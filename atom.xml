<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到lionsom的blog</title>
  
  <subtitle>人生苦短，天马行空！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-16T17:05:40.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lionsom</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中FlatBuffers的使用</title>
    <link href="http://yoursite.com/2018/08/15/iOS%E4%B8%ADFlatBuffers%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/15/iOS中FlatBuffers的使用/</id>
    <published>2018-08-15T15:45:36.000Z</published>
    <updated>2018-08-16T17:05:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章首发于<a href="http://lionsom.com" target="_blank" rel="noopener">个人blog</a></strong></p><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong></p><p><strong>原文地址：<a href="http://lionsom.com/2018/08/15/iOS中FlatBuffers的使用/" target="_blank" rel="noopener">iOS中FlatBuffers的使用</a></strong></p></blockquote><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><strong><a href="https://github.com/google/flatbuffers" target="_blank" rel="noopener">GitHub - Google / flatbuffers</a></strong><br><a href="http://google.github.io/flatbuffers/index.html" target="_blank" rel="noopener">FlatBuffer官网</a></p><a id="more"></a><h2 id="iOS-相关Demo"><a href="#iOS-相关Demo" class="headerlink" title="iOS 相关Demo"></a>iOS 相关Demo</h2><p><strong><a href="https://github.com/jidibingren/FlatBuffers-ObjC" target="_blank" rel="noopener">FlatBuffers-ObjC</a></strong><br><strong><a href="https://github.com/mrzhao12/NSStream" target="_blank" rel="noopener">NSStream</a></strong><br><strong><a href="https://github.com/TomZid/FlatBuffers_useage" target="_blank" rel="noopener">FlatBuffers_useage</a></strong><br><strong><a href="https://github.com/huoyi2000/FlatBuffer" target="_blank" rel="noopener">FlatBuffer</a></strong><br><strong><a href="https://github.com/mzaks/FlatBuffersSwift" target="_blank" rel="noopener">FlatBuffersSwift</a></strong></p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><a href="http://www.iqiyi.com/w_19rum2zoc1.html" target="_blank" rel="noopener">JSON之后的下一代数据交换格式FlaterBuffer</a></p><h2 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h2><p><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/FlatBuffers-encode.md" target="_blank" rel="noopener">推荐 – 深入浅出 FlatBuffers 之 Encode</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/FlatBuffers-schema.md" target="_blank" rel="noopener">推荐 – 深入浅出 FlatBuffers 之 Schema</a><br><a href="https://www.oschina.net/news/75092/android-flatbuffers-json" target="_blank" rel="noopener">Android 开发者应该使用 FlatBuffers 替代 JSON ?</a><br>– <strong><a href="https://github.com/amitshekhariitbhu/FlatBuffer" target="_blank" rel="noopener">对应的Demo - FlatBuffer</a></strong><br><a href="https://race604.com/flatbuffers-intro/" target="_blank" rel="noopener">FlatBuffers 体验</a><br><a href="https://www.jianshu.com/p/8df23cd182ec" target="_blank" rel="noopener">FlatBuffers入门简介</a><br><a href="http://blog.51cto.com/onebig/2122019" target="_blank" rel="noopener">flatBuffer安装及使用教程</a><br><a href="https://www.csdn.net/article/2015-08-31/2825579" target="_blank" rel="noopener">开源、高效、跨平台：深剖Google FlatBuffers工作原理</a><br><a href="https://www.jianshu.com/p/972c008177b8" target="_blank" rel="noopener">NSStream封装和FlatBuffer数据解析</a><br>– <strong><a href="https://github.com/mrzhao12/NSStream" target="_blank" rel="noopener">对应的Demo - NSStream</a></strong><br><a href="https://www.aliyun.com/jiaocheng/59674.html?spm=5176.100034.2.1.T9Nbah" target="_blank" rel="noopener">高效数据序列化的工具 FlatBuffers 的初体验</a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><h4 id="一、JSON-与-FlatBuffers-比较与使用场景"><a href="#一、JSON-与-FlatBuffers-比较与使用场景" class="headerlink" title="一、JSON 与 FlatBuffers 比较与使用场景"></a>一、<code>JSON</code> 与 <code>FlatBuffers</code> 比较与使用场景</h4></li><li><h4 id="二、FlatBuffers-环境搭建"><a href="#二、FlatBuffers-环境搭建" class="headerlink" title="二、FlatBuffers 环境搭建"></a>二、<code>FlatBuffers</code> 环境搭建</h4><ul><li><h5 id="2-1、CMake-安装"><a href="#2-1、CMake-安装" class="headerlink" title="2.1、CMake 安装"></a>2.1、<code>CMake</code> 安装</h5></li><li><h5 id="2-2、编译生成-flatc-工具"><a href="#2-2、编译生成-flatc-工具" class="headerlink" title="2.2、编译生成 flatc 工具"></a>2.2、编译生成 <code>flatc</code> 工具</h5></li><li><h5 id="2-3、编写-FlatBuffers-的-scheme-文件"><a href="#2-3、编写-FlatBuffers-的-scheme-文件" class="headerlink" title="2.3、编写 FlatBuffers 的 scheme 文件"></a>2.3、编写 <code>FlatBuffers</code> 的 <code>scheme</code> 文件</h5></li><li><h5 id="2-4、使用-flatc-工具编译-scheme-文件，生成对应语言的数据对象头文件-类"><a href="#2-4、使用-flatc-工具编译-scheme-文件，生成对应语言的数据对象头文件-类" class="headerlink" title="2.4、使用 flatc 工具编译 scheme 文件，生成对应语言的数据对象头文件/类"></a>2.4、使用 <code>flatc</code> 工具编译 <code>scheme</code> 文件，生成对应语言的数据对象头文件/类</h5></li><li><h5 id="2-5、使用各自语言的-FlatBuffers-库-序列化对象-反序列化数据对象"><a href="#2-5、使用各自语言的-FlatBuffers-库-序列化对象-反序列化数据对象" class="headerlink" title="2.5、使用各自语言的 FlatBuffers 库 序列化对象/反序列化数据对象"></a>2.5、使用各自语言的 <code>FlatBuffers</code> 库 序列化对象/反序列化数据对象</h5></li></ul></li><li><h4 id="三、iOS-从零使用-FlatBuffers"><a href="#三、iOS-从零使用-FlatBuffers" class="headerlink" title="三、iOS 从零使用 FlatBuffers"></a>三、<code>iOS</code> 从零使用 <code>FlatBuffers</code></h4></li><li><h4 id="四、FlatBuffers-原理"><a href="#四、FlatBuffers-原理" class="headerlink" title="四、FlatBuffers 原理"></a>四、<code>FlatBuffers</code> 原理</h4><ul><li><h5 id="4-1、官网概述"><a href="#4-1、官网概述" class="headerlink" title="4.1、官网概述"></a>4.1、官网概述</h5></li><li><h5 id="4-2、拿我们iOS的Demo做个分析"><a href="#4-2、拿我们iOS的Demo做个分析" class="headerlink" title="4.2、拿我们iOS的Demo做个分析"></a>4.2、拿我们iOS的Demo做个分析</h5></li></ul></li></ul><hr><hr><h1 id="一、JSON-与-FlatBuffers-比较与使用场景-1"><a href="#一、JSON-与-FlatBuffers-比较与使用场景-1" class="headerlink" title="一、JSON 与 FlatBuffers 比较与使用场景"></a>一、<code>JSON</code> 与 <code>FlatBuffers</code> 比较与使用场景</h1><p><a href="https://race604.com/flatbuffers-intro/" target="_blank" rel="noopener">了解更多：FlatBuffers 体验</a></p><h3 id="1-1、JSON-简介"><a href="#1-1、JSON-简介" class="headerlink" title="1.1、JSON 简介"></a>1.1、JSON 简介</h3><blockquote><p>优点：易读性，跨平台<br>缺点：性能差，内存占用多，需要解析、打包</p></blockquote><p>JSON是不依赖于开发语言的数据格式，但是在解析数据并将其转换到如Java对象时，会消耗我们的时间和存储资源。</p><p><img src="https://upload-images.jianshu.io/upload_images/1859399-05480d370b061453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JSON数据传输过程"></p><h3 id="1-2、FlatBuffers-简介"><a href="#1-2、FlatBuffers-简介" class="headerlink" title="1.2、FlatBuffers 简介"></a>1.2、FlatBuffers 简介</h3><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>1、直接读取序列化数据，而不需要解析（Parsing）或者解包（Unpacking）：FlatBuffer 把数据层级结构保存在一个扁平化的二进制缓存（一维数组）中，同时能够保持直接获取里面的结构化数据，而不需要解析，并且还能保证数据结构变化的前后向兼容。<br>2、高效的内存使用和速度：FlatBuffer 使用过程中，不需要额外的内存，几乎接近原始数据在内存中的大小。<br>3、灵活：数据能够前后向兼容，并且能够灵活控制你的数据结构。<br>4、很少的代码侵入性：使用少量的自动生成的代码即可实现。<br>5、强数据类性，易于使用，跨平台，几乎语言无关。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>1、FlatBuffers 需要生成代码，对代码有侵入性；<br>2、数据序列化没有可读性，不方便 Debug；<br>3、构建 FlatBuffers 对象比较麻烦，不直观，特别是如果对象比较复杂情况下需要写大段的代码；<br>4、数据的所有内容需要使用 Schema 严格定义，灵活性不如 JSON。</p><p><a href="https://github.com/google/flatbuffers" target="_blank" rel="noopener">FlatBuffers</a>是Google专门为游戏开发而创建的跨平台序列化库，<code>FlatBuffers</code> 是一个开源的跨平台数据序列化库，可以应用到几乎任何语言（C++, C#, Go, Java, JavaScript, PHP, Python）</p><h5 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h5><p>项目中有大量数据传输和解析,使用 JSON 成为了性能瓶颈;<br>稳定的数据结构定义。 </p><h1 id="二、FlatBuffers-环境搭建-1"><a href="#二、FlatBuffers-环境搭建-1" class="headerlink" title="二、FlatBuffers 环境搭建"></a>二、FlatBuffers 环境搭建</h1><h3 id="2-1、Cmake安装"><a href="#2-1、Cmake安装" class="headerlink" title="2.1、Cmake安装"></a>2.1、Cmake安装</h3><h5 id="2-1-1、查看是否安装cmake"><a href="#2-1-1、查看是否安装cmake" class="headerlink" title="2.1.1、查看是否安装cmake"></a>2.1.1、查看是否安装cmake</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure><h5 id="2-1-2、Mac安装cmake"><a href="#2-1-2、Mac安装cmake" class="headerlink" title="2.1.2、Mac安装cmake"></a>2.1.2、Mac安装cmake</h5><h5 id="方法一：推荐Homebrew自动安装"><a href="#方法一：推荐Homebrew自动安装" class="headerlink" title="方法一：推荐Homebrew自动安装"></a>方法一：<strong>推荐<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>自动安装</strong></h5><h6 id="Homebrew简介"><a href="#Homebrew简介" class="headerlink" title="Homebrew简介"></a>Homebrew简介</h6><ul><li><p>是否安装<code>brew</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew --version</span><br></pre></td></tr></table></figure></li><li><p>安装<code>brew</code>只需要一条命令即可：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><ul><li>brew常用命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">搜索软件：brew search 软件名，如brew search wget</span><br><span class="line">安装软件：brew install 软件名，如brew install wget</span><br><span class="line">卸载软件：brew remove 软件名，如brew remove wget</span><br></pre></td></tr></table></figure><h6 id="cmake具体安装"><a href="#cmake具体安装" class="headerlink" title="cmake具体安装"></a>cmake具体安装</h6><ul><li>第一步：brew search cmake</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1859399-511ac92688b5bcd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="brew search cmake"></p><ul><li>第二步：brew install cmake</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1859399-d45cdb05e32bbc91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="brew install cmake"></p><ul><li>第三步：cmake –version</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1859399-9b6f285cb5a98ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cmake --version"></p><h5 id="方法二：手动下载安装"><a href="#方法二：手动下载安装" class="headerlink" title="方法二：手动下载安装"></a>方法二：<a href="https://blog.csdn.net/baimafujinji/article/details/78588488" target="_blank" rel="noopener">手动下载</a>安装</h5><p>前往 <a href="https://cmake.org/download/" target="_blank" rel="noopener">cmake</a> 官网，下载Mac操作系统对应的安装包。</p><p><img src="https://upload-images.jianshu.io/upload_images/1859399-c0fd14de18c91fb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载Mac指定包"></p><h3 id="2-2、编译生成-flatc-工具-1"><a href="#2-2、编译生成-flatc-工具-1" class="headerlink" title="2.2、编译生成 flatc 工具"></a>2.2、编译生成 <code>flatc</code> 工具</h3><p><a href="http://google.github.io/flatbuffers/md__building.html" target="_blank" rel="noopener">官网building</a><br><a href="https://www.jianshu.com/p/8df23cd182ec" target="_blank" rel="noopener">也可以参考blog - FlatBuffers入门简介</a></p><ul><li><p>前往 <strong><a href="https://github.com/google/flatbuffers" target="_blank" rel="noopener">flatbuffers</a></strong> 下载源码</p></li><li><p>前往本地 <code>flatbuffers</code> 根目录下，输入如下命令：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G &quot;Unix Makefiles&quot;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1859399-9733f55db08cdbc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="过程图"></p><ul><li>稍等一会cmake就完成了MakeFile的生成，接下来运行：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1859399-8aad2c642477b601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="make过程图"></p><ul><li>开始编译，稍等一会编译成功后会在根目录下生成flatc工具。<br>接下来我们使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1859399-ee2a63399fba7bbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="install过程图"></p><p>该命令，安装flatc，该命令将flatc工具拷贝到/usr/local/bin/目录下（环境配置不同可能有所不同），重新启动终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatc --version</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1859399-2cec8d0a15a93b11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出flatc版本号"></p><ul><li>最后可以在源码中发现，多出一个<code>flatc</code> 的文件</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1859399-510379f6d7f192b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多出一个文件"></p><h3 id="2-3、编写FlatBuffers的scheme文件"><a href="#2-3、编写FlatBuffers的scheme文件" class="headerlink" title="2.3、编写FlatBuffers的scheme文件"></a>2.3、编写FlatBuffers的scheme文件</h3><p>官网有样例 <a href="https://google.github.io/flatbuffers/flatbuffers_guide_tutorial.html" target="_blank" rel="noopener">Tutorial</a>，也可以前往 <a href="https://google.github.io/flatbuffers/flatbuffers_guide_writing_schema.html" target="_blank" rel="noopener">官网-Writing a schema</a> 查看其规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// example IDL file</span><br><span class="line"></span><br><span class="line">namespace MyGame;</span><br><span class="line"></span><br><span class="line">attribute &quot;priority&quot;;</span><br><span class="line"></span><br><span class="line">enum Color : byte &#123; Red = 1, Green, Blue &#125;</span><br><span class="line"></span><br><span class="line">union Any &#123; Monster, Weapon, Pickup &#125;</span><br><span class="line"></span><br><span class="line">struct Vec3 &#123;</span><br><span class="line">  x:float;</span><br><span class="line">  y:float;</span><br><span class="line">  z:float;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table Monster &#123;</span><br><span class="line">  pos:Vec3;</span><br><span class="line">  mana:short = 150;</span><br><span class="line">  hp:short = 100;</span><br><span class="line">  name:string;</span><br><span class="line">  friendly:bool = false (deprecated, priority: 1);</span><br><span class="line">  inventory:[ubyte];</span><br><span class="line">  color:Color = Blue;</span><br><span class="line">  test:Any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root_type Monster;</span><br></pre></td></tr></table></figure><h3 id="2-4、使用-flatc-工具编译-scheme-文件，生成对应语言的数据对象头文件-类-1"><a href="#2-4、使用-flatc-工具编译-scheme-文件，生成对应语言的数据对象头文件-类-1" class="headerlink" title="2.4、使用 flatc 工具编译 scheme 文件，生成对应语言的数据对象头文件/类"></a>2.4、使用 flatc 工具编译 scheme 文件，生成对应语言的数据对象头文件/类</h3><p><a href="https://google.github.io/flatbuffers/flatbuffers_guide_using_schema_compiler.html" target="_blank" rel="noopener">了解更多-Using the schema compiler</a></p><p><strong>例子：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./flatc --java Person.fbs</span><br></pre></td></tr></table></figure></p><h3 id="2-5、使用各自语言的-FlatBuffers-库-序列化对象-反序列化数据对象-1"><a href="#2-5、使用各自语言的-FlatBuffers-库-序列化对象-反序列化数据对象-1" class="headerlink" title="2.5、使用各自语言的 FlatBuffers 库 序列化对象/反序列化数据对象"></a>2.5、使用各自语言的 FlatBuffers 库 序列化对象/反序列化数据对象</h3><p><strong><a href="https://github.com/amitshekhariitbhu/FlatBuffer" target="_blank" rel="noopener">Android Sample Application</a></strong></p><hr><hr><h1 id="三、iOS从零使用flatbuffers"><a href="#三、iOS从零使用flatbuffers" class="headerlink" title="三、iOS从零使用flatbuffers"></a>三、iOS从零使用flatbuffers</h1><blockquote><p>系统环境：MacOS<br>编程语言：OC</p></blockquote><p>说明：<br>如果我们通过 <strong><a href="https://github.com/google/flatbuffers" target="_blank" rel="noopener">flatbuffers</a></strong> 官网下载的代码，并通过上面一系列的流程后，当走到使用 <code>flatc</code> 工具编译生成 <code>特定的OC的 .h 和 .m 文件</code>时候发现，生成失败。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./flatc -oc AAA.fbs</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1859399-a592cc2b8d9a29b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成失败"></p><h3 id="在github找到-FlatBuffers-ObjC-库"><a href="#在github找到-FlatBuffers-ObjC-库" class="headerlink" title="在github找到 FlatBuffers-ObjC 库"></a>在github找到 <strong><a href="https://github.com/jidibingren/FlatBuffers-ObjC" target="_blank" rel="noopener">FlatBuffers-ObjC</a></strong> 库</h3><p>ReadME如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.  git clone [https://github.com/jidibingren/FlatBuffers-ObjC.git](https://github.com/jidibingren/FlatBuffers-ObjC.git)</span><br><span class="line"></span><br><span class="line">2.  open rootdir/FlatBuffer/build_ide/Xcode/FlatBuffers.xcodeproj and build flatc target</span><br><span class="line"></span><br><span class="line">3.  ./flatc -oc test.fbs</span><br><span class="line"></span><br><span class="line">4.  import the files into your project generated for step 3</span><br><span class="line"></span><br><span class="line">5.  add pod &apos;FlatBuffers-ObjC&apos; to your Podfile</span><br></pre></td></tr></table></figure></p><h5 id="3-1、按照库的指引进行生成-flatc-工具"><a href="#3-1、按照库的指引进行生成-flatc-工具" class="headerlink" title="3.1、按照库的指引进行生成 flatc 工具"></a>3.1、按照库的指引进行生成 <code>flatc</code> 工具</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open rootdir/FlatBuffer/build_ide/Xcode/FlatBuffers.xcodeproj and build flatc target</span><br></pre></td></tr></table></figure><p>会自动生成 <code>flatc</code> 工具</p><p><img src="https://upload-images.jianshu.io/upload_images/1859399-595efb29679c0ad4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flatc工具"></p><h5 id="3-2、编译-scheme-文件"><a href="#3-2、编译-scheme-文件" class="headerlink" title="3.2、编译 scheme 文件"></a>3.2、编译 scheme 文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./flatc -oc test.fbs</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1859399-bed8d1d8ee544527.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OC文件"></p><h5 id="3-3、实际项目使用"><a href="#3-3、实际项目使用" class="headerlink" title="3.3、实际项目使用"></a>3.3、实际项目使用</h5><p><img src="https://upload-images.jianshu.io/upload_images/1859399-a142382d3ce05b45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入需要的一些文件"></p><p><img src="https://upload-images.jianshu.io/upload_images/1859399-69e723d03333036f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目截图"></p><h6 id="对象编码、解码"><a href="#对象编码、解码" class="headerlink" title="对象编码、解码"></a>对象编码、解码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[Person alloc]init];</span><br><span class="line">person.name = @&quot;张三&quot;;</span><br><span class="line">person.sex = @&quot;男&quot;;</span><br><span class="line"></span><br><span class="line">// 编码：对象-&gt;data</span><br><span class="line">NSData * data = [person getData];</span><br><span class="line"></span><br><span class="line">// 解码：</span><br><span class="line">Person *person = (Person *)[Person getRootAs:data];</span><br><span class="line">NSLog(@&quot;name == %@ sex == %@&quot;, person.name, person.sex);</span><br></pre></td></tr></table></figure><hr><hr><h1 id="四、FlatBuffers-原理-1"><a href="#四、FlatBuffers-原理-1" class="headerlink" title="四、FlatBuffers 原理"></a>四、<code>FlatBuffers</code> 原理</h1><p><a href="https://race604.com/flatbuffers-intro/" target="_blank" rel="noopener">了解更多-FlatBuffers 体验</a></p><h3 id="4-1、官网概述-1"><a href="#4-1、官网概述-1" class="headerlink" title="4.1、官网概述"></a>4.1、官网概述</h3><p><strong>FlatBuffers</strong> 就像它的名字所表示的一样，就是把结构化的对象，用一个扁平化（Flat）的缓冲区保存，简单的来说就是把内存对象数据，保存在一个一维的数组中。借用 <a href="[https://code.facebook.com/posts/872547912839369/improving-facebook-s-performance-on-android-with-flatbuffers/](https://code.facebook.com/posts/872547912839369/improving-facebook-s-performance-on-android-with-flatbuffers/">Facebook 文章</a><br>) 的一张图如下：</p><p> <img src="https://upload-images.jianshu.io/upload_images/1859399-afce6d1a4120cf91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flatbuffers"></p><p>可见，FlatBuffers 保存在一个 byte 数组中，有一个“支点”指针（pivot point）以此为界，存储的内容分为两个部分：元数据和数据内容。其中元数据部分就是数据在前面，其长度等于对象中的字段数量，每个 byte 保存对应字段内容在数组中的索引（从支点位置开始计算）。</p><p>如图，上面的 Person 对象第一个字段是 name，其值的索引位置是 1，所以从索引位置 1 开始的字符串，就是 name 字段的值 “John”。第二个字段是 friendshipStatus，其索引值是 6，找到值为 2， 表示 NotFriend。第三个字段是 spouse，也一个 Person 对象，索引值是 12，指向的是此对象的支点位置。第四个字段是一个数组，图中表示的数组为空，所以索引值是 0。</p><p>通过上面的解析，可以看出，FlatBuffers 通过自己分配和管理对象的存储，使对象在内存中就是线性结构化的，直接可以把内存内容保存或者发送出去，加载“解析”数据只需要把 byte 数组加载到内存中即可，不需要任何解析，也不产生任何中间变量。</p><p>它与具体的机器或者运行环境无关，例如在 Java 中，对象内的内存不依赖 Java 虚拟机的堆内存分配策略实现，所以也是跨平台的。</p><h3 id="4-2、拿我们iOS的Demo做个分析-1"><a href="#4-2、拿我们iOS的Demo做个分析-1" class="headerlink" title="4.2、拿我们iOS的Demo做个分析"></a>4.2、拿我们iOS的Demo做个分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[Person alloc]init];</span><br><span class="line">person.name = @&quot;张三&quot;;</span><br><span class="line">person.sex = @&quot;男&quot;;</span><br><span class="line"></span><br><span class="line">// 编码：对象-&gt;data</span><br><span class="line">NSData * data = [person getData];</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1859399-df6033dd3d6ce030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="根据person对象编码生成的Bytes数组"></p><p><strong>回头再看看Flatc生成的person.m文件中的内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *) name &#123;</span><br><span class="line">    _name = [self fb_getString:4 origin:_name];</span><br><span class="line">    return _name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) add_name &#123;</span><br><span class="line">    [self fb_addString:_name voffset:4 offset:4];</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *) sex &#123;</span><br><span class="line">    _sex = [self fb_getString:6 origin:_sex];</span><br><span class="line">    return _sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) add_sex &#123;</span><br><span class="line">    [self fb_addString:_sex voffset:6 offset:8];</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        bb_pos = 14;</span><br><span class="line">        origin_size = 12+bb_pos;</span><br><span class="line">        bb = [[FBMutableData alloc]initWithLength:origin_size];</span><br><span class="line">        [bb setInt32:bb_pos offset:0];</span><br><span class="line">        [bb setInt32:8 offset:bb_pos];</span><br><span class="line">        [bb setInt16:8 offset:bb_pos-[bb getInt32:bb_pos]];</span><br><span class="line">        [bb setInt16:12 offset:bb_pos-[bb getInt32:bb_pos]+2];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现代码内部也给我们设置一定的偏移参数，具体的没有深入研究，仅仅看到表面，我们大概也猜到这是在为我们的编码进行准备。</p><p><strong>最后我们验证下，在我们的bytes数组中，是否有@”张三”、@”男”等数据的存在，这里我们单独将@”张三”、@”男”转成bytes数组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSString * nametest = @&quot;张三&quot;;</span><br><span class="line">NSString * sextest = @&quot;男&quot;;</span><br><span class="line">    </span><br><span class="line">// NSString --&gt; NSData</span><br><span class="line">NSData *nametestdata = [nametest dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">NSData *sextestdata = [sextest dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">// NSData --&gt; Byte</span><br><span class="line">Byte *nametestbytes = (Byte *)[nametestdata bytes];</span><br><span class="line">Byte *sextestbytes = (Byte *)[sextestdata bytes];</span><br><span class="line">    </span><br><span class="line">for (int j = 0; j &lt; nametestdata.length; j++) &#123;</span><br><span class="line">    NSLog(@&quot;nametestbytes[%d] = %d&quot;,j,nametestbytes[j]);</span><br><span class="line">&#125;</span><br><span class="line">for (int j = 0; j &lt; sextestdata.length; j++) &#123;</span><br><span class="line">    NSLog(@&quot;sextestbytes[%d] = %d&quot;,j,sextestbytes[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/1859399-802d47bcab5b192d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="@&quot;张三&quot;的bytes数组"></p><p><img src="https://upload-images.jianshu.io/upload_images/1859399-999ce35247bca3cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="@&quot;男&quot;的bytes数组"></p><p><strong>到了这里我们发现，”张三”、”男”数据都在 flatbuffers 中，并且也在数据内容这边，与官网描述的原理是一致的。</strong></p><p><strong>但是flatc生成的OC对象时候是如何分配存储空间的，如何确定”支点”、”元数据”、”数据内容”的暂时还没有深入研究，此处也只是简单的了解下原理。期待各位更深入的研究。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;文章首发于&lt;a href=&quot;http://lionsom.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人blog&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎指正补充，可联系&lt;a href=&quot;lionsom_lin@qq.com&quot;&gt;lionsom_lin@qq.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原文地址：&lt;a href=&quot;http://lionsom.com/2018/08/15/iOS中FlatBuffers的使用/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS中FlatBuffers的使用&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/google/flatbuffers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub - Google / flatbuffers&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://google.github.io/flatbuffers/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FlatBuffer官网&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="FlatBuffers" scheme="http://yoursite.com/tags/FlatBuffers/"/>
    
      <category term="JSON" scheme="http://yoursite.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>OC中属性和成员变量（二）面试篇</title>
    <link href="http://yoursite.com/2018/07/17/OC%E4%B8%AD%E5%B1%9E%E6%80%A7%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    <id>http://yoursite.com/2018/07/17/OC中属性和成员变量（二）面试篇/</id>
    <published>2018-07-17T15:58:38.000Z</published>
    <updated>2018-07-17T16:46:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章首发于<a href="http://lionsom.com" target="_blank" rel="noopener">个人blog</a></strong></p><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong></p><p><strong>原文地址：<a href="http://lionsom.com/2018/06/30/OC中属性和成员变量（二）面试篇/" target="_blank" rel="noopener">OC中属性和成员变量（一）概念篇</a></strong></p></blockquote><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2><ul><li><a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="noopener">招聘一个靠谱的 iOS</a> 其中就包括对@property的提问。</li></ul><h3 id="一、引入-property相关的面试题"><a href="#一、引入-property相关的面试题" class="headerlink" title="一、引入@property相关的面试题"></a>一、引入@property相关的面试题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@property 后面可以有哪些修饰符？</span><br><span class="line"></span><br><span class="line">什么情况使用 weak 关键字，相比 assign 有什么不同？</span><br><span class="line"></span><br><span class="line">怎么用 copy 关键字？</span><br><span class="line"></span><br><span class="line">这个写法会出什么问题： @property (copy) NSMutableArray *array;</span><br><span class="line"></span><br><span class="line">如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</span><br><span class="line"></span><br><span class="line">@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</span><br><span class="line"></span><br><span class="line">@protocol 和 category 中如何使用 @property</span><br><span class="line"></span><br><span class="line">runtime 如何实现 weak 属性</span><br><span class="line"></span><br><span class="line">[※]@property中有哪些属性关键字？</span><br><span class="line">[※]weak属性需要在dealloc中置nil么？</span><br><span class="line">[※※]@synthesize和@dynamic分别有什么作用？</span><br><span class="line">[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</span><br><span class="line">[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</span><br><span class="line">[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</span><br><span class="line">[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;文章首发于&lt;a href=&quot;http://lionsom.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人blog&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎指正补充，可联系&lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OC中属性和成员变量（一）概念篇</title>
    <link href="http://yoursite.com/2018/07/12/OC%E4%B8%AD%E5%B1%9E%E6%80%A7%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E5%BF%B5%E7%AF%87/"/>
    <id>http://yoursite.com/2018/07/12/OC中属性和成员变量（一）概念篇/</id>
    <published>2018-07-12T14:54:32.000Z</published>
    <updated>2018-08-15T15:22:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章首发于<a href="http://lionsom.com" target="_blank" rel="noopener">个人blog</a></strong></p><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong></p><p><strong>原文地址：<a href="http://lionsom.com/2018/07/12/OC中属性和成员变量（一）概念篇/" target="_blank" rel="noopener">OC中属性和成员变量（一）概念篇</a></strong></p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>一、什么是成员变量？<ul><li>成员变量的访问权限</li><li>.h文件与.m文件中的@interface声明成员变量的区别？</li><li>.m文件中@implementation声明变量?</li></ul></li><li>二、成员变量与实例变量的区别</li><li>三、属性<ul><li>3.1、@property 历史</li><li>3.2、@dynamic - 如果我们不想编译器给我们属性进行自动合成</li><li>3.3、如何自己重写 setter / getter?</li><li>3.4、self.myTitle 与 _myTitle的区别、本质、哪个更好？</li></ul></li><li>四、属性的特质<ul><li>4.1、原子性关键字</li><li>4.2、读/写权限</li><li>4.3、内存管理</li><li>4.4、方法名</li></ul></li><li>五、实际使用属性<ul><li>5.1、不要在init 和 dealloc 中使用 accessor 即 self.XX</li></ul></li></ul><a id="more"></a><h2 id="一、什么是成员变量？"><a href="#一、什么是成员变量？" class="headerlink" title="一、什么是成员变量？"></a>一、什么是成员变量？</h2><h3 id="成员变量的访问权限"><a href="#成员变量的访问权限" class="headerlink" title="成员变量的访问权限"></a>成员变量的访问权限</h3><ul><li>@public：在任何地方都能直接访问对象的成员变量</li><li>@private：只能在 <strong>当前类</strong> 的对象方法中直接访问,如果子类要访问需要调用父类的get/set方法</li><li>@protected：可以在 <strong>当前类及其子类对象</strong> 方法中直接访问，<strong><em>变量默认的访问权限就是 protected</em></strong></li><li>@package：对于framework内部的类是@protected的权限，对于外部的类是@private，相当于框架级的保护权限，适合使用在静态库.a中。</li></ul><h3 id="场景设置"><a href="#场景设置" class="headerlink" title="场景设置"></a>场景设置</h3><p><img src="https://upload-images.jianshu.io/upload_images/1859399-d723875957fe5434.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Student父类"></p><p><img src="https://upload-images.jianshu.io/upload_images/1859399-e8a04c04c7ff5da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MidStudent子类"></p><blockquote><p>结论：我们在.m里面声明的变量，子类是无法访问的(即使给他@public)，也会被认为是@private，所以我们的对外属性都会放到.h去声明，然而由于 _C 变量是 @private ，所以子类还是无法访问的。</p></blockquote><h4 id="外部调用MidStudent"><a href="#外部调用MidStudent" class="headerlink" title="外部调用MidStudent"></a>外部调用MidStudent</h4><p><img src="https://upload-images.jianshu.io/upload_images/1859399-70a13b88047d427c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="外部创建MidStudent对象"></p><blockquote><p>结论：由于我们没有在Student或他的子类里面,所以只能访问.h中@public修饰的变量,也就是name,由于age是@protrcted在外部是不能被访问的!</p></blockquote><h3 id="h文件与-m文件中的-interface声明成员变量的区别？"><a href="#h文件与-m文件中的-interface声明成员变量的区别？" class="headerlink" title=".h文件与.m文件中的@interface声明成员变量的区别？"></a>.h文件与.m文件中的<code>@interface</code>声明成员变量的区别？</h3><p><a href="https://blog.csdn.net/u013378438/article/details/44491703" target="_blank" rel="noopener">OC中的分类与类扩展</a><br><a href="https://www.cnblogs.com/lisa090818/p/4772838.html" target="_blank" rel="noopener">iOS中，在类的源文件(.m)中，@interface部分的作用？</a></p><p>在.m中的@interface部分为 <strong>类扩展（class extention）</strong>。</p><p>其被设计出来就是为了解决两个问题的，<br>其一，定义类私有方法的地方。<br>其二，实现public readonly,private readwrite的property（意思是在h头文件中定义一个属性对外是readonly的，但在类的内部希望是可读写的，所以可以在m源文件中的@interface部分重新定义此属性为readwrite，此时此属性对外是只读的，对内是读写的）。<br>最后，若在此部分申明变量和属性，但申明的变量，属性和方法均为私有的，只能够被当前类访问，相当于private。</p><h3 id="m文件中-implementation声明变量"><a href="#m文件中-implementation声明变量" class="headerlink" title=".m文件中@implementation声明变量?"></a>.m文件中@implementation声明变量?</h3><ul><li>如果没有 <code>{}</code> 则为全局变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@implementation Study_Ivar_Student</span><br><span class="line"></span><br><span class="line">int ABC = 10;</span><br></pre></td></tr></table></figure><ul><li>如果有 <code>{}</code> 则为成员变量，但是为私有的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@implementation Study_Ivar_Student</span><br><span class="line">&#123;</span><br><span class="line">@public</span><br><span class="line">    NSString * AAA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="interface-VS-implementation-声明变量"><a href="#interface-VS-implementation-声明变量" class="headerlink" title="@interface VS @implementation 声明变量?"></a>@interface VS @implementation 声明变量?</h3><p>@interface中的是成员变量，子类可继承使用，它的存活周期和创建的实体是一样的，在一个控制器中，随控制器的产生和销毁而创建和销毁；<br>@implementation下定义的是全局变量，如果加了｛｝则为成员变量，但是为私有的，否则为全局变量。</p><h2 id="二、成员变量与实例变量的区别"><a href="#二、成员变量与实例变量的区别" class="headerlink" title="二、成员变量与实例变量的区别"></a>二、成员变量与实例变量的区别</h2><p><a href="https://my.oschina.net/360yg/blog/1626086" target="_blank" rel="noopener">iOS 中成员变量、实例变量、属性 三者区别与联系</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Study_IvarVC : UIViewController</span><br><span class="line">&#123;</span><br><span class="line">    UIButton *yourButton;</span><br><span class="line">    int count;</span><br><span class="line">    id data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UIButton *myButton;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>上述哪些是实例变量？哪些是成员变量？</strong><br>在{   } 中所声明的变量都为成员变量。 所以yourButton、count、data都是成员变量。<br>既然如此，实例变量又是什么意思呢？<br>实例变量本质上就是成员变量，只是实例是针对类而言，实例是指类的声明。{   }中的yourButton就是实例变量。id 是OC特有的类，本质上讲id等同于（void *）。所以id data属于实例变量。</p><p>可以看到在接口 @interface 括号里面的统称为”成员变量”，实例变量是成员变量中的一种！<br>实例变量的英文翻译是 Instance Variable (object-specific storage)<br>实例的英文翻译为Instance(manifestation  of a  class)  说的是“类的表现”，说明实例变量应该是由类定义的变量！<br>除去基本数据类型int float ….等，其他类型的变量都叫做实例变量。<br><strong>实例变量+基本数据类型变量=成员变量</strong></p><h2 id="三、属性"><a href="#三、属性" class="headerlink" title="三、属性"></a>三、属性</h2><p><a href="https://www.jianshu.com/p/8e6606ce759d" target="_blank" rel="noopener">IOS属性的作用</a><br><a href="https://blog.csdn.net/mccand1234/article/details/52733270" target="_blank" rel="noopener">OC中在.h和.m中声明的属性和成员变量</a></p><h4 id="3-1、-property-历史"><a href="#3-1、-property-历史" class="headerlink" title="3.1、@property 历史"></a>3.1、@property 历史</h4><p>iOS5之前，在苹果使用GCC编译器时候，属性的使用方式是：<strong>也就是手动声明实例变量</strong>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">***.h***</span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line">&#123;</span><br><span class="line">    //属性的实例变量</span><br><span class="line">    NSString *myTitle;</span><br><span class="line">&#125;</span><br><span class="line">//编译器遇到@property会自动声明对应的setter/getter</span><br><span class="line">@property (copy, nonatomic) NSString *myTitle;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">***.m***</span><br><span class="line">// 编译器遇到@synthesize会自动实现setter/getter方法</span><br><span class="line">// 编译器遇到@synthesize回去访问myTitle的同名变量，如果没找到就报错。</span><br><span class="line">@synthesize myTitle;</span><br></pre></td></tr></table></figure><p>iOS5之后，现在，苹果将默认编译器从 <strong>GCC转换为LLVM(low level virtual machine)</strong>，从此 <strong>不再需要为属性声明实例变量</strong> 了。如果LLVM发现一个没有匹配实例变量的属性，<strong>它将自动创建一个以下划线开头的实例变量</strong>。因此，在这个版本中，我们不再为输出口声明实例变量。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">***.h***</span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line">// 编译器遇到@property会自动声明对应的setter/getter</span><br><span class="line">@property (copy, nonatomic) NSString *myTitle;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>不隐藏代码，显示全部代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">**.h**</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">***被隐藏的代码：***</span><br><span class="line">1.这个默认是@synthesize myTitle = _myTitle;生成的</span><br><span class="line">2.所以如果我们手动设置@synthesize myTitle，那么我们编译器</span><br><span class="line">  生成的变量就是NSString *myTitle,相当于@synthesize myTitle = myTitle,</span><br><span class="line">  如果设置@synthesize myTitle = youTitle，那么编译器生成的变量就是NSString *youTitle了</span><br><span class="line">  这要注意。</span><br><span class="line">*/</span><br><span class="line">    NSString *_myTitle;</span><br><span class="line">&#125;</span><br><span class="line">@property (copy, nonatomic) NSString *myTitle;</span><br><span class="line"></span><br><span class="line">//***被隐藏的代码***</span><br><span class="line">//编译器遇到@property会自动声明setter/getter方法</span><br><span class="line">- (void)setMyTitle:(NSString *)myTitle;</span><br><span class="line">- (NSString *)myTitle;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">**.m**</span><br><span class="line">/*</span><br><span class="line">***被隐藏的代码***</span><br><span class="line">1.@synthesize关键字会自动实现setter/getter的方法</span><br><span class="line">2.@synthesize myTitle = _myTitle指明了属性myTitle的实例变量是_myTitle,setter/getter操作的对象就是_myTitle.</span><br><span class="line">*/</span><br><span class="line">@synthesize myTitle = _myTitle;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    _myTitle = @&quot;123&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//***被隐藏的代码***</span><br><span class="line">// 由关键字@synthesize自动实现</span><br><span class="line">- (NSString *)myTitle&#123;</span><br><span class="line">    return _myTitle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setMyTitle:(NSString *)myTitle&#123;</span><br><span class="line">    _myTitle = myTitle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码说明：<br>1.编译器遇到关键字@property，自动声明setter/getter方法。<br>2.编译器遇到@synthesize,自动实现setter/getter方法。<br>3.@synthesize myTitle = _myTitle;为属性myTitle生成了一个实例变量_myTitle，所以我们对属性的操作self.myTitle实质上都是在操作_myTitle变量。</p></blockquote><blockquote><p>那么问题来了：<br>1、我们能否认为新编译器<code>LLVM下的@property</code> == 老编译器<code>GCC的 成员变量+ @property + @synthesize 成员变量</code>呢？<br>答案是<code>否定的</code>。<br>因为<code>成员变量+ @property + @synthesize 成员变量</code>的形式，编译器不会帮我们生成<code>_成员变量</code>，因此不会操作<code>_成员变量</code>了；<br>2、同时<code>@synthesize</code> 还有一个作用，可以指定与属性对应的实例变量，<br>例如<code>@synthesize myString = xxx;</code><br>那么<code>self.myString</code>其实是操作的<code>实例变量xxx</code>，而非<code>_String</code>了。</p></blockquote><h4 id="3-2、-dynamic-如果我们不想编译器给我们属性进行自动合成"><a href="#3-2、-dynamic-如果我们不想编译器给我们属性进行自动合成" class="headerlink" title="3.2、@dynamic - 如果我们不想编译器给我们属性进行自动合成"></a>3.2、@dynamic - 如果我们不想编译器给我们属性进行自动合成</h4><ul><li>第一种方法：自己实现存取方法<blockquote><p>如果你只实现了其中一个存取方法，那么另一个还是会由编译器来合成。</p></blockquote></li><li>第二种方法：@dynamic关键字<blockquote><p>它会告诉编译器：不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。<br>并且在编译访问属性代码的时，及时没有定义存取方法，也不会报错，因为它相信这些方法在运行期可以找到。</p></blockquote></li></ul><p>举个例子，比方说如果从CoreData框架中的NSManagedObject类里面继承一个子类，那么就需要在运行期动态创建存取方法。继承NSManagedObject时之所以这么做，是因为子类的某些属性不是实例变量，其数据来源于后端服务器。代码下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSManagedObject</span><br><span class="line">@property NSString * firstName;</span><br><span class="line">@property NSString * lastName;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCPerson</span><br><span class="line">@dynamic firstName , lastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h4 id="3-3、如何自己重写-setter-getter"><a href="#3-3、如何自己重写-setter-getter" class="headerlink" title="3.3、如何自己重写 setter / getter?"></a>3.3、如何自己重写 <code>setter / getter</code>?</h4><p><strong>同时重写 <code>setter/getter</code> 的问题：</strong><br>我们会发现，当我们同时重写<code>setter/getter</code>时会报错，为什么呢？这是因为当我们同时重写<code>setter/getter</code>时，编译器自动添加的代码<code>@synthesize myTitle = _myTitle;</code>失效，就不会自动为我们生成实例变量<code>_myTitle</code>了，<code>setter/getter</code>操作的对象就不存在了。所以我们要加上<code>@synthesize myTitle = _myTitle;</code>,手动指定setter/getter要操作的实例对象是<code>_myTitle</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">***.h***</span><br><span class="line">@interface Study_PropertyVC : UIViewController</span><br><span class="line"></span><br><span class="line">@property (copy, nonatomic) NSString *myTitle;</span><br><span class="line"></span><br><span class="line">// 重写setter getter</span><br><span class="line">-(NSString *)myTitle;</span><br><span class="line">-(void)setMyTitle:(NSString *)myTitle;</span><br><span class="line"></span><br><span class="line">***.m***</span><br><span class="line">@implementation Study_PropertyVC</span><br><span class="line">/*</span><br><span class="line">  @synthesize必须重写</span><br><span class="line"> */</span><br><span class="line">@synthesize myTitle = _newtitle;</span><br><span class="line"></span><br><span class="line">// 重写setter getter</span><br><span class="line">- (NSString *)myTitle&#123;</span><br><span class="line">    return _newtitle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setMyTitle:(NSString *)myTitle&#123;</span><br><span class="line">    _newtitle = myTitle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4、self-myTitle-与-myTitle的区别、本质、哪个更好？"><a href="#3-4、self-myTitle-与-myTitle的区别、本质、哪个更好？" class="headerlink" title="3.4、self.myTitle 与 _myTitle的区别、本质、哪个更好？"></a>3.4、self.myTitle 与 _myTitle的区别、本质、哪个更好？</h4><p><a href="https://www.cnblogs.com/mukekeheart/p/8251366.html" target="_blank" rel="noopener">iOS学习——属性引用self.xx与_xx的区别</a><br><a href="https://www.jianshu.com/p/d9a659a21b1a" target="_blank" rel="noopener">iOS之self.xxx与_xxx的区别</a><br><a href="https://www.jianshu.com/p/1cb6ec5a4ca6" target="_blank" rel="noopener">iOS的self.xxx和_.xxx的区别</a><br><a href="https://blog.csdn.net/jeikerxiao/article/details/51374215" target="_blank" rel="noopener">OC中属性self.a与_a访问的区别</a></p><h5 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h5><blockquote><p><code>self.name</code> 是对属性的访问，是调用的 <code>name属性</code> 的 <code>getter/setter</code> 方法；<br><code>_.name</code> 是对局部变量的访问，等价于 <code>self-&gt;_name</code>，并不会调用 <code>getter/setter</code> 方法；</p><p>OC中点表达式(.)其实就是调用对象的setter和getter方法的一种快捷方式。</p></blockquote><h5 id="那么使用哪种方式更好呢？"><a href="#那么使用哪种方式更好呢？" class="headerlink" title="那么使用哪种方式更好呢？"></a>那么使用哪种方式更好呢？</h5><blockquote><p><strong>推荐使用 <code>_XX</code> 的理由：</strong><br>原因一：《Effective OC2.0》中第7条：在对象内部尽量直接访问实例变量；<br>原因二：不进过OC方法派发，速度更快；</p></blockquote><blockquote><p><strong>推荐使用 <code>self.XX</code> 的理由：</strong><br>原因一：它可以兼容 <strong>懒加载</strong>；<br>原因二：避免了使用下划线的时候忽视了self这个指针，例如 <code>self-&gt;_XX</code>；<br>原因三：<code>_XX</code> 更容易造成循环引用；<br>原因四：使用 <code>_XX</code> 是获取不到父类的 <strong>属性</strong>，因为它只是对局部变量的访问；<br>原因五：<code>self.XX</code> 使用存在内存管理等优势，更加安全可靠。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1859399-fabda3e0a9c5665a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原因四示例图：_myFFF 访问不到父类属性"></p><h5 id="综合结论"><a href="#综合结论" class="headerlink" title="综合结论"></a>综合结论</h5><blockquote><h4 id="在写入实例变量的时候，使用-self-XX-方式，通过其-“设置方法”-来设置；而在读取实例变量时候，则使用-XX-方式。此方法既能提高读取速度，又能保证相关属性的”内存管理语义”。"><a href="#在写入实例变量的时候，使用-self-XX-方式，通过其-“设置方法”-来设置；而在读取实例变量时候，则使用-XX-方式。此方法既能提高读取速度，又能保证相关属性的”内存管理语义”。" class="headerlink" title="在写入实例变量的时候，使用 self.XX 方式，通过其 “设置方法” 来设置；而在读取实例变量时候，则使用 _XX 方式。此方法既能提高读取速度，又能保证相关属性的”内存管理语义”。"></a>在写入实例变量的时候，使用 <code>self.XX</code> 方式，通过其 “设置方法” 来设置；而在读取实例变量时候，则使用 <code>_XX</code> 方式。此方法既能提高读取速度，又能保证相关属性的”内存管理语义”。</h4></blockquote><h2 id="四、属性的特质"><a href="#四、属性的特质" class="headerlink" title="四、属性的特质"></a>四、属性的特质</h2><p>按照性质可以分为四类。(原子性/内存管理语义/读写权限/setter/getter别名)</p><blockquote><ul><li>原子性: nonatomic、atomic</li><li>读写权限:readwrite(读写)、readonly(只读)</li><li>内存管理:assign、strong、 weak、unsafe_unretained、copy</li><li>方法名:getter=、setter=</li></ul><p>可选值: nullable、nonnull、null_resettable、null_unspecified<br>其中atomic，nonatomic，copy在setter/getter中实现。<br>而weak和strong等则是直接作用于成员变量上。</p></blockquote><h4 id="4-1、原子性关键字"><a href="#4-1、原子性关键字" class="headerlink" title="4.1、原子性关键字"></a>4.1、原子性关键字</h4><p>默认情况下原子性是<code>atomic</code>，由编译器所合成的方法使用锁机制保证其原子性。如果属性具备 <code>nonatomic</code> 特质，则不使用同步锁。</p><h4 id="4-2、读-写权限"><a href="#4-2、读-写权限" class="headerlink" title="4.2、读/写权限"></a>4.2、读/写权限</h4><p>默认是 <code>readwrite</code><br>具备 <code>readwrite</code> (读写)特质的属性拥有 <code>setter / getter</code> 方法。编译器会自动为其生成这两个方法。</p><p>具备 <code>readonly</code> (只读)特质的属性仅拥有 <code>getter</code> 方法。但是你可以用此特质把某个属性对外公开为只读属性，然后在实现文件中将其重定义为读写属性。（可查看《Effective Objective-C 2.0》第27条）</p><h4 id="4-3、内存管理"><a href="#4-3、内存管理" class="headerlink" title="4.3、内存管理"></a>4.3、内存管理</h4><p><a href="https://www.jianshu.com/p/48665652e4e4" target="_blank" rel="noopener">OC知识–彻底理解内存管理(MRC、ARC)</a><br><a href="https://www.jianshu.com/p/a29a0bdd5da8" target="_blank" rel="noopener">iOS中copy,strong,retain,weak和assign的区别</a><br><a href="https://www.jianshu.com/p/1928b54e1253" target="_blank" rel="noopener">iOS/OS X内存管理(一)：基本概念与原理</a></p><p>assign：setter 只会执行针对简单变量，例如int、float、NSInteger、CGFloat、CGRect等；</p><p>strong：此特质表明该属性定义了一种”拥有关系”。为这种属性设置新值。设置方法先保留新值，并释放旧值，然后再将新值设置上去。</p><p>weak：此特质表明该属性定义了一种”非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，然而在属性所指的对象遭到摧毁时，属性值也会清空。</p><p>unsafe_unretained：此特质与assign相同，但它适用于”对象类型”，该特质表达一种”非拥有关系”，当目标对象遭到摧毁时，属性值不会自动清空，这点与weak区别。</p><p>copy：此特质表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其拷贝。</p><h4 id="4-4、方法名"><a href="#4-4、方法名" class="headerlink" title="4.4、方法名"></a>4.4、方法名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">*** .h ***</span><br><span class="line">@property (nonatomic, copy, getter=show1 ,setter=show2:) NSString * myName;</span><br><span class="line"></span><br><span class="line">-(NSString *)show1;</span><br><span class="line">-(void)show2:(NSString *)myname;</span><br><span class="line"></span><br><span class="line">*** .m ***</span><br><span class="line">@implementation XXX</span><br><span class="line">@synthesize myName = _myname;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line"></span><br><span class="line">    _myname = @&quot;AAAAA&quot;;</span><br><span class="line">    LXLog(@&quot;自定义属性方法名 = %@&quot;,self.myName);</span><br><span class="line"></span><br><span class="line">    self.myName = @&quot;DDDDD&quot;;</span><br><span class="line">    LXLog(@&quot;自定义属性方法名 = %@&quot;,self.myName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重写setter getter</span><br><span class="line">-(NSString *)show1 &#123;</span><br><span class="line">    return _myname;</span><br><span class="line">&#125;</span><br><span class="line">-(void)show2:(NSString *)myName &#123;</span><br><span class="line">    _myname = [myName copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出Log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[Study_PropertyVC viewDidLoad] [line: 36] 自定义属性方法名 = AAAAA</span><br><span class="line">-[Study_PropertyVC viewDidLoad] [line: 39] 自定义属性方法名 = DDDDD</span><br></pre></td></tr></table></figure><h2 id="五、实际使用属性"><a href="#五、实际使用属性" class="headerlink" title="五、实际使用属性"></a>五、实际使用属性</h2><p>《Effective Objective-C 2.0》中第6条，第7条，第18条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*** .h ***</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">-(id)initWithFirstName:(NSString *)firstName</span><br><span class="line">              lastName:(NSString *)lastName;</span><br><span class="line"></span><br><span class="line">*** .m ***</span><br><span class="line">-(id)initWithFirstName:(NSString *)firstName</span><br><span class="line">              lastName:(NSString *)lastName &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _firstName = [firstName copy];</span><br><span class="line">        _lastName = [lastName copy];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><blockquote><p>1、应尽量使用不可变的对象，也就是说应该把这个类的两个属性都应该设为 『只读』。 （第18条）<br>2、由于是『只读』，所以不会创建”设置方法”，当我们自定义方法的时候，应该保证其属性相关属性声明的特质，也就是 <code>_firstName = [firstName copy];</code> ；  （第6条）<br>3、在对象内部尽量直接访问实例变量，这里也就是 <code>_firstName</code> ； （第7条）</p></blockquote><h4 id="5-1、不要在init-和-dealloc-中使用-accessor-即-self-XX"><a href="#5-1、不要在init-和-dealloc-中使用-accessor-即-self-XX" class="headerlink" title="5.1、不要在init 和 dealloc 中使用 accessor 即 self.XX"></a>5.1、不要在init 和 dealloc 中使用 accessor 即 self.XX</h4><h5 id="唐巧-不要在init和dealloc函数中使用accessor"><a href="#唐巧-不要在init和dealloc函数中使用accessor" class="headerlink" title="唐巧 - 不要在init和dealloc函数中使用accessor"></a><a href="http://blog.devtang.com/2011/08/10/do-not-use-accessor-in-init-and-dealloc-method/" title="不要在init和dealloc函数中使用accessor" target="_blank" rel="noopener">唐巧 - 不要在init和dealloc函数中使用accessor</a></h5><h5 id="正确实例"><a href="#正确实例" class="headerlink" title="正确实例"></a>正确实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(id)init &#123; </span><br><span class="line">     self = [super init]; </span><br><span class="line">     if (self) &#123;</span><br><span class="line">          _count = [[NSNumber alloc] initWithInteger:0]; </span><br><span class="line">     &#125;</span><br><span class="line">     return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123; </span><br><span class="line">     [_count release]; </span><br><span class="line">     [super dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="终结总结：在init和dealloc中，一定不要使用-self-XX-方式！！"><a href="#终结总结：在init和dealloc中，一定不要使用-self-XX-方式！！" class="headerlink" title="终结总结：在init和dealloc中，一定不要使用 self.XX 方式！！"></a>终结总结：在init和dealloc中，一定不要使用 <code>self.XX</code> 方式！！</h4></blockquote><h5 id="为什么呢？"><a href="#为什么呢？" class="headerlink" title="为什么呢？"></a>为什么呢？</h5><p>去 stackoverflow 上搜了一下，比较不靠谱的说法是这样少一次函数调用，更快。比较靠谱的说法是：在 init 和 dealloc 中，对象的存在与否还不确定，所以给对象发消息可能不会成功。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.jianshu.com/p/d5d1243bf7ed" target="_blank" rel="noopener">iOS开发 – 属性与成员变量</a></li><li><a href="http://blog.csdn.net/u012946824/article/details/51788565" target="_blank" rel="noopener">解惑——iOS中成员变量和属性区别</a></li><li><a href="https://www.jianshu.com/p/6ca11cbe4187" target="_blank" rel="noopener">iOS 开发中成员变量与属性的区别</a></li><li><a href="https://www.cnblogs.com/Jenaral/p/5970393.html" target="_blank" rel="noopener">iOS 成员变量，实例变量，属性变量的区别，联系</a></li><li><a href="https://www.jianshu.com/p/be00d998a4ed" target="_blank" rel="noopener">OC-成员变量和属性</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/52733270" target="_blank" rel="noopener">OC中在.h和.m中声明的属性和成员变量</a></li><li><a href="https://www.jianshu.com/p/be10e24d345f" target="_blank" rel="noopener">iOS基础深入补完计划–带你重识Property</a></li><li><a href="https://www.jianshu.com/p/20447946e1c8" target="_blank" rel="noopener">property用了千百遍、可你真的懂atomic么</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;文章首发于&lt;a href=&quot;http://lionsom.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人blog&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎指正补充，可联系&lt;a href=&quot;lionsom_lin@qq.com&quot;&gt;lionsom_lin@qq.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原文地址：&lt;a href=&quot;http://lionsom.com/2018/07/12/OC中属性和成员变量（一）概念篇/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OC中属性和成员变量（一）概念篇&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一、什么是成员变量？&lt;ul&gt;
&lt;li&gt;成员变量的访问权限&lt;/li&gt;
&lt;li&gt;.h文件与.m文件中的@interface声明成员变量的区别？&lt;/li&gt;
&lt;li&gt;.m文件中@implementation声明变量?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二、成员变量与实例变量的区别&lt;/li&gt;
&lt;li&gt;三、属性&lt;ul&gt;
&lt;li&gt;3.1、@property 历史&lt;/li&gt;
&lt;li&gt;3.2、@dynamic - 如果我们不想编译器给我们属性进行自动合成&lt;/li&gt;
&lt;li&gt;3.3、如何自己重写 setter / getter?&lt;/li&gt;
&lt;li&gt;3.4、self.myTitle 与 _myTitle的区别、本质、哪个更好？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;四、属性的特质&lt;ul&gt;
&lt;li&gt;4.1、原子性关键字&lt;/li&gt;
&lt;li&gt;4.2、读/写权限&lt;/li&gt;
&lt;li&gt;4.3、内存管理&lt;/li&gt;
&lt;li&gt;4.4、方法名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;五、实际使用属性&lt;ul&gt;
&lt;li&gt;5.1、不要在init 和 dealloc 中使用 accessor 即 self.XX&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="property" scheme="http://yoursite.com/tags/property/"/>
    
  </entry>
  
  <entry>
    <title>EffectiveObjectiveC（一）</title>
    <link href="http://yoursite.com/2018/06/30/EffectiveObjectiveC(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/06/30/EffectiveObjectiveC(一)/</id>
    <published>2018-06-30T06:58:58.000Z</published>
    <updated>2018-08-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章首发于<a href="http://lionsom.com" target="_blank" rel="noopener">个人blog</a></strong></p><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong></p><p><strong>原文地址：<a href="http://lionsom.com/2018/06/30/EffectiveObjectiveC（一）/" target="_blank" rel="noopener">《Effective Objective-C 2.0》</a></strong></p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>第一章：熟悉Objective-C<ul><li>第1条：了解OC语言的起源 </li><li>第2条：头文件引入</li><li>第3条：字面量语法</li><li>第4条：多用类型常量，少用#define预处理指令</li><li>第5条：用枚举来表示状态、选项</li></ul></li><li>第二章：对象、消息、运行时<ul><li>第6条：理解”属性”这一概念 </li><li>第7条：在对象内部尽量直接访问实例对象</li><li>第8条：理解”对象等同性”这一概念</li></ul></li></ul><a id="more"></a><h2 id="第1条：了解OC语言的起源"><a href="#第1条：了解OC语言的起源" class="headerlink" title="第1条：了解OC语言的起源"></a>第1条：了解OC语言的起源</h2><ul><li>1、OC是”消息结构”语言，而非”函数调用”语言</li><li></li></ul><h4 id="1、OC是”消息结构”语言，而非”函数调用”语言"><a href="#1、OC是”消息结构”语言，而非”函数调用”语言" class="headerlink" title="1、OC是”消息结构”语言，而非”函数调用”语言"></a>1、OC是”消息结构”语言，而非”函数调用”语言</h4><p><strong>举例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 消息结构  OC</span><br><span class="line">Object * obj = [Object new];</span><br><span class="line">[obj performWith:parameter1 and:Parameter2];</span><br><span class="line"></span><br><span class="line">* 函数调用  C++</span><br><span class="line"> Object * obj = new Object;</span><br><span class="line"> obj-&gt;perform(parameter1, parameter2);</span><br></pre></td></tr></table></figure><p><strong>区别</strong></p><blockquote><p>使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；</p><p>而函数调用的语言，则由编译器决定； </p></blockquote><h2 id="第2条：头文件引入"><a href="#第2条：头文件引入" class="headerlink" title="第2条：头文件引入"></a>第2条：头文件引入</h2><ul><li>1、普通的头文件引入</li><li>2、头文件循环引用</li><li>3、无法使用<code>@class</code>的情况</li></ul><h4 id="1、普通的头文件引入"><a href="#1、普通的头文件引入" class="headerlink" title="1、普通的头文件引入"></a>1、普通的头文件引入</h4><blockquote><p>宗旨：将头文件引入的时机尽量延迟，减少编译时间。</p></blockquote><p><strong>向前声明（forward declaring）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class B;</span><br></pre></td></tr></table></figure><h4 id="2、头文件循环引用"><a href="#2、头文件循环引用" class="headerlink" title="2、头文件循环引用"></a>2、头文件循环引用</h4><p><code>#include</code>容易造成循环引用。</p><p><code>@class</code> 能够解决循环引用，但是也意味着两个类里有一个无法被真正的编译。</p><h4 id="3、无法使用-class的情况"><a href="#3、无法使用-class的情况" class="headerlink" title="3、无法使用@class的情况"></a>3、无法使用<code>@class</code>的情况</h4><p>比如要声明某个类需要遵循一项协议</p><h2 id="第3条：字面量语法"><a href="#第3条：字面量语法" class="headerlink" title="第3条：字面量语法"></a>第3条：字面量语法</h2><ul><li>1、字面数值</li><li>2、字面量数组</li><li>3、字面量字典</li><li>4、可变数组与字典</li></ul><h4 id="1、字面数值"><a href="#1、字面数值" class="headerlink" title="1、字面数值"></a>1、字面数值</h4><blockquote><p><strong>好处：</strong><br>1.代码更为简洁;<br>2.以NSNumber表示所有数据类型。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">NSNumber * intNumber = @1;</span><br><span class="line">NSNumber * floatNumber = @2.5f;</span><br><span class="line">NSNumber * doubleNumber = @3.1415926;</span><br><span class="line">NSNumber * boolNumber = @YES;</span><br><span class="line">NSNumber * charNumber = @&apos;a&apos;;</span><br><span class="line"></span><br><span class="line">// 表达式</span><br><span class="line">int x = 5;</span><br><span class="line">float y = 2.5f;</span><br><span class="line">NSNumber * expressionNumber = @(x * y);</span><br></pre></td></tr></table></figure><h4 id="2、字面量数组"><a href="#2、字面量数组" class="headerlink" title="2、字面量数组"></a>2、字面量数组</h4><blockquote><p><strong>好处：</strong><br>1.代码更为简洁;<br>2.便于『取下标』操作；<br>3.如果数组中存在 <code>nil</code>则会及时报错，更快发现错误；</p></blockquote><blockquote><p><strong>注意事项：</strong><br>1.若数组元素对象中有 <code>nil</code>，则会抛出异常；但是 <code>[NSArray arraywithObject:object1,nil,object3,nil];</code> 则不会出现异常，而是遇到 <code>nil</code>为止；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">NSArray * animals = @[@&quot;dog&quot;,@&quot;cat&quot;,@&quot;mouse&quot;];</span><br><span class="line"></span><br><span class="line">// 取值</span><br><span class="line">NSString * cat = animals[1];</span><br></pre></td></tr></table></figure><h4 id="3、字面量字典"><a href="#3、字面量字典" class="headerlink" title="3、字面量字典"></a>3、字面量字典</h4><blockquote><p><strong>好处：</strong><br>1.代码更为简洁;</p></blockquote><blockquote><p><strong>与数组 <code>NSArray</code>不同的是：</strong><br> 当 <code>NSDictionary</code>初始化中出现 <code>nil</code>,无论<strong>字面量字典</strong>还是<strong>传统写法<code>dictionaryWithObjectAndKey:</code></strong>都会报出异常；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 传统写法</span><br><span class="line">NSString *lastName = [personData objectForKey:@&quot;lastname&quot;];</span><br><span class="line"></span><br><span class="line">// 等价的 字面量语法</span><br><span class="line">NSString *lastName = personData[@&quot;lastname&quot;];</span><br></pre></td></tr></table></figure><h4 id="4、可变数组与字典"><a href="#4、可变数组与字典" class="headerlink" title="4、可变数组与字典"></a>4、可变数组与字典</h4><p><strong>修改可变数组和字典内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 传统做法</span><br><span class="line">[NSMutableArray replaceObjectAtIndex:1 withObject:@&quot;dog&quot;];</span><br><span class="line">[NSMutableDictionary setObject:@&quot;Xiang&quot; forKey:@&quot;lastname&quot;];</span><br><span class="line"></span><br><span class="line">// 字面量写法 == 下标操作</span><br><span class="line">mutableArray[1] = @&quot;dog&quot;;</span><br><span class="line">mutableDictionary[@&quot;lastname&quot;] = @&quot;Xiang&quot;;</span><br></pre></td></tr></table></figure><h2 id="第4条：多用类型常量，少用-define预处理指令"><a href="#第4条：多用类型常量，少用-define预处理指令" class="headerlink" title="第4条：多用类型常量，少用#define预处理指令"></a>第4条：多用类型常量，少用#define预处理指令</h2><ul><li>1、定义常量的C语言写法</li><li>2、更适合OC语言写法</li><li>参考文章<a href="https://www.jianshu.com/p/2b0750a77284" target="_blank" rel="noopener">static、const、extern简介与使用</a></li></ul><h4 id="1、定义常量的C语言写法"><a href="#1、定义常量的C语言写法" class="headerlink" title="1、定义常量的C语言写法"></a>1、定义常量的C语言写法</h4><blockquote><p><strong>预处理指令：</strong>会把源码中的 <code>ANIMATION_DURATION</code>字符进行替换为 <code>0.3</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ANIMATION_DURATION 0.3</span><br></pre></td></tr></table></figure><p><strong>为什么预编译指令不推荐？</strong></p><blockquote><p>1、常量不包含类型信息，只会在编译阶段进行替换操作；</p><p>2、若有人重新定义了常量值，编译器也不会报错；</p></blockquote><h4 id="2、更适合OC语言写法"><a href="#2、更适合OC语言写法" class="headerlink" title="2、更适合OC语言写法"></a>2、更适合OC语言写法</h4><h5 id="2-1、常量仅限于-『实现文件』之内"><a href="#2-1、常量仅限于-『实现文件』之内" class="headerlink" title="2.1、常量仅限于 『实现文件』之内"></a>2.1、常量仅限于 <code>『实现文件』</code>之内</h5><blockquote><p>命名规范：常量仅限于 <code>『实现文件』</code>之内，则在前面加上字目 <code>k</code>;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// EOCAnimatedView.h</span><br><span class="line">#impoert &lt;UIKit.UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface EOCAnimatedView : UIView</span><br><span class="line">- (void)animate;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">static const NSTimeInterval kAnimationDuration = 0.3;</span><br><span class="line"></span><br><span class="line">@implemention EOCAnimatedView</span><br><span class="line"></span><br><span class="line">- (void)animate &#123;</span><br><span class="line">[UIView animateWithDuration:kAnimationDuration</span><br><span class="line">animations:^()&#123;</span><br><span class="line">//do something</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>用是为什么 <code>static</code>与 <code>const</code>一起？</strong></p><blockquote><p><code>const</code>修饰符所声明的变量不能被修改，如果被修改，则编译器会报错；</p><p><code>static</code>修饰符所声明的变量仅在此声明的实现文件可见。如果不添加 <code>static</code>修饰符则编译器会给它创建一个 <strong>“外部符号”（external symbol）</strong>，此刻若另一个实现文件也声明林同名变量，则编译器会报错。</p></blockquote><h5 id="2-2、公开某个常量"><a href="#2-2、公开某个常量" class="headerlink" title="2.2、公开某个常量"></a>2.2、公开某个常量</h5><blockquote><p>命名规范：由于是全局的，为了避免名称冲突，最好使用相关类名作前缀；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// EOCAnimateView.h</span><br><span class="line">extern NSString * const EOCAnimateViewAnimationDuration;</span><br><span class="line"></span><br><span class="line">// EOCAnimateView.m</span><br><span class="line">NSString * const EOCAnimateViewAnimationDuration =@&quot;value&quot;;</span><br></pre></td></tr></table></figure><p><strong>extern的作用？</strong></p><blockquote><p><code>extern</code>修饰符告诉编译器，在<strong>全局符号表</strong>中将会有一个名叫 <code>EOCAnimateViewAnimationDuration</code>的符号，编译器也就允许代码使用此变量了。</p></blockquote><h2 id="第5条：用枚举来表示状态、选项"><a href="#第5条：用枚举来表示状态、选项" class="headerlink" title="第5条：用枚举来表示状态、选项"></a>第5条：用枚举来表示状态、选项</h2><p><strong>三种枚举定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 第一种实现方式 C语言实现枚举的方式</span><br><span class="line">typedef enum &#123;</span><br><span class="line">    GHTypeUp,</span><br><span class="line">    GHTypeDown,</span><br><span class="line">&#125;GHType;</span><br><span class="line"></span><br><span class="line">// 第二种实现方式  OC实现枚举的方式</span><br><span class="line">typedef NS_ENUM(NSUInteger, GHDemoType) &#123;</span><br><span class="line">    GHDemoTypeUp,</span><br><span class="line">    GHDemoTypeDown</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 第三种方式，位移枚举 ,OC实现枚举的方式</span><br><span class="line"> * 优点：一个参数可以传递多个值</span><br><span class="line"> * 说明：如果是位移枚举，观察第一个枚举值。如果该枚举值=0 那么默认传递0座位参数，如果传递0，效率最高</span><br><span class="line"> */</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, GHOpertionType) &#123;</span><br><span class="line">    GHOpertionTypeUp = 1&lt;&lt;0,</span><br><span class="line">    GHOpertionTypeDown = 1&lt;&lt;1,</span><br><span class="line">    GHOpertionTypeLeft = 1&lt;&lt;2,</span><br><span class="line">    GHOpertionTypeRight = 1&lt;&lt;3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>位移枚举分析</strong></p><p>摘自<a href="https://www.jianshu.com/p/b8517dc833c7" target="_blank" rel="noopener">SDWebImage4.0源码探究（一）面试题</a>中的 <code>十五、SDWebImage 中 NS_OPTIONS 与 NS_ENUM 的使用</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">若 options = SDWebImageLowPriority | SDWebImageCacheMemoryOnly | SDWebImageProgressiveDownload </span><br><span class="line"></span><br><span class="line">| 运算规则：只要两个对应的二进制位有一个为1，结果位就为1，否则为0；</span><br><span class="line">&amp; 运算规则：只有两个对应的二进制位都为1时，结果位才为1，否则为0；</span><br><span class="line"></span><br><span class="line">转换为二进制</span><br><span class="line">options = 0001 | 0010 | 0100</span><br><span class="line">SDWebImageLowPriority = 0001</span><br><span class="line"></span><br><span class="line">options = 0111</span><br><span class="line">SDWebImageLowPriority = 0001</span><br><span class="line"></span><br><span class="line">if (options &amp; SDWebImageLowPriority)</span><br><span class="line">=== if(0111 &amp; 0001)</span><br><span class="line">=== if(0001)</span><br><span class="line">=== if(2)</span><br><span class="line"></span><br><span class="line">如果SDWebImageLowPriority = 1000</span><br><span class="line">if (options &amp; SDWebImageLowPriority)</span><br><span class="line">=== if(0111 &amp; 1000)</span><br><span class="line">=== if(0000)</span><br><span class="line">=== if(0)</span><br></pre></td></tr></table></figure><h2 id="第6条-amp-amp-第7条：理解”属性”这一概念-，在对象内部尽量直接访问实例对象"><a href="#第6条-amp-amp-第7条：理解”属性”这一概念-，在对象内部尽量直接访问实例对象" class="headerlink" title="第6条 &amp;&amp; 第7条：理解”属性”这一概念 ，在对象内部尽量直接访问实例对象"></a>第6条 &amp;&amp; 第7条：理解”属性”这一概念 ，在对象内部尽量直接访问实例对象</h2><p><strong>由于篇幅过大，请移至 <a href="http://lionsom.com/2018/07/12/OC中属性和成员变量（一）概念篇/" target="_blank" rel="noopener">OC中属性和成员变量（一）概念篇</a></strong></p><h2 id="第8条：理解”对象等同性”这一概念"><a href="#第8条：理解”对象等同性”这一概念" class="headerlink" title="第8条：理解”对象等同性”这一概念"></a>第8条：理解”对象等同性”这一概念</h2><p>待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;文章首发于&lt;a href=&quot;http://lionsom.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人blog&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎指正补充，可联系&lt;a href=&quot;lionsom_lin@qq.com&quot;&gt;lionsom_lin@qq.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原文地址：&lt;a href=&quot;http://lionsom.com/2018/06/30/EffectiveObjectiveC（一）/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Effective Objective-C 2.0》&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;第一章：熟悉Objective-C&lt;ul&gt;
&lt;li&gt;第1条：了解OC语言的起源 &lt;/li&gt;
&lt;li&gt;第2条：头文件引入&lt;/li&gt;
&lt;li&gt;第3条：字面量语法&lt;/li&gt;
&lt;li&gt;第4条：多用类型常量，少用#define预处理指令&lt;/li&gt;
&lt;li&gt;第5条：用枚举来表示状态、选项&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二章：对象、消息、运行时&lt;ul&gt;
&lt;li&gt;第6条：理解”属性”这一概念 &lt;/li&gt;
&lt;li&gt;第7条：在对象内部尽量直接访问实例对象&lt;/li&gt;
&lt;li&gt;第8条：理解”对象等同性”这一概念&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
  </entry>
  
  <entry>
    <title>《网络是怎样连接的》阅读整理</title>
    <link href="http://yoursite.com/2018/06/03/HowNetWork/"/>
    <id>http://yoursite.com/2018/06/03/HowNetWork/</id>
    <published>2018-06-03T14:55:04.000Z</published>
    <updated>2018-06-25T16:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章首发于<a href="http://lionsom.com" target="_blank" rel="noopener">个人blog</a></strong></p><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong></p><p><strong>原文地址：<a href="http://lionsom.com/2018/06/03/HowNetWork/" target="_blank" rel="noopener">《网络是怎样连接的》阅读整理</a></strong></p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>前序</li><li>一、生成HTTP请求消息</li><li>二、向DNS服务器查询Web服务器的IP地址</li><li>三、浏览器委托协议栈发送消息</li><li>四、IP与以太网的包收发操作</li><li>五、集线器、交换机、路由器</li><li>六、探索接入网和网络运营商（没有深入了解）</li><li>七、服务器端的局域网中有什么玄机</li><li>八、请求到达Web服务器，响应返回浏览器</li></ul><a id="more"></a><hr><hr><h2 id="macOS-Sierra-网络实用工具帮助"><a href="#macOS-Sierra-网络实用工具帮助" class="headerlink" title="macOS Sierra: 网络实用工具帮助"></a><a href="https://support.apple.com/kb/PH25801?locale=zh_CN&amp;viewlocale=zh_CN" target="_blank" rel="noopener">macOS Sierra: 网络实用工具帮助</a></h2><ul><li><p><a href="https://support.apple.com/kb/PH25352?locale=zh_CN&amp;viewlocale=zh_CN" target="_blank" rel="noopener">检查您的网络连接</a></p></li><li><p><a href="https://support.apple.com/kb/PH25178?locale=zh_CN&amp;viewlocale=zh_CN" target="_blank" rel="noopener">查看网络路由表和统计数据</a></p></li><li><p><a href="https://support.apple.com/kb/PH25238?locale=zh_CN&amp;viewlocale=zh_CN" target="_blank" rel="noopener">测试您是否可以联系另一台电脑</a></p></li><li><p><a href="https://support.apple.com/kb/PH25354?locale=zh_CN&amp;viewlocale=zh_CN" target="_blank" rel="noopener">测试 DNS 服务器</a></p></li><li><p><a href="https://support.apple.com/kb/PH25356?locale=zh_CN&amp;viewlocale=zh_CN" target="_blank" rel="noopener">追踪网络通信的路径</a></p></li><li><p><a href="https://support.apple.com/kb/PH25357?locale=zh_CN&amp;viewlocale=zh_CN" target="_blank" rel="noopener">检查开放的 TCP 端口</a></p></li></ul><hr><hr><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>为什么会读这本书？作为一名普通的iOS开发者，在iOS开发过程中一般使用三方库<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a>来进行网络请求，很少使用到系统的网络请求接口<a href="https://developer.apple.com/documentation/foundation/nsurlsession?language=occ" target="_blank" rel="noopener">NSURLSession</a>，顶多顶多使用过<a href="https://developer.apple.com/documentation/foundation/socketport/1399492-socket" target="_blank" rel="noopener">socket</a>套接字进行网络请求，<a href="https://github.com/lionsom/FastDFS_iOS_demo" target="_blank" rel="noopener">这里</a>是我用socket与FastDFS文件服务器进行交互的一个demo。所以我们作为上层开发者一般只会使用规定好的接口，根本不会在意网络请求底层是如何实现或者说是如何传递数据的，基于这种情况，我也就很好奇网络请求底层是如何如何的。</p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/cover.png" alt="作者：[日]户根勤"></p><p>于是我也就在亚马逊上挑选了这本《网络是怎样连接的》书籍来进行阅读，希望能从中得到些许启发，借此文章来记录一些我对网络的理解。</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E7%9B%AE%E5%BD%95.png" alt="整体结构"></p><h2 id="快速温习"><a href="#快速温习" class="headerlink" title="快速温习"></a>快速温习</h2><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E6%80%BB%E7%BA%B21.png" alt="总纲1"></p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E6%80%BB%E7%BA%B22.png" alt="总纲2"></p><h2 id="一、生成HTTP请求消息"><a href="#一、生成HTTP请求消息" class="headerlink" title="一、生成HTTP请求消息"></a>一、生成HTTP请求消息</h2><h3 id="1-1、浏览器输入URL"><a href="#1-1、浏览器输入URL" class="headerlink" title="1.1、浏览器输入URL"></a>1.1、浏览器输入URL</h3><blockquote><p><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></p></blockquote><h3 id="1-2、首先根据HTTP的规则，解析URL"><a href="#1-2、首先根据HTTP的规则，解析URL" class="headerlink" title="1.2、首先根据HTTP的规则，解析URL"></a>1.2、首先根据HTTP的规则，解析URL</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/3/163c64fc435d748f?w=643&amp;h=854&amp;f=jpeg&amp;s=88415" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/6/3/163c64fc17878ac4?w=659&amp;h=493&amp;f=jpeg&amp;s=57769" alt=""></p><h4 id="1-3、URL省略文件名的几种情况"><a href="#1-3、URL省略文件名的几种情况" class="headerlink" title="1.3、URL省略文件名的几种情况"></a>1.3、URL省略文件名的几种情况</h4><p><strong>a）、<a href="http://www.baidu.com/dir/" target="_blank" rel="noopener">http://www.baidu.com/dir/</a></strong></p><blockquote><p>在<code>/dir/</code>后面省略了访问的文件名，服务器已经默认设置在省略文件名情况下要访问的默认文件名，一般都会访问<code>/dir/index.html</code>或者<code>/dir/default.html</code>。</p></blockquote><p><strong>b）、<a href="http://www.baidu.com/dir" target="_blank" rel="noopener">http://www.baidu.com/dir</a></strong></p><blockquote><p>一般处理方案：如果web服务器上存在dir文件，则将dir当作文件名来处理；如果web服务器上存在名为dir的目录，则将dir当作目录来处理。</p></blockquote><p><strong>c）、<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a></strong></p><blockquote><p>这个URL表示：它访问一个名叫<code>/</code>的目录。由于省略了文件名，所以根据上一种情况，它访问的文件也就是<code>/index.html</code>或者<code>/default.html</code>。<br>注释：<code>/</code>目录表示的是目录层级中最顶级的『根目录』。</p></blockquote><p><strong>d）、<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></strong></p><blockquote><p>没有路径时，表示访问<code>根目录</code>下事先设置的默认文件夹，也就是<code>/index.html</code>或者<code>/default.html</code>。</p></blockquote><h3 id="1-4、HTTP的基本思路"><a href="#1-4、HTTP的基本思路" class="headerlink" title="1.4、HTTP的基本思路"></a>1.4、HTTP的基本思路</h3><blockquote><h5 id="HTTP协议：它定义了客户端与服务器之间交互信息的内容和步骤"><a href="#HTTP协议：它定义了客户端与服务器之间交互信息的内容和步骤" class="headerlink" title="HTTP协议：它定义了客户端与服务器之间交互信息的内容和步骤"></a>HTTP协议：它定义了客户端与服务器之间交互信息的内容和步骤</h5></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/HTTP%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF.png" alt="HTTP基本思路"></p><p>HTTP请求消息包含『对什么』和『进行怎样的操作』两个部分。<br>其中相当于『对什么』的部分称为<strong>URI</strong>。一般来说URI的内容是一个存放网页的文件名或者是一个CGI程序的文件名，例如”/dir/file.html”、”/dir/program.cgi”等。<br>其中『进行怎样的操作』的部分称为<strong>方法</strong>。方法表示需要让web服务器完成怎样的工作，其中典型的例子包括读取URI表示的数据、将客户端输入的数据传递给CGI程序等。</p><p><strong>URI：Uniform Resource Identifier，统一资源标识符</strong></p><p><strong>CGI程序：对web服务器程序调用其他程序的规则所做的定义就是CGI，安装这个规则来工作的程序就是CGI程序。</strong></p><p><strong>HTTP的主要方法</strong></p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">GET</td><td style="text-align:center">获取URI指定的信息，如果URI指定的文件，则返回文件的内容；如果URI指定的是CGI程序，则返回该程序的输出数据</td></tr><tr><td style="text-align:center">POST</td><td style="text-align:center">从客户端向服务器发送数据。一般用于发送表单中填写的数据等情况下。</td></tr></tbody></table><h3 id="1-5、生成HTTP请求消息"><a href="#1-5、生成HTTP请求消息" class="headerlink" title="1.5、生成HTTP请求消息"></a>1.5、生成HTTP请求消息</h3><p>HTTP消息在格式上是有严格规定的，因此浏览器会按照规定的格式来生成请求消息。</p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/HTTP%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF.png" alt="HTTP请求消息"></p><h3 id="1-6、发送请求后收到响应消息"><a href="#1-6、发送请求后收到响应消息" class="headerlink" title="1.6、发送请求后收到响应消息"></a>1.6、发送请求后收到响应消息</h3><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/HTTP%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF.png" alt="HTTP响应消息"></p><p><strong>响应状态码</strong></p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="响应状态码"></p><h4 id="1-7、请求网页中包含图片"><a href="#1-7、请求网页中包含图片" class="headerlink" title="1.7、请求网页中包含图片"></a>1.7、请求网页中包含图片</h4><blockquote><h5 id="1条请求消息中只能写一个URI，如果需要获取多个文件，必须对每个文件单独发送1条请求"><a href="#1条请求消息中只能写一个URI，如果需要获取多个文件，必须对每个文件单独发送1条请求" class="headerlink" title="1条请求消息中只能写一个URI，如果需要获取多个文件，必须对每个文件单独发送1条请求"></a>1条请求消息中只能写一个URI，如果需要获取多个文件，必须对每个文件单独发送1条请求</h5></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E5%A4%8D%E6%9D%82%E7%BD%91%E9%A1%B5%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B01.png" alt="复杂网页请求流程01"></p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E5%A4%8D%E6%9D%82%E7%BD%91%E9%A1%B5%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B02.png" alt="复杂网页请求流程02"></p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E5%A4%8D%E6%9D%82%E7%BD%91%E9%A1%B5%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B03.png" alt="复杂网页请求流程03"></p><h2 id="二、向DNS服务器查询Web服务器的IP地址"><a href="#二、向DNS服务器查询Web服务器的IP地址" class="headerlink" title="二、向DNS服务器查询Web服务器的IP地址"></a>二、向DNS服务器查询Web服务器的IP地址</h2><blockquote><p>浏览器能够解析网址并生成HTTP消息，但它本身不具备将消息发送到网络的功能，因此这一功能需要委托操作系统来实现。在委托操作系统发送消息时，必须提供通讯对象的IP地址，而不是域名，因此在HTTP消息之后，我们需要根据域名查询IP地址。</p></blockquote><h3 id="2-1、TCP-IP网络"><a href="#2-1、TCP-IP网络" class="headerlink" title="2.1、TCP/IP网络"></a>2.1、TCP/IP网络</h3><p>互联网和公司内部的局域网都是基于TCP/IP的思路来设计的，TCP/IP的结构就是由一些小的子网，通过路由器连接起来组成一个大的网络，这里的子网可以理解为用集线器连接起来的几台计算机，我们将它看成一个单位，称为子网，将子网通过路由器连接起来，就形成一个网络。</p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/TCP:IP%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt="TCP/IP网络结构"></p><h3 id="2-2、IP地址"><a href="#2-2、IP地址" class="headerlink" title="2.2、IP地址"></a>2.2、IP地址</h3><blockquote><p>在网络中，所有的设备都会被分配一个地址，这个地址就相当于显示中某一条路上的”XX号XX室”，其中”号”对应的号码是分配给整个子网的，而”室”对应的号码是分配给子网中的计算机的，这就是网络中的地址。<strong>“号”称为网络号，”室”称为主机号</strong>，整个地址称为<code>IP地址</code>。<br><code>IP地址 = 网络号 + 主机号</code></p></blockquote><blockquote><p><strong>预热：数据传递过程</strong></p><p>通过IP地址我们可以判断出访问对象服务器的位置，从而将消息发送到服务器。消息传送的具体过程在后面的章节有详细讲解，不过现在我们先简单了解一下。发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上（上图①）。接下来，路由器会根据消息的目的地判断下一个路由器的位置，然后将消息发送到下一个路由器，即消息再次经过子网内的集线器被转发到下一个路由器（上图②）。前面的过程不断重复，最终消息就被传送到了目的地。</p></blockquote><h3 id="2-3、IP地址结构"><a href="#2-3、IP地址结构" class="headerlink" title="2.3、IP地址结构"></a>2.3、IP地址结构</h3><blockquote><p>实际的IP地址是一串32比特(bit)的数字，按照8bit=1byte(字节)为一组分成4组，分别用十进制表示。这就是我们常见的IP地址格式，但仅凭这一串数字我们无法区分哪部分是网络号，哪部分是主机号。在IP地址的规则中，网络号和主机号连起来总共是32比特，但这两部分的具体结构是不固定的。在组建网络时，用户可以自行决定它们之间的分配关系，因此，我们还需要另外的附加信息来表示IP地址的内部结构。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="IP地址的表示方法"></p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="IP地址举例"></p><blockquote><p>IP地址的主机号：</p><p>全0：表示<code>整个子网</code></p><p>全1：表示向子网上所有设备发送包，即<code>『广播』</code></p></blockquote><p><strong>【拓展】</strong></p><p>问：有了 IP 地址，为什么还要用 MAC 地址？</p><p>答：<a href="https://www.zhihu.com/question/21546408" target="_blank" rel="noopener">知乎-有了 IP 地址，为什么还要用 MAC 地址？</a></p><h3 id="2-4、浏览器如何向DNS服务器发出查询的呢？"><a href="#2-4、浏览器如何向DNS服务器发出查询的呢？" class="headerlink" title="2.4、浏览器如何向DNS服务器发出查询的呢？"></a>2.4、浏览器如何向DNS服务器发出查询的呢？</h3><p><strong>DNS解析器</strong></p><blockquote><p>向 DNS服务器发出查询，也就是向DNS服务器发送查询消息，并接收服务器返回的响应消息。换句话说，对于 DNS服务器，我们的计算机上一定有相应的 DNS客户端，而相当于 DNS客户端的部分称为 <code>DNS解析器</code>，或者简称<code>解析器</code>。通过 DNS查询 IP地址的操作称为<code>域名解析</code>，因此负责执行解析（ resolution）这一操作的就叫解析器（ resolver）了。解析器实际上是一段程序，它包含在操作系统的 Socket库中。</p></blockquote><p><strong>库</strong></p><blockquote><p>首先，库到底是什么东西呢？库就是一堆通用程序组件的集合，其他的应用程序都需要使用其中的组件。库有很多好处。首先，使用现成的组件搭建应用程序可以节省编程工作量；其次，多个程序使用相同的组件可以实现程序的标准化。除此之外还有很多其他的好处，因此使用库来进行软件开发的思路已经非常普及，库的种类和数量也非常之多。</p></blockquote><p><strong>Socket库</strong></p><blockquote><p>Socket库也是一种库，是用于调用网络功能的程序组件集合。其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能 ，而<code>解析器</code>就是这个库中的其中一种程序组件。</p></blockquote><h3 id="2-5、如何通过解析器向DNS服务器发出查询"><a href="#2-5、如何通过解析器向DNS服务器发出查询" class="headerlink" title="2.5、如何通过解析器向DNS服务器发出查询"></a>2.5、如何通过解析器向DNS服务器发出查询</h3><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/C%E8%AF%AD%E8%A8%80gethostbyname.png" alt="代码调用查询DNS"></p><p>根据域名查询 IP地址时，浏览器会使用 Socket库中的解析器。</p><p>调用解析器后，解析器会向 DNS服务器发送查询消息，然后DNS服务器会返回响应消息。响应消息中包含查询到的IP地址，解析器会取出 IP地址，并将其写入浏览器指定的内存地址中。只要运行图 1.11中的这一行程序，就可以完成前面所有这些工作，我们也就完成了IP地址的查询。接下来，浏览器在向 Web服务器发送消息时，只要从该内存地址取出 IP地址，并将它与HTTP请求消息一起交给操作系统就可以了。</p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/DNS%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png" alt="调用解析器时，计算机内部工作流程"></p><h3 id="2-6、如何获取DNS服务器IP地址？（Domain-Name-System，域名系统）"><a href="#2-6、如何获取DNS服务器IP地址？（Domain-Name-System，域名系统）" class="headerlink" title="2.6、如何获取DNS服务器IP地址？（Domain Name System，域名系统）"></a>2.6、如何获取DNS服务器IP地址？（Domain Name System，域名系统）</h3><p>向 DNS服务器发送消息时，我们当然也需要知道 DNS服务器的 IP地址。只不过这个 IP地址是作为 TCP/ IP的一个设置项目事先设置好的，不需要再去查询了。不同的操作系统中 TCP/ IP的设置方法也有差异， MAC中的设置如下图所示，解析器会根据这里设置的 DNS服务器 IP地址来发送消息。</p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/DNS%E7%9A%84IP%E5%9C%B0%E5%9D%80.png" alt="Mac中DNS服务器地址的设置"></p><h3 id="2-7、DNS服务器是如何工作的"><a href="#2-7、DNS服务器是如何工作的" class="headerlink" title="2.7、DNS服务器是如何工作的"></a>2.7、DNS服务器是如何工作的</h3><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C.png" alt="DNS服务器基本工作"></p><blockquote><h4 id="DNS服务器会从域名与-IP地址的对照表中查找相应的记录，并返回-IP地址。"><a href="#DNS服务器会从域名与-IP地址的对照表中查找相应的记录，并返回-IP地址。" class="headerlink" title="DNS服务器会从域名与 IP地址的对照表中查找相应的记录，并返回 IP地址。"></a>DNS服务器会从域名与 IP地址的对照表中查找相应的记录，并返回 IP地址。</h4></blockquote><p><strong>域名</strong></p><blockquote><p>例如：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p>服务器、邮件服务器（邮件地址中 @后面的部分）的名称</p></blockquote><p><strong>Class</strong></p><blockquote><p>在最早设计 DNS方案时， DNS在互联网以外的其他网络中的应用也被考虑到了，而 Class就是用来识别网络的信息。不过，如今除了互联网并没有其他的网络了，因此 Class的值永远是代表互联网的 IN</p></blockquote><p><strong>记录类型</strong></p><blockquote><p>例如：A = IP地址</p><p>MX = 邮件服务器</p><p>CNAME = 域名相关的别名</p><p>表示域名对应何种类型的记录。例如，当类型为 A时，表示域名对应的是 IP地址；当类型为 MX时，表示域名对应的是邮件服务器。对于不同的记录类型，服务器向客户端返回的信息也会不同</p></blockquote><h3 id="2-8、如何在数万DNS服务器中找到目标DNS服务器"><a href="#2-8、如何在数万DNS服务器中找到目标DNS服务器" class="headerlink" title="2.8、如何在数万DNS服务器中找到目标DNS服务器"></a>2.8、如何在数万DNS服务器中找到目标DNS服务器</h3><p><strong>域名层次结构</strong></p><blockquote><p>DNS中的域名都是用句点来分隔的，比如 <a href="http://www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已" target="_blank" rel="noopener">www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已</a> 。</p><p><code>在域名中，越靠右的位置表示其层级越高</code>，比如 www. lab. glasscom. com这个域名如果按照公司里的组织结构来说，大概就是“ com事业集团 glasscom部 lab科的 www”这样。其中，相当于一个层级的部分称为域。因此， com域的下一层是 glasscom域，再下一层是 lab域，再下面才是 www这个名字。</p></blockquote><p><strong>根域</strong></p><blockquote><p>com、jp、cn这些域（称为顶级域）就是最顶层了，它们各自负责保存下级DNS服务器的信息，但实际上并非如此。在互联网中，com和 jp的上面还有一级域，称为根域。根域不像 com、 jp那样有自己的名字，因此在一般书写域名时经常被省略，如果要明确表示根域，应该像 www. lab. glasscom. com.这样在域名的最后再加上一个句点，而这个最后的句点就代表根域。不过，一般都不写最后那个句点，因此根域的存在往往被忽略，但根域毕竟是真实存在的，根域的 DNS服务器中保管着 com、 jp等的 DNS服务器的信息。由于上级 DNS服务器保管着所有下级 DNS服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的 DNS服务器。</p></blockquote><p><strong>通过根域找到目标DNS服务器</strong></p><blockquote><p>还需要完成另一项工作，那就是将根域的 DNS服务器信息保存在互联网中所有的 DNS服务器中。这样一来，任何 DNS服务器就都可以找到并访问根域 DNS服务器了。因此，客户端只要能够找到任意一台 DNS服务器，就可以通过它找到根域 DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS服务器。分配给根域 DNS服务器的 IP地址在全世界仅有 13个，而且这些地址几乎不发生变化，因此将这些地址保存在所有的 DNS服务器中也并不是一件难事。实际上，根域 DNS服务器的相关信息已经包含在 DNS服务器程序的配置文件中了，因此只要安装了 DNS服务器程序，这些信息也就被自动配置好了。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E6%9F%A5%E6%89%BE%E7%9B%AE%E6%A0%87DNS%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%AF%A6%E7%BB%86.png" alt="查找目标DNS服务器"></p><h2 id="三、浏览器委托协议栈发送消息"><a href="#三、浏览器委托协议栈发送消息" class="headerlink" title="三、浏览器委托协议栈发送消息"></a>三、浏览器委托协议栈发送消息</h2><h3 id="整体流程一览图"><a href="#整体流程一览图" class="headerlink" title="整体流程一览图"></a>整体流程一览图</h3><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/socket%E8%BF%9E%E6%8E%A5.png" alt="TCP整体流程"></p><h3 id="3-1、创建套接字"><a href="#3-1、创建套接字" class="headerlink" title="3.1、创建套接字"></a>3.1、创建套接字</h3><blockquote><h4 id="lt-描述符-gt-socket-lt-使用IPv4-gt-lt-使用TCP-gt-…"><a href="#lt-描述符-gt-socket-lt-使用IPv4-gt-lt-使用TCP-gt-…" class="headerlink" title="&lt;描述符&gt; = socket(&lt;使用IPv4&gt;,&lt;使用TCP&gt;,…)"></a>&lt;描述符&gt; = socket(&lt;使用IPv4&gt;,&lt;使用TCP&gt;,…)</h4><p>浏览器调用Socket库中socket程序组件，和调用解析器一样，调用socket之后，控制流程会转移到socket内部并执行创建套接字的操作，完成之后控制流程又会被移交回应用程序。</p><p>应用程序调用 socket申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作。在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间，然后写入初始状态。此内存空间用于记录套接字的控制信息。</p><p><strong>套接字</strong> 创建成功后，协议栈会返回一个<strong>描述符</strong>，应用程序会将收到的描述符存放在内存中。</p></blockquote><p><strong>描述符</strong></p><blockquote><h4 id="应用程序是通过“描述符”这一类-似号码牌的东西来识别套接字的。"><a href="#应用程序是通过“描述符”这一类-似号码牌的东西来识别套接字的。" class="headerlink" title="应用程序是通过“描述符”这一类 似号码牌的东西来识别套接字的。"></a>应用程序是通过“描述符”这一类 似号码牌的东西来识别套接字的。</h4><p>描述符是用来识别不同的套接字的，大家可以作如下理解。我们现在只关注了浏览器访问 Web服务器的过程，但实际上计算机中会同时进行多个数据的通信操作，比如可以打开两个浏览器窗口，同时访问两台 Web服务器。这时，有两个数据收发操作在同时进行，也就需要创建两个不同的套接字。这个例子说明，同一台计算机上可能同时存在多个套接字，在这样的情况下，我们就需要一种方法来识别出某个特定的套接字，这种方法就是描述符。我们可以将描述符理解成给某个套接字分配的编号。也许光说编号还不够形象，大家可以想象一下在酒店寄存行李时的场景，酒店服务人员会给你一个号码牌，向服务人员出示号码牌，就可以取回自己寄存的行李，描述符的原理和这个差不多。当创建套接字后，我们就可以使用这个套接字来执行收发数据的操作了。这时，只要我们出示描述符，协议栈就能够判断出我们希望用哪一个套接字来连接或者收发数据了。</p><p>由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1.png" alt="协议栈内部"></p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/socket%E4%BD%8D%E7%BD%AE.png" alt="socket所在位置"></p><p><strong>套接字</strong></p><blockquote><p>socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。</p><p>套接字是网络通信过程中端点的抽象表示，包含进行网络通信必需的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p><p>socket = IP address + TCP/UDP + port。</p></blockquote><h3 id="Mac查看实际的套接字"><a href="#Mac查看实际的套接字" class="headerlink" title="Mac查看实际的套接字"></a>Mac查看实际的套接字</h3><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/Mac%E6%9F%A5%E7%9C%8B%E5%A5%97%E6%8E%A5%E5%AD%97.png" alt="Mac查看实际的套接字"></p><p><strong>协议栈</strong></p><blockquote><p>操作系统中的网络控制软件也就是协议栈，网络硬件是网卡。</p></blockquote><p><strong>套接字与协议栈之间的关系</strong></p><blockquote><p>套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。</p><p>协议栈是根据套接字中记录的控制信息来工作的。</p></blockquote><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><table><thead><tr><th style="text-align:center"><strong>OSI七层网络模型（Open System Interconnect）</strong></th><th style="text-align:center"><strong>TCP/IP网络模型</strong></th><th style="text-align:center"><strong>对应网络协议</strong></th></tr></thead><tbody><tr><td style="text-align:center">应用层（Application）</td><td style="text-align:center"></td><td style="text-align:center">HTTP、FTP、TFTP、SMTP、NFS</td></tr><tr><td style="text-align:center">表示层（Presentation）</td><td style="text-align:center">应用层</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">会话层（Session）</td><td style="text-align:center"></td><td style="text-align:center">SMTP、DNS</td></tr><tr><td style="text-align:center">传输层（Transport）</td><td style="text-align:center">传输层</td><td style="text-align:center">TCP、UDP</td></tr><tr><td style="text-align:center">网络层（Network）</td><td style="text-align:center">网络层</td><td style="text-align:center">IP、ARP、ICMP</td></tr><tr><td style="text-align:center">数据链路层（Data Link）</td><td style="text-align:center">数据链路层</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">物理层（Physical）</td><td style="text-align:center">物理层</td></tr></tbody></table><h3 id="3-2、连接服务器"><a href="#3-2、连接服务器" class="headerlink" title="3.2、连接服务器"></a>3.2、连接服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int connect(int sockfd, const struct sockaddr* servaddr, socklen_t addrlen); // 返回：成功为0，出错-1</span><br></pre></td></tr></table></figure><blockquote><p>应用程序通过调用 Socket库中的名为 connect的程序组件来完成这一操作。</p><p>第一个参数：即<strong>描述符</strong>，connect会将应用程序指定的描述符告知协议栈，然后协议栈根据这个描述符来判断到底使用哪一个套接字去和服务器端的套接字进行连接，并执行连接的操作</p><p>第二个参数，即<strong>服务器 IP地址</strong>，就是通过 DNS服务器查询得到的我们要访问的服务器的 IP地址。</p><p>第三个参数，即<strong>端口号</strong>，IP地址是为了区分网络中的各个计算机而分配的数值。因此，只要知道了 IP地址，我们就可以识别出网络上的某台计算机。但是，连接操作的对象是某个具体的套接字，因此必须要识别到具体的套接字才行，而仅凭IP地址是无法做到这一点的。</p><p><strong><em>如果说描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制。</em></strong></p><p>服务器上所使用的端口号是根据应用的种类事先规定好的，仅此而已。</p><p>Web是 80号端口，电子邮件是 25号端口 65</p></blockquote><p><strong>问题：我们知道了服务器的端口号，但是服务器不知道客户端的端口号？</strong></p><blockquote><p>既然确定连接对象的套接字需要使用端口号，那么服务器也得知道客户端的套接字号码才行吧，这个问题是怎么解决的呢？</p><p>事情是这样的，首先，客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号。接下来，当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器。</p></blockquote><p><strong>连接服务器本质</strong></p><blockquote><p>连接实际上是通信双方交换控制信息</p></blockquote><p><strong>控制信息</strong></p><blockquote><p>通信操作中使用的控制信息分为两类。 </p><p>（1）头部中记录的信息 </p><p>（2）套接字（协议栈中的内存空间）中记录的信息</p></blockquote><p><strong>控制信息一：头部中记录的信息</strong></p><blockquote><p>他们是客户端和服务器相互联络时交换的控制信息。这些字段是固定的，在连接、收发、断开等各个阶段中，每次客户端和服务器之间进行通信时，都需要提供这些控制信息。具体来说，这些信息会被添加在客户端与服务器之间传递的网络包的开头。在连接阶段，由于数据收发还没有开始，网络包中没有实际的数据，只有控制信息。这些控制信息位于网络包的开头，因此被称为头部。此外，以太网和IP协议也有自己的控制信息，这些信息也叫 <strong><em>头部</em></strong>，为了避免各种不同的头部发生混淆，我们一般会记作 <strong><em>TCP头部、以太网头部、 IP头部</em></strong>。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/TCP%E5%A4%B4%E9%83%A8.png" alt="TCP头部格式"></p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E7%BD%91%E7%BB%9C%E5%8C%85%E4%B8%AD%E5%A4%B4%E9%83%A8.png" alt="网络包中各个头部"></p><p><strong>控制信息二：套接字（协议栈中的内存空间）中记录的信息</strong></p><blockquote><p>那就是保存在套接字中，用来控制协议栈操作的信息。应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。</p></blockquote><h4 id="3-2-1、连接操作的实际过程"><a href="#3-2-1、连接操作的实际过程" class="headerlink" title="3.2.1、连接操作的实际过程"></a>3.2.1、连接操作的实际过程</h4><blockquote><p>这个过程是从应用程序调用 Socket库的connect开始的（看上图『整体流程一览图』中②）。 &gt;</p><h4 id="connect-lt-描述符-gt-lt-服务器IP地址和端口号-gt-…"><a href="#connect-lt-描述符-gt-lt-服务器IP地址和端口号-gt-…" class="headerlink" title="connect(&lt;描述符&gt;,&lt;服务器IP地址和端口号&gt;, …)"></a>connect(&lt;描述符&gt;,&lt;服务器IP地址和端口号&gt;, …)</h4><p>连接操作的第一步是在 TCP模块处创建表示连接控制信息的头部。</p><p>通过 TCP头部中的发送方和接收方端口号可以找到要连接的套接字。</p></blockquote><h4 id="TCP建立连接要进行“三次握手”"><a href="#TCP建立连接要进行“三次握手”" class="headerlink" title="TCP建立连接要进行“三次握手”"></a>TCP建立连接要进行“三次握手”</h4><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li><li>客户端再向服务器发一个确认ACK K+1</li></ul><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/TCP%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手"></p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p><p>建立连接之后，协议栈的连接操作就结束了，也就是说 connect已经执行完毕，控制流程被交回到应用程序。</p><h3 id="3-3、收发数据"><a href="#3-3、收发数据" class="headerlink" title="3.3、收发数据"></a>3.3、收发数据</h3><h4 id="3-3-1、将HTTP请求消息交给协议栈"><a href="#3-3-1、将HTTP请求消息交给协议栈" class="headerlink" title="3.3.1、将HTTP请求消息交给协议栈"></a>3.3.1、将HTTP请求消息交给协议栈</h4><p>接下来就进入数据收发阶段了。数据收发操作是从应用程序调用 write将要发送的数据交给协议栈开始的（看上图『整体流程一览图』中③），协议栈收到数据后执行发送操作。</p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/MTU:MSS.png" alt="MTU/MSS"></p><blockquote><p>MTU： Maximum Transmission Unit，最大传输单元。一个网络包的最大长度，以太网中一般为 1500字节。</p><p>MSS： Maximum Segment Size，最大分段大小。除去头部之后，一个网络包所能容纳的 TCP数据的最大长度。TCP和 IP的头部加起来一般是 40字节，因此 MTU减去这个长度就是 MSS。例如，在以太网中， MTU为 1500，因此 MSS就是 1460。 TCP/ IP可以使用一些可选参数（ protocol option），如加密等，这时头部的长度会增加，那么 MSS就会随着头部长度增加而相应缩短。</p></blockquote><h4 id="3-3-2、对较大数据进行拆分"><a href="#3-3-2、对较大数据进行拆分" class="headerlink" title="3.3.2、对较大数据进行拆分"></a>3.3.2、对较大数据进行拆分</h4><blockquote><p>应用程序的数据一般都比较大，因此 TCP会按照网络包的大小对数据进行拆分。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E6%95%B0%E6%8D%AE%E6%8B%86%E5%88%86.png" alt="数据拆分"></p><h4 id="3-3-3、TCP通过ACK号确保网络包是否收到"><a href="#3-3-3、TCP通过ACK号确保网络包是否收到" class="headerlink" title="3.3.3、TCP通过ACK号确保网络包是否收到"></a>3.3.3、TCP通过ACK号确保网络包是否收到</h4><blockquote><p>通过“序号”和“ ACK号”可以确认接收方是否收到了网络包。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/ACK%E5%8E%9F%E7%90%86.png" alt="ACK原理"></p><h4 id="3-3-4、接受HTTP响应消息"><a href="#3-3-4、接受HTTP响应消息" class="headerlink" title="3.3.4、接受HTTP响应消息"></a>3.3.4、接受HTTP响应消息</h4><blockquote><p>首先，浏览器在委托协议栈发送请求消息之后，会调用read程序（看上图『整体流程一览图』中④）来获取响应消息。然后，控制流程会通过read转移到协议栈，然后协议栈会执行接下来<br>的操作。和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中，这里的操作过程如下。首先，协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起，等服务器返回的响应消息到达之后再继续执行接收操作。</p></blockquote><blockquote><p>协议栈会检查收到的数据块和 TCP头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK号。然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序。具体来说，协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新。</p></blockquote><h3 id="3-4、断开连接，并删除套接字"><a href="#3-4、断开连接，并删除套接字" class="headerlink" title="3.4、断开连接，并删除套接字"></a>3.4、断开连接，并删除套接字</h3><h4 id="3-4-1、从服务器端断开连接"><a href="#3-4-1、从服务器端断开连接" class="headerlink" title="3.4.1、从服务器端断开连接"></a>3.4.1、从服务器端断开连接</h4><blockquote><p>这里我们以服务器一方发起断开过程为例来进行讲解。</p><p>首先，服务器一方的应用程序会调用Socket库的close程序。然后，服务器的协议栈会生成包含断开信息的 TCP头部，具体来说就是将控制位中的 FIN比特设为 1。接下来，协议栈会委托 IP模块向客户端发送数据。同时，服务器的套接字中也会记录下断开操作的相关信息。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/socket_Close.png" alt="服务器端断开socket"></p><h4 id="3-4-2、从客户端断开连接"><a href="#3-4-2、从客户端断开连接" class="headerlink" title="3.4.2、从客户端断开连接"></a>3.4.2、从客户端断开连接</h4><ul><li>应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/TCP%E6%96%AD%E5%BC%80%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP客户端断开连接"></p><h4 id="3-4-3、删除套接字"><a href="#3-4-3、删除套接字" class="headerlink" title="3.4.3、删除套接字"></a>3.4.3、删除套接字</h4><blockquote><p>和服务器的通信结束之后，用来通信的套接字也就不会再使用了，这时我们就可以删除这个套接字了。不过，套接字并不会立即被删除，而是会等待一段时间之后再被删除。等待这段时间是为了防止误操作。</p><p><strong>误操作举例</strong>：如果最后客户端返回的 ACK号丢失了，结果会如何呢？这时，服务器没有接收到  ACK号，可能会重发一次 FIN。如果这时客户端的套接字已经删除了，会发生什么事呢？套接字被删除，那么套接字中保存的控制信息也就跟着消失了，套接字对应的端口号就会被释放出来。这时，如果别的应用程序要创建套接字，新套接字碰巧又被分配了同一个端口号，而服务器重发的  FIN正好到达，会怎么样呢？本来这个 FIN是要发给刚刚删除的那个套接字的，但新套接字具有相同的端口号，于是这个 FIN就会错误地跑到新套接字里面，新套接字就开始执行断开操作了。之所以不马上删除套接字，就是为了防止这样的误操作。</p></blockquote><h4 id="TCP整个流程一览"><a href="#TCP整个流程一览" class="headerlink" title="TCP整个流程一览"></a>TCP整个流程一览</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/TCP%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B.png" alt="TCP整个流程"></p><h2 id="四、IP与以太网的包收发操作"><a href="#四、IP与以太网的包收发操作" class="headerlink" title="四、IP与以太网的包收发操作"></a>四、IP与以太网的包收发操作</h2><h3 id="4-1、包的基本知识"><a href="#4-1、包的基本知识" class="headerlink" title="4.1、包的基本知识"></a>4.1、包的基本知识</h3><blockquote><p><strong>TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP模块将数据封装成包发送给通信对象</strong>。我们在 TCP的讲解中也经常提到 IP，下面就来讨论一下 IP模块是如何将包发送给对方的。</p><p>正式开始这个话题之前，我们先来介绍一下关于网络包的一些基本知识。首先，包是由头部和数据两部分构成的（下图（a））。头部包含目的地址等控制信息，大家可以把它理解为快递包裹的面单；头部后面就是委托方要发送给对方的数据，也就相当于快递包裹里的货物。一个包发往目的地的过程如图 2. 15所示。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E5%8C%85.png" alt="包的基本结构"></p><h3 id="4-2、IP模块的作用"><a href="#4-2、IP模块的作用" class="headerlink" title="4.2、IP模块的作用"></a>4.2、IP模块的作用</h3><h4 id="4-2-1、发送包的时候，IP模块工作"><a href="#4-2-1、发送包的时候，IP模块工作" class="headerlink" title="4.2.1、发送包的时候，IP模块工作"></a>4.2.1、发送包的时候，IP模块工作</h4><blockquote><p>收到委托后， IP模块会将包的内容当作一整块数据，在前面加上包含控制信息的头部。</p><p><strong>IP模块负责添加如下两个头部：</strong></p><p><strong><em>（1）IP头部： IP用的头部，包含 IP地址。IP头部中包含 IP协议规定的、根据 IP地址将包发往目的地所需的控制信息；</em></strong></p><p><strong><em>（2）MAC头部：以太网用的头部，包含 MAC地址。MAC头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息。</em></strong></p><p>总之，加上这两个头部之后，一个包就封装好了，这些就是 IP模块负责的工作。</p></blockquote><h4 id="4-2-2、接收包的时候，IP模块工作"><a href="#4-2-2、接收包的时候，IP模块工作" class="headerlink" title="4.2.2、接收包的时候，IP模块工作"></a>4.2.2、接收包的时候，IP模块工作</h4><blockquote><p>返回的包也会通过转发设备发送回来，然后我们需要接收这个包。接收的过程和发送的过程是相反的，信息先以电信号的形式从网线传输进来，然后由网卡将其转换为数字信息并传递给 IP模块（下图中的“ ③接收”）。接下来， IP模块会将 MAC头部和 IP头部后面的内容，也就是 TCP头部加上数据块，传递给 TCP模块。接下来的操作就是我们之前讲过的 TCP模块负责的部分了。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/IP%E6%A8%A1%E5%9D%97%E5%B7%A5%E4%BD%9C%E5%9B%BE.png" alt="IP模块工作图"></p><h3 id="4-3、生成包含接收方IP地址的IP头部"><a href="#4-3、生成包含接收方IP地址的IP头部" class="headerlink" title="4.3、生成包含接收方IP地址的IP头部"></a>4.3、生成包含接收方IP地址的IP头部</h3><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/IP%E5%A4%B4%E9%83%A8.png" alt="IP头部"></p><blockquote><p>IP头部的“接收方 IP地址”填写通信对象的 IP地址。</p><p>发送方 IP地址需要判断发送所使用的网卡，并填写该网卡的 IP地址。</p></blockquote><h4 id="问题来了：一台计算机多个网卡，如何设置发送方IP地址？"><a href="#问题来了：一台计算机多个网卡，如何设置发送方IP地址？" class="headerlink" title="问题来了：一台计算机多个网卡，如何设置发送方IP地址？"></a>问题来了：一台计算机多个网卡，如何设置发送方IP地址？</h4><p>很多服务器上都会安装多块网卡，这时一台计算机就有多个 IP地址，在填写发送方 IP地址时就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪一块网卡来发送这个包，也就相当于判断应该把包发往哪个路由器，因此只要确定了目标路由器，也就确定了应该使用哪块网卡，也就确定了发送方的 IP地址。</p><p>那么，我们应该如何判断应该把包交给哪块网卡呢？其实和路由器使用 IP表（也叫<strong>路由表</strong>）判断下一个路由器位置的操作是一样的。因为协议栈的 IP模块与路由器中负责包收发的部分都是根据 IP协议规则来进行包收发操作的，所以它们也都用相同的方法来判断把包发送给谁。</p><p><strong>（路由器收发下一章节具体说）</strong></p><h4 id="查看Mac本机的路由表Route-Table"><a href="#查看Mac本机的路由表Route-Table" class="headerlink" title="查看Mac本机的路由表Route Table"></a>查看Mac本机的路由表Route Table</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/Mac%E6%9F%A5%E7%9C%8BRouteTable.png" alt="Mac查看RouteTable"></p><h4 id="查看Windows本机的路由表Route-Table"><a href="#查看Windows本机的路由表Route-Table" class="headerlink" title="查看Windows本机的路由表Route Table"></a>查看Windows本机的路由表Route Table</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/Windows%E6%9F%A5%E7%9C%8BRouteTable.png" alt="Windows查看RouteTable"></p><h3 id="4-4、生成以太网用的MAC头部"><a href="#4-4、生成以太网用的MAC头部" class="headerlink" title="4.4、生成以太网用的MAC头部"></a>4.4、生成以太网用的MAC头部</h3><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/MAC%E5%A4%B4%E9%83%A8.png" alt="MAC头部"></p><ul><li><p>发送方 MAC地址</p><blockquote><p>发送方 MAC地址，这里填写网卡本身的 MAC地址。 MAC地址是在网卡生产时写入 ROM里的，只要将这个值读取出来写入 MAC头部就可以了。对于多块网卡的情况，请大家回想一下设置发送方 IP地址的方法 。设置发送方 IP地址时，我们已经判断出了从哪块网卡发送这个包，那么现在只要将这块网卡对应的 MAC地址填进去就好了。</p></blockquote></li><li><p>接收方MAC地址</p><blockquote><p>只要告诉以太网对方的 MAC的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC地址。然而，在这个时间点上，我们还没有把包发送出去，所以先得搞清楚应该把包发给谁，这个只要查一下路由表就知道了。在路由表中找到相匹配的条目，然后把包发给 Gateway列中的 IP地址就可以了。既然已经知道了包应该发给谁，那么只要将对方的 MAC地址填上去就好了，但到这里为止根本没有出现对方的 MAC地址，也就是说我们现在根本不知道对方的 MAC地址是什么。因此，我们还需要执行根据 IP地址查询 MAC地址的操作。<strong>详情看 4.4.1、通过 ARP查询目标路由器的 MAC地址</strong></p><p><strong>IP模块根据路由表 Gateway栏的内容判断应该把包发送给谁。</strong></p></blockquote></li></ul><h4 id="4-4-1、通过-ARP查询目标路由器的-MAC地址"><a href="#4-4-1、通过-ARP查询目标路由器的-MAC地址" class="headerlink" title="4.4.1、通过 ARP查询目标路由器的 MAC地址"></a>4.4.1、通过 ARP查询目标路由器的 MAC地址</h4><blockquote><p>这里我们需要使用 <strong>ARP协议</strong>（网络层协议），它其实非常简单。在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。 ARP就是利用广播对所有设备提问：“ × ×这个 IP地址是谁的？请把你的 MAC地址告诉我。”然后就会有人回答：“这个 IP地址是我的，我的 MAC地址是 × × × ×。” （下图） </p><p>ARP： Address Resolution Protocol，地址解析协议。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/ARP%E5%B7%A5%E4%BD%9C%E5%9B%BE.png" alt="ARP工作图"></p><blockquote><p>通过ARP缓存提升效率，避免每次发送</p></blockquote><h4 id="Mac查看ARP缓存"><a href="#Mac查看ARP缓存" class="headerlink" title="Mac查看ARP缓存"></a>Mac查看ARP缓存</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/Mac%E6%9F%A5%E7%9C%8BARP%E7%BC%93%E5%AD%98.png" alt="Mac查看ARP缓存"></p><h4 id="Windows查看ARP缓存"><a href="#Windows查看ARP缓存" class="headerlink" title="Windows查看ARP缓存"></a>Windows查看ARP缓存</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/Windows%E6%9F%A5%E7%9C%8BARP%E7%BC%93%E5%AD%98.png" alt="Windows查看ARP缓存"></p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/MAC%E6%A0%BC%E5%BC%8F.png" alt="MAC格式"></p><blockquote><h4 id="MAC：-Media-Access-Control的缩写。-MAC头部、-MAC地址中的-MAC也是这个意思。也就是说，通过-MAC模块控制包收发操作时所使用的头部和地址就叫作-MAC头部和-MAC地址。"><a href="#MAC：-Media-Access-Control的缩写。-MAC头部、-MAC地址中的-MAC也是这个意思。也就是说，通过-MAC模块控制包收发操作时所使用的头部和地址就叫作-MAC头部和-MAC地址。" class="headerlink" title="MAC： Media Access Control的缩写。 MAC头部、 MAC地址中的 MAC也是这个意思。也就是说，通过 MAC模块控制包收发操作时所使用的头部和地址就叫作 MAC头部和 MAC地址。"></a>MAC： Media Access Control的缩写。 MAC头部、 MAC地址中的 MAC也是这个意思。也就是说，通过 MAC模块控制包收发操作时所使用的头部和地址就叫作 MAC头部和 MAC地址。</h4></blockquote><h3 id="4-5、网卡-将IP包转换成电或光信号发送出去"><a href="#4-5、网卡-将IP包转换成电或光信号发送出去" class="headerlink" title="4.5、网卡-将IP包转换成电或光信号发送出去"></a>4.5、网卡-将IP包转换成电或光信号发送出去</h3><blockquote><p>IP生成的网络包只是存放在内存中的一串数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电或光信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。负责执行这一操作的是网卡，但网卡也无法单独工作，要控制网卡还需要网卡驱动程序。驱动程序不只有网卡才有，键盘、鼠标、显卡、声卡等各种硬件设备都有。当然，不同厂商和型号的网卡在结构上有所不同，因此网卡驱动程序也是厂商开发的专用程序。</p></blockquote><h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E7%BD%91%E5%8D%A1.png" alt="网卡"></p><blockquote><p><strong>网卡的 ROM中保存着全世界唯一的 MAC地址，这是在生产网卡时写入的。</strong></p></blockquote><h4 id="网卡是如何将包转换成电信号并发送到网线中的"><a href="#网卡是如何将包转换成电信号并发送到网线中的" class="headerlink" title="网卡是如何将包转换成电信号并发送到网线中的"></a>网卡是如何将包转换成电信号并发送到网线中的</h4><blockquote><p>网卡驱动从 IP模块获取包之后，会将其复制到网卡内的缓冲区中，然后向 MAC模块发送发送包的命令。接下来就轮到 MAC模块进行工作了。首先， MAC模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</p></blockquote><h4 id="给网络包再加-3个控制数据"><a href="#给网络包再加-3个控制数据" class="headerlink" title="给网络包再加 3个控制数据"></a>给网络包再加 3个控制数据</h4><p>网卡MAC模块将包从缓冲区中取出，并在开头加上 <strong><em>报头</em></strong> 和 <strong><em>起始帧分界符</em></strong>，在末尾加上用于检测错误的 <strong><em>帧校验序列</em></strong>。</p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E7%BD%91%E5%8D%A1%E5%8C%85%E6%A0%BC%E5%BC%8F.png" alt="网卡包格式"></p><h4 id="4-5-1、报头"><a href="#4-5-1、报头" class="headerlink" title="4.5.1、报头"></a>4.5.1、报头</h4><h4 id="报头作用"><a href="#报头作用" class="headerlink" title="报头作用"></a>报头作用</h4><blockquote><p>报头是一串像 10101010…这样 1和 0交替出现的比特序列，长度为 56比特，<strong><em>它的作用是确定包的读取时机</em></strong>。当这些 1010的比特序列被转换成电信号后，会形成如图这样的波形。接收方在收到信号时，遇到这样的波形就可以判断读取数据的时机。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E7%BD%91%E5%8D%A1%E5%8C%85%E7%9A%84%E6%8A%A5%E5%A4%B4.png" alt="网卡包的报头"></p><h4 id="如何通过电信号来读取数据"><a href="#如何通过电信号来读取数据" class="headerlink" title="如何通过电信号来读取数据"></a>如何通过电信号来读取数据</h4><blockquote><p>用电信号来表达数字信息时，我们需要让 0和 1两种比特分别对应特定的电压和电流，例如下图（ a）这样的电信号就可以表达数字信息。通过电信号来读取数据的过程就是将这种对应关系颠倒过来。也就是说，通过测量信号中的电压和电流变化，还原出 0和 1两种比特的值。然而，实际的信号并不像下图所示的那样有分隔每个比特的辅助线，因此在测量电压和电流时必须先判断出每个比特的界限在哪里。但是，像下图（ a）右边这种 1和 0连续出现的信号，由于电压和电流没有变化，我们就没办法判断出其中每个比特到底应该从哪里去切分。</p></blockquote><h4 id="通过时钟测量读取信号的时机"><a href="#通过时钟测量读取信号的时机" class="headerlink" title="通过时钟测量读取信号的时机"></a>通过时钟测量读取信号的时机</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E6%97%B6%E9%92%9F%E6%B5%8B%E9%87%8F%E8%AF%BB%E5%8F%96%E4%BF%A1%E5%8F%B7.png" alt="通过时钟测量读取信号的时机"></p><h4 id="如何判断出其中每个比特到底应该从哪里去切分？"><a href="#如何判断出其中每个比特到底应该从哪里去切分？" class="headerlink" title="如何判断出其中每个比特到底应该从哪里去切分？"></a>如何判断出其中每个比特到底应该从哪里去切分？</h4><blockquote><p>要解决这个问题，最简单的方法就是在数据信号之外再发送一组用来区分比特间隔的时钟信号。如图（ b）所示，当时钟信号从下往上变化时读取电压和电流的值，然后和 0或 1进行对应就可以了。但是这种方法存在问题。当距离较远，网线较长时，两条线路的长度会发生差异，数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移。 </p></blockquote><h4 id="数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移。"><a href="#数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移。" class="headerlink" title="数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移。"></a>数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移。</h4><blockquote><p>另外一种方法是当时钟信号从上往下变化时进行读取。要解决这个问题，可以采用将数据信号和时钟信号叠加在一起的方法。这样的信号如图（ c）所示，发送方将这样的信号发给接收方。由于时钟信号是像图（ b）这样按固定频率进行变化的，只要能够找到这个变化的周期，就可以从接收到的信号（ c）中提取出时钟信号（ b），进而通过接收信号（ c）和时钟信号（ b）计算出数据信号（ a），这和发送方将数据信号和时钟信号进行叠加的过程正好相反。然后，只要根据时钟信号（ b）的变化周期，我们就可以从数据信号（ a）中读取相应的电压和电流值，并将其还原为 0或 1的比特了。</p></blockquote><h4 id="4-5-2、起始帧分界符"><a href="#4-5-2、起始帧分界符" class="headerlink" title="4.5.2、起始帧分界符"></a>4.5.2、起始帧分界符</h4><blockquote><p>起始帧分界符，它的末尾比特排列有少许变化。接收方以这一变化作为标记，从这里开始提取网络包数据。也就是说，起始帧分界符是一个用来表示包起始位置的标记。</p></blockquote><h4 id="4-5-3、帧校验序列"><a href="#4-5-3、帧校验序列" class="headerlink" title="4.5.3、帧校验序列"></a>4.5.3、帧校验序列</h4><blockquote><p>末尾的 FCS（帧校验序列）用来检查包传输过程中因噪声导致的波形紊乱、数据错误，它是一串 32比特的序列，是通过一个公式对包中从头到尾的所有内容进行计算而得出来的。具体的计算公式在此省略，它和磁盘等设备中使用的 CRC错误校验码是同一种东西，当原始数据中某一个比特发生变化时，计算出来的结果就会发生变化。在包传输过程中，如果受到噪声的干扰而导致其中的数据发生了变化，那么接收方计算出的 FCS和发送方计算出的 FCS就会不同，这样我们就可以判断出数据有没有错误。</p></blockquote><h4 id="4-5-4、向集线器发送网络包"><a href="#4-5-4、向集线器发送网络包" class="headerlink" title="4.5.4、向集线器发送网络包"></a>4.5.4、向集线器发送网络包</h4><blockquote><p>网卡的 MAC模块生成通用信号，然后由 PHY（ MAU）模块转换成可在网线中传输的格式，并通过网线发送出去。</p></blockquote><h3 id="4-6、接收返回包"><a href="#4-6、接收返回包" class="headerlink" title="4.6、接收返回包"></a>4.6、接收返回包</h3><h4 id="网卡接收网络包"><a href="#网卡接收网络包" class="headerlink" title="网卡接收网络包"></a>网卡接收网络包</h4><blockquote><p>接收操作的第一步就是不管三七二十一把这些信号全都收进来再说。信号的开头是报头，通过报头的波形同步时钟，然后遇到起始帧分界符时开始将后面的信号转换成数字信息。这个操作和发送时是相反的，即 PHY（ MAU）模块先开始工作，然后再轮到 MAC模块。首先， PHY（ MAU）模块会将信号转换成通用格式并发送给 MAC模块， MAC模块再从头开始将信号转换为数字信息，并存放到缓冲区中。当到达信号的末尾时，还需要检查 FCS。具体来说，就是将从包开头到结尾的所有比特套用到公式中计算出 FCS，然后和包末尾的 FCS进行对比，正常情况下两者应该是一致的，如果中途受到噪声干扰而导致波形发生紊乱，则两者的值会产生差异，这时这个包就会被当作错误包而被丢弃。如果 FCS校验没有问题，接下来就要看一下 MAC头部中接收方 MAC地址与网卡在初始化时分配给自己的 MAC地址是否一致，以判断这个包是不是发给自己的。我们没必要去接收发给别人的包，因此如果不是自己的包就直接丢弃，如果接收方 MAC地址和自己 MAC地址一致，则将包放入缓冲区中 。到这里， MAC模块的工作就完成了，接下来网卡会通知计算机收到了一个包。</p></blockquote><h4 id="网卡中断计算机，网卡驱动从网卡缓存中读取数据"><a href="#网卡中断计算机，网卡驱动从网卡缓存中读取数据" class="headerlink" title="网卡中断计算机，网卡驱动从网卡缓存中读取数据"></a>网卡中断计算机，网卡驱动从网卡缓存中读取数据</h4><blockquote><p>通知计算机的操作会使用一个叫作中断的机制。在网卡执行接收包的操作的过程中，计算机并不是一直监控着网卡的活动，而是去继续执行其他的任务。因此，如果网卡不通知计算机，计算机是不知道包已经收到了这件事的。网卡驱动也是在计算机中运行的一个程序，因此它也不知道包到达的状态。在这种情况下，我们需要一种机制能够打断计算机正在执行的任务，让计算机注意到网卡中发生的事情，这种机制就是中断。具体来说，中断的工作过程是这样的。首先，网卡向扩展总线中的中断信号线发送信号，该信号线通过计算机中的中断控制器连接到 CPU。当产生中断信号时， CPU会暂时挂起正在处理的任务，切换到操作系统中的中断处理程序 。然后，中断处理程序会调用网卡驱动，控制网卡执行相应的接收操作。</p></blockquote><blockquote><p>网卡驱动被中断处理程序调用后，会从网卡的缓冲区中取出收到的包，并通过 MAC头部中的以太类型字段判断协议的类型。现在我们在大多数情况下都是使用 TCP/ IP协议，但除了 TCP/ IP之外还有很多其他类型的协议，例如 NetWare中使用的 IPX/ SPX，以及 Mac电脑中使用的 AppleTalk等协议。这些协议都被分配了不同的以太类型，如 0080（十六进制）代表 IP协议，网卡驱动就会把这样的包交给 TCP/ IP协议栈；如果是 809B则表示 AppleTalk协议，就把包交给 AppleTalk协议栈，以此类推。</p></blockquote><h3 id="4-7、将服务器的响应包从-IP传递给-TCP"><a href="#4-7、将服务器的响应包从-IP传递给-TCP" class="headerlink" title="4.7、将服务器的响应包从 IP传递给 TCP"></a>4.7、将服务器的响应包从 IP传递给 TCP</h3><blockquote><p>下面我们假设 Web服务器返回了一个网络包，那么协议栈会进行哪些处理呢 100？服务器返回的包的以太类型应该是 0800，因此网卡驱动会将其交给 TCP/ IP协议栈来进行处理。接下来就轮到 IP模块先开始工作了，第一步是检查 IP头部，确认格式是否正确。如果格式没有问题，下一步就是查看接收方 IP地址。如果接收网络包的设备是一台 Windows客户端计算机，那么服务器返回的包的接收方 IP地址应该与客户端网卡的地址一致，检查确认之后我们就可以接收这个包了。</p></blockquote><h4 id="IP模块检查IP头部，如果接收方-IP地址不是自己的地址，通过ICMP反馈回去"><a href="#IP模块检查IP头部，如果接收方-IP地址不是自己的地址，通过ICMP反馈回去" class="headerlink" title="IP模块检查IP头部，如果接收方 IP地址不是自己的地址，通过ICMP反馈回去"></a>IP模块检查IP头部，如果接收方 IP地址不是自己的地址，通过ICMP反馈回去</h4><blockquote><p>如果接收方 IP地址不是自己的地址，那一定是发生了什么错误。客户端计算机不负责对包进行转发，因此不应该收到不是发给自己的包 101。当发生这样的错误时， IP模块会通过 ICMP消息将错误告知发送方（图 2. 1）。 ICMP规定了各种类型的消息，如表所示。当我们遇到这个错误时， IP模块会通过表中的 Destination unreachable消息通知对方。从这张表的内容中我们可以看到在包的接收和转发过程中能够遇到的各种错误，因此希望大家看一看这张表。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/ICMP%E6%A0%BC%E5%BC%8F.png" alt="ICMP格式"></p><h4 id="IP模块检查IP头部，如果接收方-IP地址是自己的地址，进行分片重组"><a href="#IP模块检查IP头部，如果接收方-IP地址是自己的地址，进行分片重组" class="headerlink" title="IP模块检查IP头部，如果接收方 IP地址是自己的地址，进行分片重组"></a>IP模块检查IP头部，如果接收方 IP地址是自己的地址，进行分片重组</h4><blockquote><p>如果接收方 IP地址正确，则这个包会被接收下来，这时还需要完成另一项工作。 IP协议有一个叫作分片的功能。简单来说，网线和局域网中只能传输小包，因此需要将大的包切分成多个小包。如果接收到的包是经过分片的，那么 IP模块会将它们还原成原始的包。分片的包会在 IP头部的标志字段中进行标记，当收到分片的包时， IP模块会将其暂存在内部的内存空间中，然后等待 IP头部中具有相同 ID的包全部到达，这是因为同一个包的所有分片都具有相同的 ID。此外， IP头部还有一个分片偏移量（ fragment offset）字段，它表示当前分片在整个包中所处的位置。根据这些信息，在所有分片全部收到之后，就可以将它们还原成原始的包，这个操作叫作分片重组。</p></blockquote><h4 id="TCP模块接收包"><a href="#TCP模块接收包" class="headerlink" title="TCP模块接收包"></a>TCP模块接收包</h4><p>接下来包会被交给 TCP模块。 TCP模块会根据 IP头部中的接收方和发送方 IP地址，以及 TCP头部中的接收方和发送方端口号来查找对应的套接字。找到对应的套接字之后，就可以根据套接字中记录的通信状态，执行相应的操作了。例如，如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序</p><h2 id="五、集线器、交换机、路由器"><a href="#五、集线器、交换机、路由器" class="headerlink" title="五、集线器、交换机、路由器"></a>五、集线器、交换机、路由器</h2><blockquote><p>（1）路由器根据目标地址判断下一个路由器的位置 </p><p>（2）集线器在子网中将网络包传输到下一个路由</p><p>实际上，集线器是按照以太网规则传输包的设备，而路由器是按照 IP规则传输包的设备，因此我们也可以作如下理解。 </p><p>（1）IP协议根据目标地址判断下一个 IP转发设备的位置</p><p>（2）子网中的以太网协议将包传输到下一个转发设备</p></blockquote><blockquote><p>场景设定：网络包在进入互联网之前经历的传输过程。这里我们假设客户端计算机连接的局域网结构是像下图这样的。也就是说，网络包从客户端计算机发出之后，要经过集线器、交换机和路由器最终进入互联网。实际上，我们家里用的路由器已经集成了集线器和交换机的功能，像图上这样使用独立设备的情况很少见。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%B8%83%E5%B1%80.png" alt="局域网的结构"></p><h3 id="5-1、信号在网线中传播"><a href="#5-1、信号在网线中传播" class="headerlink" title="5.1、信号在网线中传播"></a>5.1、信号在网线中传播</h3><blockquote><p>网卡 -&gt; 网线 -&gt; 集线器</p><p>从信号流出网卡进入网线开始。网卡中的 PHY（ MAU） 2模块负责将包转换成电信号，信号通过 RJ-45接口进入双绞线，这部分的放大图如下图的右侧部分所示。以太网信号的本质是正负变化的电压，大家可以认为网卡的 PHY（ MAU）模块就是一个从正负两个信号端子输出信号的电路。</p></blockquote><h4 id="网卡与集线器用双绞线连接的形态"><a href="#网卡与集线器用双绞线连接的形态" class="headerlink" title="网卡与集线器用双绞线连接的形态"></a>网卡与集线器用双绞线连接的形态</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E7%BD%91%E5%8D%A1%E5%88%B0%E9%9B%86%E7%BA%BF%E5%99%A8.png" alt="网卡与集线器用双绞线连接的形态"></p><h4 id="问题来了：信号衰减"><a href="#问题来了：信号衰减" class="headerlink" title="问题来了：信号衰减"></a>问题来了：信号衰减</h4><blockquote><p>信号在网线的传输过程中，能量会逐渐损失。网线越长，信号衰减就越严重。集线器收到的信号有时会出现衰减。如下图。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E7%BD%91%E7%BA%BF%E4%BF%A1%E5%8F%B7%E8%A1%B0%E5%BC%B1.png" alt="接收方信号变得难以识别"></p><h4 id="“双绞”是为了抑制噪声"><a href="#“双绞”是为了抑制噪声" class="headerlink" title="“双绞”是为了抑制噪声"></a>“双绞”是为了抑制噪声</h4><blockquote><p>局域网网线使用的是双绞线，其中“双绞”的意思就是以两根信号线为一组缠绕在一起，这种拧麻花一样的设计是为了抑制噪声的影响。</p></blockquote><h4 id="噪声是如何产生的"><a href="#噪声是如何产生的" class="headerlink" title="噪声是如何产生的"></a>噪声是如何产生的</h4><blockquote><p>首先，我们来看看噪声是如何产生的。产生噪声的原因是网线周围的电磁波，当电磁波接触到金属等导体时，在其中就会产生电流。因此，如果网线周围存在电磁波，就会在网线中产生和原本的信号不同的电流。由于信号本身也是一种带有电压变化的电流，其本质和噪声产生的电流是一样的，所以信号和噪声的电流就会混杂在一起，导致信号的波形发生失真，这就是噪声的影响。</p></blockquote><h4 id="电磁波来源有两种：外部和内部"><a href="#电磁波来源有两种：外部和内部" class="headerlink" title="电磁波来源有两种：外部和内部"></a>电磁波来源有两种：外部和内部</h4><blockquote><p>影响网线的电磁波分为两种：</p><p>一种是由电机、荧光灯、 CRT显示器等设备泄漏出来的电磁波，这种电磁波来自网线之外的其他设备，</p><p>另一种电磁波是从网线中相邻的信号线泄漏出来的。由于传输的信号本身就是一种电流，当电流流过时就会向周围发出电磁波，这些电磁波对于其他信号线来说就成了噪声。这种内部产生的噪声称为串扰（ crosstalk）。</p></blockquote><h4 id="双绞线对噪声的抑制"><a href="#双绞线对噪声的抑制" class="headerlink" title="双绞线对噪声的抑制"></a>双绞线对噪声的抑制</h4><blockquote><p>a）通过两根信号线的缠绕抵消外源性噪声；</p><p>b）通过改变节距抑制内源性噪声。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E5%8F%8C%E7%BB%9E%E7%BA%BF%E5%AF%B9%E5%99%AA%E5%A3%B0%E7%9A%84%E6%8A%91%E5%88%B6.png" alt="双绞线对噪声的抑制"></p><h3 id="5-2、集线器将信号发往所有设备"><a href="#5-2、集线器将信号发往所有设备" class="headerlink" title="5.2、集线器将信号发往所有设备"></a>5.2、集线器将信号发往所有设备</h3><blockquote><p><strong>集线器的作用?</strong></p><p><strong>集线器将信号发送给所有连接在它上面的线路。</strong></p></blockquote><blockquote><p>信号到达集线器的 PHY（ MAU）模块后，会进入中继电路。中继电路的基本功能就是将输入的信号广播到集线器的所有端口上。当然，也有一些产品具有信号整形、错误抑制等功能，但基本上就是将输入的信号原封不动地输出到网线接口。接下来，信号从所有接口流出，到达连接在集线器上的所有设备。然后，这些设备在收到信号之后会通过 MAC头部中的接收方 MAC地址判断是不是发给自己的，如果是发给自己的就接受，否则就忽略。这样，网络包就能够到达指定 MAC地址的接收方了。</p></blockquote><blockquote><p>由于集线器只是原封不动地将信号广播出去，所以即便信号受到噪声的干扰发生了失真，也会原样发送到目的地。这时，接收信号的设备，也就是交换机、路由器、服务器等，会在将信号转换成数字信息后通过 FCS8校验发现错误，并将出错的包丢弃。当然，丢弃包并不会影响数据的传输，因为丢弃的包不会触发确认响应。因此协议栈的 TCP模块会检测到丢包，并对该包进行重传。</p></blockquote><h3 id="5-3、交换机的包转发操作"><a href="#5-3、交换机的包转发操作" class="headerlink" title="5.3、交换机的包转发操作"></a>5.3、交换机的包转发操作</h3><hr><h3 id="对于交换机暂时理解不深刻"><a href="#对于交换机暂时理解不深刻" class="headerlink" title="对于交换机暂时理解不深刻"></a>对于交换机暂时理解不深刻</h3><hr><h3 id="5-4、路由器的包转发操作"><a href="#5-4、路由器的包转发操作" class="headerlink" title="5.4、路由器的包转发操作"></a>5.4、路由器的包转发操作</h3><h4 id="5-4-1、路由器内部结构"><a href="#5-4-1、路由器内部结构" class="headerlink" title="5.4.1、路由器内部结构"></a>5.4.1、路由器内部结构</h4><blockquote><p>大家只要看明白路由器包括转发模块和端口模块两部分就可以了。其中转发模块负责判断包的转发目的地，端口模块负责包的收发操作。换句话说，路由器转发模块和端口模块的关系，就相当于协议栈的 IP模块和网卡之间的关系。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="路由器内部结构"></p><blockquote><p><strong>路由器的各个端口都具有 MAC地址和 IP地址。</strong></p></blockquote><h4 id="5-4-2、路由器的工作原理"><a href="#5-4-2、路由器的工作原理" class="headerlink" title="5.4.2、路由器的工作原理"></a>5.4.2、路由器的工作原理</h4><blockquote><p>路由器在转发包时，首先会通过端口将发过来的包接收进来，这一步的工作过程取决于端口对应的通信技术。对于以太网端口来说，就是按照以太网规范进行工作，而无线局域网端口则按照无线局域网的规范工作，总之就是委托端口的硬件将包接收进来。接下来，转发模块会根据接收到的包的 IP头部中记录的接收方 IP地址，在路由表中进行查询，以此判断转发目标。然后，转发模块将包转移到转发目标对应的端口，端口再按照硬件的规则将包发送出去，也就是转发模块委托端口模块将包发送出去的意思。</p></blockquote><h4 id="5-4-3、路由器根据路由表对包进行转发"><a href="#5-4-3、路由器根据路由表对包进行转发" class="headerlink" title="5.4.3、路由器根据路由表对包进行转发"></a>5.4.3、路由器根据路由表对包进行转发</h4><blockquote><p>交换机是通过 MAC头部中的接收方 MAC地址来判断转发目标的，而路由器则是根据 IP头部中的 IP地址来判断的。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E8%B7%AF%E7%94%B1%E8%A1%A8.png" alt="路由表"></p><blockquote><p>交换机在地址表中只匹配完全一致的记录，而 <strong><em>路由器则会忽略主机号部分，只匹配网络号部分</em></strong>。打个比方，路由器在转发包的时候只看接收方地址属于哪个区， × ×区发往这一边， × ×区发往那一边。</p></blockquote><h4 id="5-4-4、路由器的包接收操作"><a href="#5-4-4、路由器的包接收操作" class="headerlink" title="5.4.4、路由器的包接收操作"></a>5.4.4、路由器的包接收操作</h4><blockquote><p>路由器的整个工作过程。首先，路由器会接收网络包。路由器的端口有各种不同的类型，这里我们只介绍以太网端口是如何接收包的。以太网端口的结构和计算机的网卡基本相同，接收包并存放到缓冲区中的过程也和网卡几乎没有区别。首先，信号到达网线接口部分，其中的 PHY（ MAU）模块和 MAC模块将信号转换为数字信息，然后通过包末尾的 FCS进行错误校验，如果没问题则检查 MAC头部中的接收方 MAC地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。如果包的接收方 MAC地址不是自己，说明这个包是发给其他设备的，如果接收这个包就违反了以太网的规则。</p><p><strong><em>路由器的端口都具有 MAC地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</em></strong></p></blockquote><h4 id="5-4-5、查询路由表确定输出端口"><a href="#5-4-5、查询路由表确定输出端口" class="headerlink" title="5.4.5、查询路由表确定输出端口"></a>5.4.5、查询路由表确定输出端口</h4><h4 id="MAC头部作用"><a href="#MAC头部作用" class="headerlink" title="MAC头部作用"></a>MAC头部作用</h4><blockquote><p>完成包接收操作之后，路由器就会丢弃包开头的 MAC头部。 MAC头部的作用就是将包送达路由器，其中的接收方 MAC地址就是路由器端口的 MAC地址。因此，当包到达路由器之后， MAC头部的任务就完成了，于是 MAC头部就会被丢弃。</p><p><strong>通过路由器转发的网络包，其接收方 MAC地址为路由器端口的 MAC地址。</strong></p></blockquote><h4 id="路由器会根据-IP头部中的内容进行包的转发操作"><a href="#路由器会根据-IP头部中的内容进行包的转发操作" class="headerlink" title="路由器会根据 IP头部中的内容进行包的转发操作"></a>路由器会根据 IP头部中的内容进行包的转发操作</h4><ul><li>a）查询路由表判断转发目标</li></ul><blockquote><p>关于具体的工作过程，我们还是来看一个实际的例子，如上图的情况，假设地址为 10. 10. 1. 101的计算机要向地址为 192. 168. 1. 10的服务器发送一个包，这个包先到达图中的路由器。判断转发目标的第一步，就是根据包的接收方 IP地址查询路由表中的目标地址栏，以找到相匹配的记录。就像前面讲过的一样，这个匹配并不是匹配全部 32个比特，而是根据子网掩码列中的值判断网络号的比特数，并匹配相应数量的比特 33。例如，上图的第 3行，子网掩码列为 255. 255. 255. 0，就表示需要匹配从左起 24个比特。网络包的接收方 IP地址和路由表中的目标地址左起 24个比特的内容都是 192. 168. 1，因此两者是匹配的，该行记录就是候选转发目标之一。</p></blockquote><ul><li>b）路由器修改包的有效期</li><li>c）路由器通过分片功能拆分大网络包</li><li>d）路由器的发送操作</li></ul><blockquote><p>这一步操作取决于输出端口的类型。如果是以太网端口，则按照以太网的规则将包转换为电信号发送出去；如果是 ADSL则按照 ADSL的规则来转换，以此类推。在家庭网络中，路由器后面一般连接 ADSL等线路接入互联网，因此路由器会根据接入网的规则来发送包。不过，要理解具体的操作过程，需要先理解相应的通信线路 ，比较复杂，因此我们留到下一章探索互联网内部时再讲解。这里，我们假设路由器位于公司等局域网的内部，即输出端口也是以太网，看看这种情况是如何操作的。</p><p>以太网的包发送操作是根据以太网规则来进行的，即便设备种类不同，规则也是相同的。也就是说，其基本过程和协议栈中的 IP模块发送包的过程是相同的，即在包前面加上 MAC头部，</p><p>设置其中的一些字段，然后将完成的包转换成电信号并发送出去。下面来简单复习一下这个过程。首先，为了判断 MAC头部中的 MAC地址应该填写什么值，我们需要根据路由表的网关列判断对方的地址。如果网关是一个 IP地址，则这个 IP地址就是我们要转发到的目标地址；如果网关为空，则 IP头部中的接收方 IP地址就是要转发到的目标地址。知道对方的 IP地址之后，接下来需要通过 ARP根据 IP地址查询 MAC地址，并将查询的结果作为接收方 MAC地址。路由器也有 ARP缓存，因此首先会在 ARP缓存中查询，如果找不到则发送 ARP查询请求。</p><p>路由器判断下一个转发目标的方法如下。</p><ul><li>如果路由表的网关列内容为 IP地址，则该地址就是下一个转发目标。</li><li>如果路由表的网关列内容为空，则 IP头部中的接收方 IP地址就是下一个转发目标。</li></ul><p>路由器也会使用 ARP来查询下一个转发目标的 MAC地址。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。例如，当以太网工作在半双工模式时，需要先确认线路中没有其他信号后才能发送，如果检测到碰撞，则需要等待一段时间后重发。如果以太网工作在全双工模式，则不需要确认线路中的信号，可以直接发送。如果输出端口为以太网，则发送出去的网络包会通过交换机到达下一个路由器。由于接收方 MAC地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p></blockquote><h3 id="5-5、路由器与交换机的关系"><a href="#5-5、路由器与交换机的关系" class="headerlink" title="5.5、路由器与交换机的关系"></a>5.5、路由器与交换机的关系</h3><blockquote><p>IP协议本身没有传输包的功能，因此包的实际传输要委托以太网来进行。</p><p>路由器是基于 IP设计的，而交换机是基于以太网设计的，因此 IP与以太网的关系也就是路由器与交换机的关系。换句话说，路由器将包的传输工作委托给交换机来进行</p></blockquote><blockquote><p><strong>IP（路由器）负责将包送达通信对象这一整体过程，而其中将包传输到下一个路由器的过程则是由以太网（交换机）来负责的。</strong></p></blockquote><h2 id="六、探索接入网和网络运营商"><a href="#六、探索接入网和网络运营商" class="headerlink" title="六、探索接入网和网络运营商"></a>六、探索接入网和网络运营商</h2><p>此章节没啥好说的，了解下即可！</p><h2 id="七、服务器端的局域网中有什么玄机"><a href="#七、服务器端的局域网中有什么玄机" class="headerlink" title="七、服务器端的局域网中有什么玄机"></a>七、服务器端的局域网中有什么玄机</h2><h3 id="7-1、防火墙"><a href="#7-1、防火墙" class="headerlink" title="7.1、防火墙"></a>7.1、防火墙</h3><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E9%98%B2%E7%81%AB%E5%A2%99.png" alt="防火墙基本布局"></p><h4 id="防火墙的基本思路"><a href="#防火墙的基本思路" class="headerlink" title="防火墙的基本思路"></a>防火墙的基本思路</h4><blockquote><p>防火墙的基本思路，即只允许发往特定服务器中的特定应用程序的包通过，然后屏蔽其他的包。</p></blockquote><h4 id="主流的是包过滤方式的防火墙"><a href="#主流的是包过滤方式的防火墙" class="headerlink" title="主流的是包过滤方式的防火墙"></a>主流的是包过滤方式的防火墙</h4><blockquote><p><strong>包过滤方式的防火墙可根据接收方 IP地址、发送方 IP地址、接收方端口号、发送方端口号、控制位等信息来判断是否允许某个包通过。</strong></p></blockquote><h4 id="防火墙的不足"><a href="#防火墙的不足" class="headerlink" title="防火墙的不足"></a>防火墙的不足</h4><blockquote><p><strong>防火墙无法抵御的攻击</strong></p><p>防火墙可以根据包的起点和终点来判断是否允许其通过，但仅凭起点和终点并不能筛选出所有有风险的包。</p><p>比如，假设 Web服务器在收到含有特定数据的包时会引起宕机。但是防火墙只关心包的起点和终点，因此即便包中含有特定数据，防火墙也无法发现，于是包就被放行了。然后，当包到达 Web服务器时，就会引发服务器宕机。通过这个例子大家可以看出，只有检查包的内容才能识别这种风险，因此防火墙对这种情况无能为力。</p></blockquote><h4 id="对防火墙无法抵御攻击的应对方法"><a href="#对防火墙无法抵御攻击的应对方法" class="headerlink" title="对防火墙无法抵御攻击的应对方法"></a>对防火墙无法抵御攻击的应对方法</h4><p>a）方法一：这个问题的根源在于 Web服务器程序的 Bug，因此修复 Bug防止宕机就是其中一种方法。这类 Bug中，危险性较高的会作为安全漏洞公布出来，开发者会很快发布修复了 Bug的新版本，因此持续关注安全漏洞信息并更新软件的版本是非常重要的。</p><p>b）另一种方法就是在防火墙之外部署用来检查包的内容并阻止有害包的设备或软件。</p><h3 id="7-2、负载均衡"><a href="#7-2、负载均衡" class="headerlink" title="7.2、负载均衡"></a>7.2、负载均衡</h3><h4 id="7-2-1、多台服务器-–-分布式架构"><a href="#7-2-1、多台服务器-–-分布式架构" class="headerlink" title="7.2.1、多台服务器 – 分布式架构"></a>7.2.1、多台服务器 – 分布式架构</h4><blockquote><p>使用多台服务器来分担负载的方法更有效。这种架构统称为分布式架构。</p></blockquote><ul><li><p>DNS轮询分配服务器IP地址</p><blockquote><p>最简单的一种是通过 DNS服务器来分配。当访问服务器时，客户端需要先向 DNS服务器查询服务器的 IP地址，如果在 DNS服务器中填写多个名称相同的记录，则每次查询时 DNS服务器都会按顺序返回不同的 IP地址。</p><p><strong>DNS轮询不足之处</strong></p><p>例如：假如多台 Web服务器中有一台出现了故障，这时我们希望在返回 IP地址时能够跳过故障的 Web服务器，然而普通的 DNS服务器并不能确认 Web服务器是否正常工作，因此即便 Web服务器宕机了，它依然可能会返回这台服务器的 IP地址。</p></blockquote></li><li><p>使用负载均衡器分配访问</p></li></ul><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8.png" alt="负载均衡器分配访问"></p><h4 id="7-2-2、缓存服务器"><a href="#7-2-2、缓存服务器" class="headerlink" title="7.2.2、缓存服务器"></a>7.2.2、缓存服务器</h4><h4 id="临时保存内容并代替-Web服务器返回内容的缓存服务器"><a href="#临时保存内容并代替-Web服务器返回内容的缓存服务器" class="headerlink" title="临时保存内容并代替 Web服务器返回内容的缓存服务器"></a>临时保存内容并代替 Web服务器返回内容的缓存服务器</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="临时保存内容并代替 Web服务器返回内容的缓存服务器"></p><h4 id="缓存服务器三种部署"><a href="#缓存服务器三种部署" class="headerlink" title="缓存服务器三种部署"></a>缓存服务器三种部署</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%89%E7%A7%8D%E9%83%A8%E7%BD%B2.png" alt="缓存服务器三种部署"></p><h3 id="7-3、内容分发服务"><a href="#7-3、内容分发服务" class="headerlink" title="7.3、内容分发服务"></a>7.3、内容分发服务</h3><blockquote><p>根据缓存服务器分布第三种方式，进行布局。</p></blockquote><h2 id="八、请求到达Web服务器，响应返回浏览器"><a href="#八、请求到达Web服务器，响应返回浏览器" class="headerlink" title="八、请求到达Web服务器，响应返回浏览器"></a>八、请求到达Web服务器，响应返回浏览器</h2><h3 id="8-1、服务器概览"><a href="#8-1、服务器概览" class="headerlink" title="8.1、服务器概览"></a>8.1、服务器概览</h3><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="服务器工作过程"></p><h3 id="8-2、服务器的接收操作"><a href="#8-2、服务器的接收操作" class="headerlink" title="8.2、服务器的接收操作"></a>8.2、服务器的接收操作</h3><h4 id="8-2-1、-网卡将接收到的信号转换成数字信息"><a href="#8-2-1、-网卡将接收到的信号转换成数字信息" class="headerlink" title="8.2.1、 网卡将接收到的信号转换成数字信息"></a>8.2.1、 网卡将接收到的信号转换成数字信息</h4><h4 id="服务器将接收到的电信号还原数字信息"><a href="#服务器将接收到的电信号还原数字信息" class="headerlink" title="服务器将接收到的电信号还原数字信息"></a>服务器将接收到的电信号还原数字信息</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E7%94%B5%E4%BF%A1%E5%8F%B7%E8%BD%AC%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7.png" alt="网卡将接收到的信号转换成数字信息"></p><h4 id="根据信号还原的数字信息"><a href="#根据信号还原的数字信息" class="headerlink" title="根据信号还原的数字信息"></a>根据信号还原的数字信息</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/%E8%BF%98%E5%8E%9F%E6%95%B0%E5%AD%97%E4%BF%A1%E6%81%AF.png" alt="根据信号还原的数字信息"></p><blockquote><p><strong>网卡的 MAC模块将网络包从信号还原为数字信息，校验 FCS并存入缓冲区。</strong></p><p>在这个过程中，服务器的 CPU并不是一直在监控网络包的到达，而是在执行其他的任务，因此 CPU并不知道此时网络包已经到达了。但接下来的接收操作需要 CPU来参与，因此网卡需要通过 <strong><em>中断</em></strong> 将网络包到达的事件通知给 CPU。接下来， CPU就会暂停当前的工作，并切换到网卡的任务。然后，网卡驱动会开始运行，从网卡缓冲区中将接收到的包读取出来，根据 MAC头部的以太类型字段判断协议的种类，并调用负责处理该协议的软件。这里，以太类型的值应该是表示 IP协议，因此会调用 TCP/ IP协议栈，并将包转交给它。</p><p>网卡驱动会根据 MAC头部判断协议类型，并将包交给相应的协议栈。</p></blockquote><h4 id="8-2-2、IP模块接收操作"><a href="#8-2-2、IP模块接收操作" class="headerlink" title="8.2.2、IP模块接收操作"></a>8.2.2、IP模块接收操作</h4><blockquote><p>（ 1）IP模块首先会检查 IP头部的格式是否符合规范，然后检查接收方 IP地址，看包是不是发给自己的；</p><p>（ 2）判断网络包是否经过分片；</p><p>（ 3）需要检查 IP头部的协议号字段，并将包转交给相应的模块。例如，如果协议号为 06（十六进制），则将包转交给 TCP模块；如果是 11（十六进制），则转交给 UDP模块。</p></blockquote><h4 id="8-2-3、TCP模块如何处理连接包"><a href="#8-2-3、TCP模块如何处理连接包" class="headerlink" title="8.2.3、TCP模块如何处理连接包"></a>8.2.3、TCP模块如何处理连接包</h4><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/TCP%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手"></p><p>第一步：当 TCP头部中的控制位 SYN为 1时，表示这是一个发起连接的包。这时， TCP模块会执行接受连接的操作，不过在此之前，需要先检查包的接收方端口号，并确认在该端口上有没有与接收方端口号相同且正在处于等待连接状态的套接字。如果指定端口号没有等待连接的套接字，则向客户端返回错误通知的包。向客户端返回一个表示接收方端口不存在等待连接的套接字的 ICMP消息。</p><p>第二步：如果存在等待连接的套接字，则为这个套接字复制一个新的副本，并将发送方 IP地址、端口号、序号初始值、窗口大小等必要的参数写入这个套接字中，同时分配用于发送缓冲区和接收缓冲区的内存空间。然后生成代表接收确认的 ACK号，用于从服务器向客户端发送数据的序号初始值，表示接收缓冲区剩余容量的窗口大小，并用这些信息生成 TCP头部，委托 IP模块发送给客户端。</p><p>第三步：这个包到达客户端之后，客户端会返回表示接收确认的 ACK号，当这个 ACK号返回服务器后，连接操作就完成了。这时，服务器端的程序应该进入调用 accept的暂停状态，当将新套接字的描述符转交给服务器程序之后，服务器程序就会恢复运行。</p><h4 id="8-2-4、TCP模块如何处理数据包"><a href="#8-2-4、TCP模块如何处理数据包" class="headerlink" title="8.2.4、TCP模块如何处理数据包"></a>8.2.4、TCP模块如何处理数据包</h4><blockquote><p>（ 1）收到数据包时， TCP模块会根据收到的包的发送方 IP地址、发送方端口号、接收方 IP地址、接收方端口号找到相对应的套接字；</p><p>（ 2）将数据块拼合起来并保存在接收缓冲区中；</p><p>（ 3）向客户端返回 ACK。</p></blockquote><h4 id="8-2-5、TCP模块的断开操作"><a href="#8-2-5、TCP模块的断开操作" class="headerlink" title="8.2.5、TCP模块的断开操作"></a>8.2.5、TCP模块的断开操作</h4><p>在TCP协议的规则中，断开操作可以由客户端或服务器任何一方发起，具体的顺序是由应用层协议决定的。Web中，这一顺序随HTTP协议版本不同而不同，在HTTP1.0中，是服务器先发起断开操作。</p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog/HowNetWork/TCP%E6%96%AD%E5%BC%80%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP客户端断开连接"></p><blockquote><p>（1）服务器会调用Socket库的socket，TCP模块会生成一个 FIN为 1的 TCP头部，并委托 IP模块发送给客户端</p><p>（2）当客户端收到这个包后，会返回一个ACK号，</p><p>（3）接下来客户端会调用close，生成一个 FIN为 1的 TCP头部发给服务器，</p><p>（4）服务器再返回一个 ACK号。</p></blockquote><h3 id="8-3、Web服务器程序解释请求消息并作出响应"><a href="#8-3、Web服务器程序解释请求消息并作出响应" class="headerlink" title="8.3、Web服务器程序解释请求消息并作出响应"></a>8.3、Web服务器程序解释请求消息并作出响应</h3><h3 id="8-4、浏览器接收到响应并显示内容"><a href="#8-4、浏览器接收到响应并显示内容" class="headerlink" title="8.4、浏览器接收到响应并显示内容"></a>8.4、浏览器接收到响应并显示内容</h3><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://juejin.im/post/5b10be81518825139e0d8160" target="_blank" rel="noopener">完整的一次 HTTP 请求响应过程（一）</a></p><p><a href="https://juejin.im/post/5b152061e51d4506a269a34f" target="_blank" rel="noopener">完整的一次 HTTP 请求响应过程（二）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;文章首发于&lt;a href=&quot;http://lionsom.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人blog&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎指正补充，可联系&lt;a href=&quot;lionsom_lin@qq.com&quot;&gt;lionsom_lin@qq.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原文地址：&lt;a href=&quot;http://lionsom.com/2018/06/03/HowNetWork/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《网络是怎样连接的》阅读整理&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;前序&lt;/li&gt;
&lt;li&gt;一、生成HTTP请求消息&lt;/li&gt;
&lt;li&gt;二、向DNS服务器查询Web服务器的IP地址&lt;/li&gt;
&lt;li&gt;三、浏览器委托协议栈发送消息&lt;/li&gt;
&lt;li&gt;四、IP与以太网的包收发操作&lt;/li&gt;
&lt;li&gt;五、集线器、交换机、路由器&lt;/li&gt;
&lt;li&gt;六、探索接入网和网络运营商（没有深入了解）&lt;/li&gt;
&lt;li&gt;七、服务器端的局域网中有什么玄机&lt;/li&gt;
&lt;li&gt;八、请求到达Web服务器，响应返回浏览器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage4.0源码探究（一）UML类图和时序图</title>
    <link href="http://yoursite.com/2018/04/10/SDWebImage4-0%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89UML%E7%B1%BB%E5%9B%BE%E5%92%8C%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/04/10/SDWebImage4-0源码探究（一）UML类图和时序图/</id>
    <published>2018-04-10T02:42:56.000Z</published>
    <updated>2018-04-19T15:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>SDWebImage类图和时序图</li><li>UML类图阅读规则</li><li>UML时序图阅读规则</li></ul><a id="more"></a><h2 id="一、SDWebImage类图和时序图"><a href="#一、SDWebImage类图和时序图" class="headerlink" title="一、SDWebImage类图和时序图"></a>一、SDWebImage类图和时序图</h2><p><img src="https://github.com/rs/SDWebImage/raw/master/Docs/SDWebImageClassDiagram.png" alt="SDWebImage类图"></p><p><img src="https://github.com/rs/SDWebImage/blob/master/Docs/SDWebImageSequenceDiagram.png?raw=true" alt="SDWebImage时序图"></p><h2 id="二、UML类图阅读规则"><a href="#二、UML类图阅读规则" class="headerlink" title="二、UML类图阅读规则"></a>二、UML类图阅读规则</h2><p><a href="https://www.jianshu.com/p/10cc65dea07a" target="_blank" rel="noopener">UML基本使用–类图</a></p><h4 id="UML-Class"><a href="#UML-Class" class="headerlink" title="UML Class"></a>UML Class</h4><p>类图的3个基本组件：类名，属性，方法。<br>在描述方法时可以通过在方法下面添加一个横线来区分类方法和实例方法,以及在后面添加 readOnly 来表明只读属性</p><p><img src="https://upload-images.jianshu.io/upload_images/183487-47aa82683b4dfd5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/241" alt="UML_Class"></p><h4 id="UML-Protocol"><a href="#UML-Protocol" class="headerlink" title="UML Protocol"></a>UML Protocol</h4><p><img src="https://upload-images.jianshu.io/upload_images/183487-b6a9f167dfc46e9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/585" alt="UML_Protocol"></p><h4 id="常见的关系"><a href="#常见的关系" class="headerlink" title="常见的关系"></a>常见的关系</h4><ul><li><h4 id="继承（Generalization）"><a href="#继承（Generalization）" class="headerlink" title="继承（Generalization）"></a>继承（Generalization）</h4></li></ul><p>【定义】：表示的是子类和父类的关系，例如猫和动物的关系一样<br>【描述方式】：带三角箭头的实现，箭头指向父类<br><img src="https://upload-images.jianshu.io/upload_images/183487-68f9c3a012985380..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/208" alt=""></p><ul><li><h4 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h4></li></ul><p>【定义】：描述的是一种类与接口(协议)的关系<br>【描述方式】：用带三角箭头的虚线表示，箭头指向接口。<br><img src="https://upload-images.jianshu.io/upload_images/183487-e0ac831baad632ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/435" alt=""></p><ul><li><h4 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h4></li></ul><p>【定义】：是一种拥有关系，它使得一个类知道另一个类的属性或方法；分为双向关联和单向关联。例如老师和学生是双向关联，老师可以有多名学生，学生也可以有多名老师；但学生和课程之间就是单向关联的，一个学生可以有多门课程上，但是课程不拥有学生。<br>【描述方式】：双向关联的关系用一条直线连接两个类，并在两头标注数量对应关系（1:n或者n：n）；单向关联关系用一个普通的箭头连接两个类，箭头指向被拥有者。<br>【备注】：这种普通的关联关系感觉在 iOS 中用的比较少，基本都是用下面三种更为特殊的关联关系，聚合，组合，依赖</p><p><img src="https://upload-images.jianshu.io/upload_images/183487-4e269fd858fe2a89.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/560" alt=""></p><ul><li><h4 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h4></li></ul><p>【定义】：是一种整体与部分的关系，并且部分可以离开整体而单独存在，好比汽车和轮胎是整体和部分的关系，但轮胎离开车任然可以存在。聚合关系是关联关系的一种，是一种强关联关系<br>【描述方式】：带空心菱形的实心线表示，菱形指向整体</p><p><img src="https://upload-images.jianshu.io/upload_images/183487-2aca6310d96d7ebc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/418" alt=""></p><p>【备注】：聚合的方式还可以用来表示 iOS 中某个声明在 VC 或者 view 中的协议(反正不是单独创建一个protocol文件那种)以 MPINewUserCell类来介绍，该类中定义了一个 MPINewUserCellDelegate给外界使用表示方式可以：</p><p><img src="https://upload-images.jianshu.io/upload_images/183487-593a41bc51d996dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/213" alt=""></p><ul><li><h4 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h4></li></ul><p>【定义】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系也是关联关系的一种，是比聚合关系还要强的关联关系。<br>【描述方式】：带实心菱形的实线，菱形指向整体<br><img src="https://upload-images.jianshu.io/upload_images/183487-7113c45c5b39707b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/403" alt=""></p><ul><li><h4 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h4></li></ul><p>【定义】：依赖关系是一种使用关系，即一个类做某件事情需要另一个类的协助，但不是把另一个类作为自己的属性；例如下载素材的 manager 类和下载的素材material之间的关系就是依赖关系，manager仅仅是使用material，并没有把它定义为自己的一个属性<br>【描述方式】：带箭头的虚线指向被使用者</p><p><img src="https://upload-images.jianshu.io/upload_images/183487-5e4d615ae22da4d1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/519" alt=""></p><h2 id="三、UML时序图阅读规则"><a href="#三、UML时序图阅读规则" class="headerlink" title="三、UML时序图阅读规则"></a>三、UML时序图阅读规则</h2><p><a href="https://www.jianshu.com/p/51318fefdcaa" target="_blank" rel="noopener">UML基本使用–时序图</a></p><hr><blockquote><h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong><br><strong>原文地址：<a href="http://lionsom.com/2018/04/10/SDWebImage4-0源码探究（一）UML类图和时序图/" target="_blank" rel="noopener">Mac+Hexo+github搭建myblog完整版</a></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SDWebImage类图和时序图&lt;/li&gt;
&lt;li&gt;UML类图阅读规则&lt;/li&gt;
&lt;li&gt;UML时序图阅读规则&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="框架分析" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    
    
      <category term="SDWebImage" scheme="http://yoursite.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage4.0源码探究（二）框架分析</title>
    <link href="http://yoursite.com/2018/03/22/SDWebImage4-0%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/03/22/SDWebImage4-0源码探究（二）框架分析/</id>
    <published>2018-03-22T06:32:23.000Z</published>
    <updated>2018-05-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>一、SDWebImage UML分析</li><li>二、SDWebImage 中 <strong>@autoreleasepool</strong> 的应用</li><li>三、SDWebImage 支持 <strong>GIF动图</strong> 吗？</li><li>四、SDWebImage 如何 <strong>区分图片格式</strong>？</li><li>五、SDWebImage 缓存图片的名称如何 <strong>避免重名</strong>？</li><li>六、SDWebImage 中 <strong>常量的定义</strong></li><li>七、SDWebImage 如何保证UI操作放在主线程中执行？</li><li>八、SDWebImage 的 <strong>最大并发数</strong> 和 <strong>超时时长</strong></li><li>九、SDWebImage 的Memory缓存和Disk缓存是用什么实现的？</li><li>十、SDWebImage 读取Memory和Disk的时候如何保证 <strong>线程安全</strong>？</li><li>十一、SDWebImage 的 <strong>Memory警告</strong> 是如何处理的！</li><li>十二、SDWebImage Disk缓存时长？ Disk清理操作时间点？ Disk清理原则？</li><li>十三、SDWebImage <strong>Disk目录</strong> 位于哪里？</li><li>十四、SDWebImage 的回调设计？</li><li>十五、SDWebImage 中 <strong>NS_OPTIONS</strong> 与 <strong>NS_ENUM</strong> 的使用</li><li>十六、SDWebImage 中的工具类介绍</li></ul><a id="more"></a><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul><li><p><a href="https://github.com/rs/SDWebImage/blob/master/Docs/SDWebImage-4.0-Migration-guide.md" target="_blank" rel="noopener">SDWebImage 4.0迁移指南</a></p></li><li><p><a href="https://github.com/rs/SDWebImage/wiki/Common-Problems" target="_blank" rel="noopener">Common Problems</a></p></li><li><p><a href="https://github.com/rs/SDWebImage/wiki" target="_blank" rel="noopener">SDWebImage/wiki</a></p></li><li><p><a href="https://github.com/rs/SDWebImage/blob/master/Docs/HowToUse.md" target="_blank" rel="noopener">HowToUse</a></p></li></ul><h2 id="一、UML图和时序图"><a href="#一、UML图和时序图" class="headerlink" title="一、UML图和时序图"></a>一、UML图和时序图</h2><p><img src="https://github.com/rs/SDWebImage/raw/master/Docs/SDWebImageClassDiagram.png" alt="aa"></p><p><img src="https://github.com/rs/SDWebImage/blob/master/Docs/SDWebImageSequenceDiagram.png?raw=true" alt="BB"></p><hr><h1 id="二、SDWebImage-中-autoreleasepool的应用"><a href="#二、SDWebImage-中-autoreleasepool的应用" class="headerlink" title="二、SDWebImage 中@autoreleasepool的应用"></a>二、SDWebImage 中@autoreleasepool的应用</h1><ul><li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#retain-count-semantics" target="_blank" rel="noopener">Retain count semantics in ARC</a></li><li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#autoreleasepool" target="_blank" rel="noopener">What’s @autoreleasepool</a></li><li><a href="https://www.jianshu.com/p/1b66c4d47cd7" target="_blank" rel="noopener">AutoreleasePool的原理和实现</a></li></ul><p>现考虑如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">    [self doSthWith:object];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和笔试题关键部分大同小异。如果”doSthWith:”方法要创建一个临时对象，那么这个对象很可能会放在自动释放池里。笔试题中最后stringByAppendingString方法很有可能属于上述的方法。因此如果涉及到了自动释放池，那么问题也应该就出在上面。</p><p>注意：即便临时对象在调用完方法后就不再使用了，它们也依然处于存活状态，因为目前它们都在自动释放池里，等待系统稍后进行回收。但自动释放池却要等到该线程执行下一次事件循环时才会清空，这就意味着在执行for循环时，会有持续不断的新的临时对象被创建出来，并加入自动释放池。要等到结束for循环才会释放。在for循环中内存用量会持续上涨，而等到结束循环后，内存用量又会突然下降。</p><p>而如果把循环内的代码包裹在“自动释放池”中，那么在循环中自动释放的对象就会放在这个池，而不是在线程的主池里面。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            NSString *str = @&quot;abc&quot;;</span><br><span class="line">            str = [str lowercaseString];</span><br><span class="line">            str = [str stringByAppendingString:@&quot;xyz&quot;];</span><br><span class="line">        &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增的自动释放池可以减少内存用量，因为系统会在块的末尾把这些对象回收掉。而上述这些临时对象，正在回收之列。</p><p>自动释放池的机制就像“栈”。系统创建好池之后，将其压入栈中，而清空自动释放池相当于将池从栈中弹出。在对象上执行自动释放操作，就等于将其放入位于栈顶的那个池。</p><blockquote><h3 id="结论：-autoreleasepool利于局部变量立刻释放"><a href="#结论：-autoreleasepool利于局部变量立刻释放" class="headerlink" title="结论：@autoreleasepool利于局部变量立刻释放"></a>结论：@autoreleasepool利于局部变量立刻释放</h3></blockquote><hr><h1 id="三、SDWebImage-支持GIF动图吗？"><a href="#三、SDWebImage-支持GIF动图吗？" class="headerlink" title="三、SDWebImage 支持GIF动图吗？"></a>三、SDWebImage 支持GIF动图吗？</h1><h3 id="3-1、SDWebImage-4-0版本之前的UIImage-GIF类别"><a href="#3-1、SDWebImage-4-0版本之前的UIImage-GIF类别" class="headerlink" title="3.1、SDWebImage 4.0版本之前的UIImage+GIF类别"></a>3.1、SDWebImage 4.0版本之前的<code>UIImage+GIF</code>类别</h3><p>在<code>SDWebImage</code>这个库里有一个<code>UIImage+GIF</code>的类别，里面为<code>UIImage</code>扩展了三个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface UIImage (GIF)</span><br><span class="line">+ (IImage *)sd_animatedGIFNamed:(NSString *)name;</span><br><span class="line">+ (UIImage *)sd_animatedGIFWithData:(NSData *)data;</span><br><span class="line">- (UIImage *)sd_animatedImageByScalingAndCroppingToSize:(CGSize)size;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>具体使用 <a href="https://www.jianshu.com/p/f0530a75c7af#comment-12834850" target="_blank" rel="noopener">参考文章</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;gifTest&quot; ofType:@&quot;gif&quot;];</span><br><span class="line">NSData *data = [NSData dataWithContentsOfFile:path];</span><br><span class="line">UIImage *image = [UIImage sd_animatedGIFWithData:data];</span><br><span class="line">gifImageView.image = image;</span><br></pre></td></tr></table></figure></p><h3 id="3-2、SDWebImage-4-0版本之后的UIImage-GIF类别"><a href="#3-2、SDWebImage-4-0版本之后的UIImage-GIF类别" class="headerlink" title="3.2、SDWebImage 4.0版本之后的UIImage+GIF类别"></a>3.2、<strong>SDWebImage 4.0</strong>版本之后的<code>UIImage+GIF</code>类别</h3><p>在<code>SDWebImage</code>这个库里有一个<code>UIImage+GIF</code>的类别，其中的扩展方法只有一个<code>sd_animatedGIFWithData :</code>，<strong>它只返回数据包含的第一帧的图像</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface UIImage (GIF)</span><br><span class="line">/**</span><br><span class="line"> *  Compatibility method - creates an animated UIImage from an NSData, it will only contain the 1st frame image</span><br><span class="line"> */</span><br><span class="line">+ (UIImage *)sd_animatedGIFWithData:(NSData *)data;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Checks if an UIImage instance is a GIF. Will use the `images` array</span><br><span class="line"> */</span><br><span class="line">- (BOOL)isGIF;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>具体使用</p><p><img src="https://upload-images.jianshu.io/upload_images/1859399-b106e48344d3ebef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="只返回一帧的图像"></p><p>结论：SDWebImage 4.0版本之后，<code>sd_animatedGIFWithData :</code>没办法实现gif加载；</p><h3 id="3-3、SDWebImage-4-0版本之后-加载gif新方法"><a href="#3-3、SDWebImage-4-0版本之后-加载gif新方法" class="headerlink" title="3.3、SDWebImage 4.0版本之后 加载gif新方法"></a>3.3、SDWebImage 4.0版本之后 加载gif新方法</h3><p><strong>官方文档：</strong></p><hr><h2 id="Animated-Images-GIF-support"><a href="#Animated-Images-GIF-support" class="headerlink" title="Animated Images (GIF) support"></a>Animated Images (GIF) support</h2><ul><li>Starting with the 4.0 version, we rely on <a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage</a> to take care of our animated images.</li><li>If you use cocoapods, add <code>pod &#39;SDWebImage/GIF&#39;</code> to your podfile.</li><li>To use it, simply make sure you use <code>FLAnimatedImageView</code> instead of <code>UIImageView</code>.</li><li><strong>Note</strong>: there is a backwards compatible feature, so if you are still trying to load a GIF into a <code>UIImageView</code>, it will only show the 1st frame as a static image by default. However, you can enable the full GIF support by using the built-in GIF coder. See <a href="https://github.com/rs/SDWebImage/wiki/Advanced-Usage#gif-coder" target="_blank" rel="noopener">GIF coder</a></li><li><strong>Important</strong>: FLAnimatedImage only works on the iOS platform. For macOS, use <code>NSImageView</code> with <code>animates</code> set to <code>YES</code> to show the entire animated images and <code>NO</code> to only show the 1st frame. For all the other platforms (tvOS, watchOS) we will fallback to the backwards compatibility feature described above</li></ul><hr><p><strong>结论：</strong></p><ul><li>4.0版本之后，SD依赖 <a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage</a>进行了gif的加载，</li><li>需要我们单独导入<code>pod &#39;SDWebImage/GIF&#39;</code>，</li><li>并且需要使用<code>FLAnimatedImageView</code> 代替 <code>UIImageView</code></li><li>注意事项：这里所说的就是版本兼容的问题，也就是我们之前讨论的<code>sd_animatedGIFWithData :</code>方法没办法实现gif加载了。但是，您可以使用内置的GIF编码器来启用完整的GIF支持。具体查看 <a href="https://github.com/rs/SDWebImage/wiki/Advanced-Usage#gif-coder" target="_blank" rel="noopener">GIF coder</a></li><li>重要事项：<ul><li><code>FLAnimatedImage</code>暂时仅支持iOS平台；</li><li>macOS平台使用<code>NSImageView</code>与<code>animates</code>设置为YES以显示整个动画图像，而不只是显示第1帧。</li><li>其他平台(tvOS, watchOS)，我们将退回到上面描述的向后兼容性特性。可以使用老版本的方法。</li></ul></li></ul><hr><h1 id="四、SDWebImage-如何区分图片格式？"><a href="#四、SDWebImage-如何区分图片格式？" class="headerlink" title="四、SDWebImage 如何区分图片格式？"></a>四、SDWebImage 如何区分图片格式？</h1><ul><li>PNG：压缩比没有JPG高，但是无损压缩，解压缩性能高，苹果推荐的图像格式！</li><li>JPG：压缩比最高的一种图片格式，有损压缩！最多使用的场景，照相机！解压缩的性能不好！</li><li>GIF：序列桢动图，特点：只支持256种颜色！最流行的时候在1998～1999，有专利的！</li></ul><p>在分类”NSData+ImageContentType.h”中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDImageFormat) &#123;</span><br><span class="line">    SDImageFormatUndefined = -1,</span><br><span class="line">    SDImageFormatJPEG = 0,</span><br><span class="line">    SDImageFormatPNG,</span><br><span class="line">    SDImageFormatGIF,</span><br><span class="line">    SDImageFormatTIFF,</span><br><span class="line">    SDImageFormatWebP</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Return image format</span><br><span class="line"> *</span><br><span class="line"> *  @param data the input image data</span><br><span class="line"> *</span><br><span class="line"> *  @return the image format as `SDImageFormat` (enum)</span><br><span class="line"> */</span><br><span class="line">+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data &#123;</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return SDImageFormatUndefined;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    uint8_t c;</span><br><span class="line">    [data getBytes:&amp;c length:1];</span><br><span class="line">    switch (c) &#123;</span><br><span class="line">        case 0xFF:</span><br><span class="line">            return SDImageFormatJPEG;</span><br><span class="line">        case 0x89:</span><br><span class="line">            return SDImageFormatPNG;</span><br><span class="line">        case 0x47:</span><br><span class="line">            return SDImageFormatGIF;</span><br><span class="line">        case 0x49:</span><br><span class="line">        case 0x4D:</span><br><span class="line">            return SDImageFormatTIFF;</span><br><span class="line">        case 0x52:</span><br><span class="line">            // R as RIFF for WEBP</span><br><span class="line">            if (data.length &lt; 12) &#123;</span><br><span class="line">                return SDImageFormatUndefined;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</span><br><span class="line">            if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123;</span><br><span class="line">                return SDImageFormatWebP;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return SDImageFormatUndefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="实现思想：将数据data转为十六进制数据，取第一个字节数据进行判断。"><a href="#实现思想：将数据data转为十六进制数据，取第一个字节数据进行判断。" class="headerlink" title="实现思想：将数据data转为十六进制数据，取第一个字节数据进行判断。"></a>实现思想：将数据data转为十六进制数据，取第一个字节数据进行判断。</h3></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1859399-66c9b525aa5c5175.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看图片"></p><hr><h1 id="五、SDWebImage-缓存图片的名称如何避免重名"><a href="#五、SDWebImage-缓存图片的名称如何避免重名" class="headerlink" title="五、SDWebImage 缓存图片的名称如何避免重名"></a>五、SDWebImage 缓存图片的名称如何避免重名</h1><blockquote><h3 id="对『绝对路径』进行MD5"><a href="#对『绝对路径』进行MD5" class="headerlink" title="对『绝对路径』进行MD5"></a>对『绝对路径』进行MD5</h3></blockquote><ul><li>如果单纯使用 文件名保存，重名的几率很高！</li><li>使用 MD5 的散列函数！对完整的 URL 进行 md5，结果是一个 32 个字符长度的字符串！</li></ul><hr><h1 id="六、SDWebImage-中常量的定义"><a href="#六、SDWebImage-中常量的定义" class="headerlink" title="六、SDWebImage 中常量的定义"></a>六、SDWebImage 中常量的定义</h1><blockquote><p>可参考之前的文章<a href="https://www.jianshu.com/p/e65d4c40e116" target="_blank" rel="noopener">宏(define)与常量(const)</a></p></blockquote><ul><li>SD中的<code>FOUNDATION_EXPORT</code>定义与调用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImage-umbrella.h</span><br><span class="line"></span><br><span class="line">#ifdef __OBJC__</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#else</span><br><span class="line">#ifndef FOUNDATION_EXPORT</span><br><span class="line">#if defined(__cplusplus)</span><br><span class="line">#define FOUNDATION_EXPORT extern &quot;C&quot;</span><br><span class="line">#else</span><br><span class="line">#define FOUNDATION_EXPORT extern</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在SDWebImageCompat.h</span><br><span class="line">FOUNDATION_EXPORT NSString *const SDWebImageErrorDomain;</span><br><span class="line"></span><br><span class="line">// 在SDWebImageCompat.m</span><br><span class="line">NSString *const SDWebImageErrorDomain = @&quot;SDWebImageErrorDomain&quot;;</span><br></pre></td></tr></table></figure><ul><li>我常用的<code>UIKIT_EXTERN</code>调用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN NSString * const CHECK_SUM_MQ;</span><br><span class="line"></span><br><span class="line">NSString * const CHECK_SUM_MQ = @&quot;123&quot;;</span><br></pre></td></tr></table></figure><ul><li>系统内部对<code>FOUNDATION_EXPORT</code>和<code>UIKIT_EXTERN</code>的定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在系统内部文件 UIKitDefines.h 中</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">#define UIKIT_EXTERNextern &quot;C&quot; __attribute__((visibility (&quot;default&quot;)))</span><br><span class="line">#else</span><br><span class="line">#define UIKIT_EXTERN        extern __attribute__((visibility (&quot;default&quot;)))</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 系统内部文件 NSObjCRuntime.h 中</span><br><span class="line"></span><br><span class="line">#if defined(__cplusplus)</span><br><span class="line">#define FOUNDATION_EXTERN extern &quot;C&quot;</span><br><span class="line">#else</span><br><span class="line">#define FOUNDATION_EXTERN extern</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_WIN32</span><br><span class="line"></span><br><span class="line">    #if defined(NSBUILDINGFOUNDATION)</span><br><span class="line">        #define FOUNDATION_EXPORT FOUNDATION_EXTERN __declspec(dllexport)</span><br><span class="line">    #else</span><br><span class="line">        #define FOUNDATION_EXPORT FOUNDATION_EXTERN __declspec(dllimport)</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    #define FOUNDATION_IMPORT FOUNDATION_EXTERN __declspec(dllimport)</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">    #define FOUNDATION_EXPORT  FOUNDATION_EXTERN</span><br><span class="line">    #define FOUNDATION_IMPORT FOUNDATION_EXTERN</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ul><li>结论：<ul><li><code>FOUNDATION_EXTERN</code> 在 C 中 是 extern；在C++中是 extern ‘C’ ；其他情况则在win32情况下；</li><li><code>UIKIT_EXTERN</code>简单来说，就是将函数修饰为兼容以往C编译方式的、具有extern属性(文件外可见性)、public修饰的方法或变量库外仍可见的属性；</li></ul></li></ul><hr><h1 id="七、SDWebImage-如何保证UI操作放在主线程中执行？"><a href="#七、SDWebImage-如何保证UI操作放在主线程中执行？" class="headerlink" title="七、SDWebImage 如何保证UI操作放在主线程中执行？"></a>七、SDWebImage 如何保证UI操作放在主线程中执行？</h1><p><a href="https://www.jianshu.com/p/cb3dbeaa8b18" target="_blank" rel="noopener">iOS UI 操作在主线程不一定安全？</a></p><p>在SDWebImage的SDWebImageCompat.h中有这样一个宏定义，用来保证主线程操作，为什么要这样写？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCompat.h 中</span><br><span class="line"></span><br><span class="line">#ifndef dispatch_main_async_safe</span><br><span class="line">#define dispatch_main_async_safe(block)\</span><br><span class="line">    if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>在此之前见到最多的是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define dispatch_main_async_safe(block)\</span><br><span class="line">    if ([NSThread isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对比两段代码可以发现前者有两个地方改变了，一是多了 <code>#ifndef</code>，二是判断条件改变了。</p><p>显然，增加 <code>#ifndef</code> 是为了提高代码的严谨，防止重复定义 <code>dispatch_main_async_safe</code>。</p><p>关于判断条件的改变的原因则是复杂得多了,可参考文档</p><p><a href="http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/" target="_blank" rel="noopener">GCD’s Main Queue vs. Main Thread</a></p><p><a href="http://blog.krzyzanowskim.com/2016/06/03/queues-are-not-bound-to-any-specific-thread/" target="_blank" rel="noopener">Queues are not bound to any specific thread</a></p><h4 id="分析：如何判断当前是否在main-thread？"><a href="#分析：如何判断当前是否在main-thread？" class="headerlink" title="分析：如何判断当前是否在main thread？"></a>分析：如何判断当前是否在main thread？</h4><h5 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h5><p>检查我们当前在主线程上执行的最简单的方法是使用[NSThread isMainThread] - GCD缺少一个类似的方便的API来检查我们是否在主队列上运行，因此许多开发人员使用了NSThread API。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ([NSThread isMainThread]) &#123;</span><br><span class="line">block();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在大多数情况下是有效的，直到它出现了异常。下面是关于ReactiveCocoa repo问题的摘录:<br><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2635#issuecomment-170215083" target="_blank" rel="noopener">ReactiveCocoa issue</a></p><p><img src="http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/rac_issue_queue_thread.png" alt=""></p><p>潜在的问题是VektorKit API正在检查是否在主队列上调用它，而不是检查它在主线程上运行。</p><p>虽然每个应用程序都只有一个主线程，但是在这个主线程上执行许多不同的队列是可能的。</p><p>如果库(如VektorKit)依赖于在主队列上检查执行，那么从主线程上执行的非主队列调用API将导致问题。也就是说，<strong>如果在主线程执行非主队列调度的API，而这个API需要检查是否由主队列上调度，那么将会出现问题。</strong></p><h5 id="更安全的方法一"><a href="#更安全的方法一" class="headerlink" title="更安全的方法一"></a>更安全的方法一</h5><p>从技术上讲，我认为这是一个 <code>MapKit / VektorKit</code> 漏洞，苹果的UI框架通常保证在从主线程调用时正确工作，没有任何文档提到需要在主队列上执行代码。</p><p>但是，现在我们知道某些api不仅依赖于主线程上的运行，而且还依赖于主队列，因此检查当前队列而不是检查当前线程更安全。</p><p>检查当前队列还可以更好地利用GCD为线程提供的抽象。从技术上讲，我们不应该知道/关心主队列是一种总是绑定到主线程的特殊队列。</p><p>不幸的是，GCD没有一个非常方便的API来检查我们当前正在运行的队列(这很可能是许多开发人员首先使用NSThread.isMainThread()的原因)。</p><p>我们需要使用 <code>dispatch_queue_set_specific</code> 函数来将键值对与主队列相关联;稍后，我们可以使用 <code>dispatch_queue_get_specific</code> 来检查键和值的存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)function &#123;</span><br><span class="line">    static void *mainQueueKey = &quot;mainQueueKey&quot;;</span><br><span class="line">    dispatch_queue_set_specific(dispatch_get_main_queue(), mainQueueKey, &amp;mainQueueKey, NULL);</span><br><span class="line">    if (dispatch_get_specific(mainQueueKey)) &#123;</span><br><span class="line">        // do something in main queue</span><br><span class="line">        //通过这样判断，就可以真正保证(我们在不主动搞事的情况下)，任务一定是放在主队列中的</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // do something in other queue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="更安全的方法二-SDWebImage使用的方法"><a href="#更安全的方法二-SDWebImage使用的方法" class="headerlink" title="更安全的方法二 (SDWebImage使用的方法)"></a>更安全的方法二 (SDWebImage使用的方法)</h5><p>我们知道在使用 GCD 创建一个 queue 的时候会指定 queue_label，可以理解为队列名，就像下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.apple.threadQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure><p>而第一个参数就是 queue_label，根据官方文档解释，这个queueLabel 是唯一的，所以SDWebImage就采用了这个方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//取得当前队列的队列名</span><br><span class="line">dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)</span><br><span class="line">   </span><br><span class="line">//取得主队列的队列名</span><br><span class="line">dispatch_queue_get_label(dispatch_get_main_queue())</span><br><span class="line"></span><br><span class="line">然后通过 strcmp 函数进行比较，如果为0 则证明当前队列就是主队列。</span><br></pre></td></tr></table></figure><p><strong>SDWebImage中的实例 ：判断当前是否是IOQueue</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)checkIfQueueIsIOQueue &#123;</span><br><span class="line">    const char *currentQueueLabel = dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL);</span><br><span class="line">    const char *ioQueueLabel = dispatch_queue_get_label(self.ioQueue);</span><br><span class="line">    if (strcmp(currentQueueLabel, ioQueueLabel) != 0) &#123;</span><br><span class="line">        NSLog(@&quot;This method should be called from the ioQueue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p>SDWebImage 就是从判断是否在<strong>主线程执行改为判断是否由主队列上调度</strong>。而由于主队列是一个串行队列，无论任务是异步同步都不会开辟新线程，所以当前队列是主队列等价于当前在主线程上执行。可以这样说，<strong>在主队列调度的任务肯定在主线程执行，而在主线程执行的任务不一定是由主队列调度的。</strong></p></blockquote><hr><h1 id="八、SDWebImage-的最大并发数-和-超时时长"><a href="#八、SDWebImage-的最大并发数-和-超时时长" class="headerlink" title="八、SDWebImage 的最大并发数 和 超时时长"></a>八、SDWebImage 的最大并发数 和 超时时长</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageDownloader.m   -initWithSessionConfiguration:</span><br><span class="line"></span><br><span class="line">_downloadQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">_downloadTimeout = 15.0;</span><br></pre></td></tr></table></figure><hr><h1 id="九、SDWebImage-的Memory缓存和Disk缓存是用什么实现的？"><a href="#九、SDWebImage-的Memory缓存和Disk缓存是用什么实现的？" class="headerlink" title="九、SDWebImage 的Memory缓存和Disk缓存是用什么实现的？"></a>九、SDWebImage 的Memory缓存和Disk缓存是用什么实现的？</h1><h3 id="9-1、Memory缓存实现-–-AutoPurgeCache"><a href="#9-1、Memory缓存实现-–-AutoPurgeCache" class="headerlink" title="9.1、Memory缓存实现 – AutoPurgeCache"></a>9.1、Memory缓存实现 – <code>AutoPurgeCache</code></h3><blockquote><h3 id="『AutoPurgeCache』类继承自-『NSCache』"><a href="#『AutoPurgeCache』类继承自-『NSCache』" class="headerlink" title="『AutoPurgeCache』类继承自 『NSCache』"></a>『AutoPurgeCache』类继承自 『NSCache』</h3></blockquote><p><code>SDWebImage</code> 还专门实现了一个叫做 <code>AutoPurgeCache</code> 的类 继承自 <code>NSCache</code> ，相比于普通的 <code>NSCache</code>， <strong>它提供了一个在内存紧张时候释放缓存的能力。</strong></p><ul><li>自动删除机制：当系统内存紧张时，<code>NSCache</code> 会自动删除一些缓存对象</li><li>线程安全：从不同线程中对同一个 <code>NSCache</code> 对象进行增删改查时，不需要加锁</li><li>不同于 <code>NSMutableDictionary</code>、<code>NSCache</code>存储对象时不会对 <code>key</code> 进行 <code>copy</code> 操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@interface AutoPurgeCache : NSCache</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AutoPurgeCache</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(removeAllObjects) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="9-2、Disk缓存实现-–-NSFileManager"><a href="#9-2、Disk缓存实现-–-NSFileManager" class="headerlink" title="9.2、Disk缓存实现 – NSFileManager"></a>9.2、Disk缓存实现 – <code>NSFileManager</code></h3><blockquote><p><code>SDImageCache</code> 的磁盘缓存是通过异步操作 <code>NSFileManager</code> 存储缓存文件到沙盒来实现的。</p></blockquote><hr><h1 id="十、读取Memory和Disk的时候如何保证线程安全？"><a href="#十、读取Memory和Disk的时候如何保证线程安全？" class="headerlink" title="十、读取Memory和Disk的时候如何保证线程安全？"></a>十、读取Memory和Disk的时候如何保证线程安全？</h1><h3 id="10-1、读取Memory"><a href="#10-1、读取Memory" class="headerlink" title="10.1、读取Memory"></a>10.1、读取Memory</h3><p><strong><code>NScache</code>是线程安全的，在多线程操作中，不需要对Cache加锁。</strong><br>读取缓存的时候是在主线程进行。由于使用NSCache进行存储、所以不需要担心单个value对象的线程安全。</p><h3 id="10-2、读取Disk"><a href="#10-2、读取Disk" class="headerlink" title="10.2、读取Disk"></a>10.2、读取Disk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property (SDDispatchQueueSetterSementics, nonatomic, nullable) dispatch_queue_t ioQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Create IO serial queue</span><br><span class="line">_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure><ul><li><strong>判断当前是否是IOQueue</strong> <strong><em>(原理：七、SDWebImage 如何保证UI操作放在主线程中执行？)</em></strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)checkIfQueueIsIOQueue &#123;</span><br><span class="line">    const char *currentQueueLabel = dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL);</span><br><span class="line">    const char *ioQueueLabel = dispatch_queue_get_label(self.ioQueue);</span><br><span class="line">    if (strcmp(currentQueueLabel, ioQueueLabel) != 0) &#123;</span><br><span class="line">        NSLog(@&quot;This method should be called from the ioQueue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在主要存储函数中，<strong>dispatch_async(self.ioQueue, ^{})</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SDImageCache.m</span><br><span class="line"></span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    // .........    </span><br><span class="line">    </span><br><span class="line">    if (toDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                NSData *data = imageData;</span><br><span class="line">                if (!data &amp;&amp; image) &#123;</span><br><span class="line">                    SDImageFormat imageFormatFromData = [NSData sd_imageFormatForImageData:data];</span><br><span class="line">                    data = [image sd_imageDataAsFormat:imageFormatFromData];</span><br><span class="line">                &#125;                </span><br><span class="line">                [self storeImageDataToDisk:data forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (completionBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completionBlock();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><ul><li>真正的磁盘缓存是在另一个IO专属线程中的一个串行队列下进行的。</li><li>如果你搜索self.ioQueue还能发现、不只是读取磁盘内容。</li><li>包括删除、写入等所有磁盘内容都是在这个IO线程进行、以保证线程安全。</li><li>但计算大小、获取文件总数等操作。则是在主线程进行。（<strong>看下面代码</strong>）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SDImageCache.m</span><br><span class="line"></span><br><span class="line">- (NSUInteger)getSize &#123;</span><br><span class="line">    __block NSUInteger size = 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        for (NSString *fileName in fileEnumerator) &#123;</span><br><span class="line">            NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">            size += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：我们可以看见，不会创建新线程且切操作会顺序执行。你可能会疑惑：为什么同样都是在主线程执行，这样没有死锁。其实这个和线程没有关系，和队列有关系，只要不放在主队列就不会阻塞主队列上的操作(各种系统的UI方法)，这个操作只是选择了合适的时机在主线程上跑了一下而已~</p><hr><h1 id="十一、SDWebImage-的Memory警告是如何处理的！"><a href="#十一、SDWebImage-的Memory警告是如何处理的！" class="headerlink" title="十一、SDWebImage 的Memory警告是如何处理的！"></a>十一、SDWebImage 的Memory警告是如何处理的！</h1><blockquote><h3 id="利用通知中心观察"><a href="#利用通知中心观察" class="headerlink" title="利用通知中心观察"></a>利用通知中心观察</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(clearMemory)</span><br><span class="line">                                             name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                           object:nil];</span><br></pre></td></tr></table></figure><ul><li>UIApplicationDidReceiveMemoryWarningNotification 接收到内存警告的通知<ul><li>执行 clearMemory 方法，清理内存缓存！</li></ul></li></ul><hr><h1 id="十二、SDWebImage-Disk缓存时长？-Disk清理操作时间点？-Disk清理原则？"><a href="#十二、SDWebImage-Disk缓存时长？-Disk清理操作时间点？-Disk清理原则？" class="headerlink" title="十二、SDWebImage Disk缓存时长？ Disk清理操作时间点？ Disk清理原则？"></a>十二、SDWebImage Disk缓存时长？ Disk清理操作时间点？ Disk清理原则？</h1><h4 id="12-1、默认为一周"><a href="#12-1、默认为一周" class="headerlink" title="12.1、默认为一周"></a>12.1、默认为一周</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// SDImageCacheConfig.m</span><br><span class="line"></span><br><span class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</span><br></pre></td></tr></table></figure><h4 id="12-2、磁盘清理时间点"><a href="#12-2、磁盘清理时间点" class="headerlink" title="12.2、磁盘清理时间点"></a>12.2、磁盘清理时间点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(deleteOldFiles)</span><br><span class="line">                                             name:UIApplicationWillTerminateNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line"></span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(backgroundDeleteOldFiles)</span><br><span class="line">                                             name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                           object:nil];</span><br></pre></td></tr></table></figure><blockquote><p><strong>分别在『应用被杀死时』和 『应用进入后台时』进行清理操作</strong></p></blockquote><p>清理磁盘的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br></pre></td></tr></table></figure><p>当应用进入后台时，会涉及到『<strong>Long-Running Task</strong>』<br>正常程序在进入后台后、虽然可以继续执行任务。但是在时间很短内就会被挂起待机。<br>Long-Running可以让系统为app再多分配一些时间来处理一些耗时任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)backgroundDeleteOldFiles &#123;</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">// 后台任务标识--注册一个后台任务</span><br><span class="line">    __block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        // Clean up any unfinished task business by marking where you</span><br><span class="line">        // stopped or ending the task outright.</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // Start the long-running task and return immediately.</span><br><span class="line">    [self deleteOldFilesWithCompletionBlock:^&#123;</span><br><span class="line">//结束后台任务</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-3、磁盘清理原则"><a href="#12-3、磁盘清理原则" class="headerlink" title="12.3、磁盘清理原则"></a>12.3、磁盘清理原则</h4><p>清理缓存的规则分两步进行。 第一步先清除掉过期的缓存文件。 如果清除掉过期的缓存之后，空间还不够。 那么就继续按文件时间从早到晚排序，先清除最早的缓存文件，直到剩余空间达到要求。</p><p>具体点，SDWebImage 是怎么控制哪些缓存过期，以及剩余空间多少才够呢？ 通过两个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface SDImageCacheConfig : NSObject</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The maximum length of time to keep an image in the cache, in seconds</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSInteger maxCacheAge;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The maximum size of the cache, in bytes.</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxCacheSize;</span><br></pre></td></tr></table></figure><p><strong>maxCacheAge 和 maxCacheSize 有默认值吗？</strong></p><ul><li><code>maxCacheAge</code> 在上述已经说过了，是有默认值的 <strong>1week</strong>，单位秒。</li><li><code>maxCacheSize</code> 翻了一遍 SDWebImage 的代码，并没有对 maxCacheSize 设置默认值。 这就意味着 SDWebImage 在默认情况下不会对缓存空间设限制。可以这样设置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SDImageCache sharedImageCache].maxCacheSize = 1024 * 1024 * 50;// 50M</span><br></pre></td></tr></table></figure></li></ul><p>maxCacheSize 是以字节来表示的，我们上面的计算代表 50M 的最大缓存空间。 把这行代码写在你的 APP 启动的时候，这样 SDWebImage 在清理缓存的时候，就会清理多余的缓存文件了。</p><h1 id="十三、SDWebImage-Disk目录位于哪里？"><a href="#十三、SDWebImage-Disk目录位于哪里？" class="headerlink" title="十三、SDWebImage Disk目录位于哪里？"></a>十三、SDWebImage Disk目录位于哪里？</h1><ul><li>缓存在沙盒目录下 <code>Library/Caches</code></li><li>默认情况下，二级目录为 <code>~/Library/Caches/default/com.hackemist.SDWebImageCache.default</code></li><li>也可自定义文件名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithNamespace:@&quot;default&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns &#123;</span><br><span class="line">    NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">    return [self initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line">   </span><br><span class="line">   // .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何打开-真机和模拟器-沙盒文件"><a href="#如何打开-真机和模拟器-沙盒文件" class="headerlink" title="如何打开 真机和模拟器 沙盒文件"></a>如何打开 真机和模拟器 沙盒文件</h4><ul><li><strong>模拟器</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) objectAtIndex:0];</span><br></pre></td></tr></table></figure><blockquote><p>通过 Finder -&gt; 前往 -&gt; 前往文件夹 -&gt; 将路径输入即可！</p></blockquote><ul><li><strong>真机</strong> </li></ul><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_SDWebImage_001.jpg" alt=""></p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_SDWebImage_002.jpg" alt=""></p><blockquote><p>通过 查看包内容 查看即可！</p></blockquote><h1 id="十四、SDWebImage-的回调设计？"><a href="#十四、SDWebImage-的回调设计？" class="headerlink" title="十四、SDWebImage 的回调设计？"></a>十四、SDWebImage 的回调设计？</h1><ul><li>Block<br>单个图片的分类、单个图片的下载。<br>每个操作任务中必现的progress以及completed。<br>所以、有很强的个体绑定需要或者使用次数不多时、倾向使用block</li><li>Delegate<br>SDWebImageManager下载完成之后的自定义图片处理、是否下载某个url。<br>这两个方法如果需要的话都是将会调用多次的。所以、用Delegate更好、可以将方法常驻。</li><li>同理<br>UITableView的使用Delegate、是用为在滚动途中、代理方法需要被不断的执行。<br>UIButton也是将会被多次点击。<br>UIView的动画/GCD则可以使用Block、因为只执行一次、用完释放。<br>所以、在日常使用中、我们也可以参考上述原则进行设计。</li></ul><h1 id="十五、SDWebImage-中-NS-OPTIONS-与-NS-ENUM-的使用"><a href="#十五、SDWebImage-中-NS-OPTIONS-与-NS-ENUM-的使用" class="headerlink" title="十五、SDWebImage 中 NS_OPTIONS 与 NS_ENUM 的使用"></a>十五、SDWebImage 中 <strong>NS_OPTIONS</strong> 与 <strong>NS_ENUM</strong> 的使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/// SDWebImageManager.h      Line 14</span><br><span class="line"></span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line">    SDWebImageRetryFailed = 1 &lt;&lt; 0,                    // 值为2的0次方</span><br><span class="line">    SDWebImageLowPriority = 1 &lt;&lt; 1,                    // 值为2的1次方</span><br><span class="line">    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,                // 值为2的2次方</span><br><span class="line">    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,            // 值为2的3次方</span><br><span class="line">    SDWebImageRefreshCached = 1 &lt;&lt; 4,                  // 值为2的4次方</span><br><span class="line">    SDWebImageContinueInBackground = 1 &lt;&lt; 5,           // 值为2的5次方</span><br><span class="line">    SDWebImageHandleCookies = 1 &lt;&lt; 6,                  // 值为2的6次方</span><br><span class="line">    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,    // 值为2的7次方</span><br><span class="line">    SDWebImageHighPriority = 1 &lt;&lt; 8,</span><br><span class="line">    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</span><br><span class="line">    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</span><br><span class="line">    SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</span><br><span class="line">    SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/// SDImageCache.h     Line 13</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    SDImageCacheTypeNone,             // 默认从0开始</span><br><span class="line">    SDImageCacheTypeDisk,             // 值为1</span><br><span class="line">    SDImageCacheTypeMemory            // 值为2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>NS_ENUM 定义 <strong>通用枚举</strong><br>NS_OPTIONS 定义 <strong>位移枚举</strong></p></blockquote><p>位移枚举即是在你需要的地方可以同时存在多个枚举值如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[gifImageView sd_setImageWithURL:url placeholderImage:image options:SDWebImageRefreshCached | SDWebImageRetryFailed progress:^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123;</span><br><span class="line"> </span><br><span class="line">            &#125;];</span><br></pre></td></tr></table></figure><p>而NS_ENUM定义的枚举不能几个枚举项同时存在，只能选择其中一项，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// SDImageCache.m      Line 407</span><br><span class="line"></span><br><span class="line">doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</span><br></pre></td></tr></table></figure><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// SDWebImageManager.m    Line 157</span><br><span class="line"></span><br><span class="line">SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">若 options = SDWebImageLowPriority | SDWebImageCacheMemoryOnly | SDWebImageProgressiveDownload </span><br><span class="line"></span><br><span class="line">| 运算规则：只要两个对应的二进制位有一个为1，结果位就为1，否则为0；</span><br><span class="line">&amp; 运算规则：只有两个对应的二进制位都为1时，结果位才为1，否则为0；</span><br><span class="line"></span><br><span class="line">转换为二进制</span><br><span class="line">options = 0001 | 0010 | 0100</span><br><span class="line">SDWebImageLowPriority = 0001</span><br><span class="line"></span><br><span class="line">options = 0111</span><br><span class="line">SDWebImageLowPriority = 0001</span><br><span class="line"></span><br><span class="line">if (options &amp; SDWebImageLowPriority)</span><br><span class="line">=== if(0111 &amp; 0001)</span><br><span class="line">=== if(0001)</span><br><span class="line">=== if(2)</span><br><span class="line"></span><br><span class="line">如果SDWebImageLowPriority = 1000</span><br><span class="line">if (options &amp; SDWebImageLowPriority)</span><br><span class="line">=== if(0111 &amp; 1000)</span><br><span class="line">=== if(0000)</span><br><span class="line">=== if(0)</span><br></pre></td></tr></table></figure><h1 id="十六、SDWebImage-中的工具类介绍"><a href="#十六、SDWebImage-中的工具类介绍" class="headerlink" title="十六、SDWebImage 中的工具类介绍"></a>十六、SDWebImage 中的工具类介绍</h1><p><a href="https://www.jianshu.com/p/9df79789fa98?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation" target="_blank" rel="noopener">工具类深入研读</a></p><ul><li><code>NSData+ImageContentType</code>: 根据图片数据获取图片的类型，比如GIF、PNG等。</li><li><code>SDWebImageCompat</code>: 根据屏幕的分辨倍数成倍放大或者缩小图片大小。</li><li><code>SDImageCacheConfig</code>: 图片缓存策略记录。比如是否解压缩、是否允许iCloud、是否允许内存缓存、缓存时间等。默认的缓存时间是一周。</li><li><code>UIImage+MultiFormat</code>: 获取UIImage对象对应的data、或者根据data生成指定格式的UIImage，其实就是UIImage和NSData之间的转换处理。</li><li><code>UIImage+GIF</code>: 对于一张图片是否GIF做判断。可以根据NSData返回一张GIF的UIImage对象，并且只返回GIF的第一张图片生成的GIF。如果要显示多张GIF，使用FLAnimatedImageView。</li><li><code>SDWebImageDecoder</code>: 根据图片的情况，做图片的解压缩处理。并且根据图片的情况决定如何处理解压缩。</li></ul><hr><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="http://swiftcafe.io/2017/02/19/sdimage-cache/" target="_blank" rel="noopener">天天都在用的 SDWebImage， 你了解它的缓存策略吗？</a></li><li><a href="https://www.jianshu.com/p/06f0265c22eb#" target="_blank" rel="noopener">[iOS 开发] SDWebImage 源码阅读笔记</a></li><li><a href="https://www.jianshu.com/p/3b8a7ae966d3" target="_blank" rel="noopener">iOS源码补完计划–SDWebImage4.0+源码参阅(附面试题/流程图)</a></li></ul><hr><blockquote><h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong><br><strong>原文地址：<a href="http://lionsom.com/2018/03/22/SDWebImage4-0源码探究（二）框架分析/" target="_blank" rel="noopener">SDWebImage4-0源码探究（二）框架分析</a></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一、SDWebImage UML分析&lt;/li&gt;
&lt;li&gt;二、SDWebImage 中 &lt;strong&gt;@autoreleasepool&lt;/strong&gt; 的应用&lt;/li&gt;
&lt;li&gt;三、SDWebImage 支持 &lt;strong&gt;GIF动图&lt;/strong&gt; 吗？&lt;/li&gt;
&lt;li&gt;四、SDWebImage 如何 &lt;strong&gt;区分图片格式&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;五、SDWebImage 缓存图片的名称如何 &lt;strong&gt;避免重名&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;六、SDWebImage 中 &lt;strong&gt;常量的定义&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;七、SDWebImage 如何保证UI操作放在主线程中执行？&lt;/li&gt;
&lt;li&gt;八、SDWebImage 的 &lt;strong&gt;最大并发数&lt;/strong&gt; 和 &lt;strong&gt;超时时长&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;九、SDWebImage 的Memory缓存和Disk缓存是用什么实现的？&lt;/li&gt;
&lt;li&gt;十、SDWebImage 读取Memory和Disk的时候如何保证 &lt;strong&gt;线程安全&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;十一、SDWebImage 的 &lt;strong&gt;Memory警告&lt;/strong&gt; 是如何处理的！&lt;/li&gt;
&lt;li&gt;十二、SDWebImage Disk缓存时长？ Disk清理操作时间点？ Disk清理原则？&lt;/li&gt;
&lt;li&gt;十三、SDWebImage &lt;strong&gt;Disk目录&lt;/strong&gt; 位于哪里？&lt;/li&gt;
&lt;li&gt;十四、SDWebImage 的回调设计？&lt;/li&gt;
&lt;li&gt;十五、SDWebImage 中 &lt;strong&gt;NS_OPTIONS&lt;/strong&gt; 与 &lt;strong&gt;NS_ENUM&lt;/strong&gt; 的使用&lt;/li&gt;
&lt;li&gt;十六、SDWebImage 中的工具类介绍&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="框架分析" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    
    
      <category term="SDWebImage" scheme="http://yoursite.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>Mac安装CocoaPods详解</title>
    <link href="http://yoursite.com/2018/03/21/Mac%E5%AE%89%E8%A3%85CocoaPods%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/21/Mac安装CocoaPods详解/</id>
    <published>2018-03-21T03:57:04.000Z</published>
    <updated>2018-03-22T07:23:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>Ruby环境的安装<ul><li>安装系统需要的包</li><li>Homebrew安装</li><li>安装RVM</li><li>使用RVM安装Ruby环境</li><li>设置 Ruby 版本</li><li>替换Ruby源为taobao.org    </li></ul></li><li>安装CocoaPods<ul><li>CocoaPods是什么？</li><li>直接安装CocoaPods</li><li>更新repos文件</li></ul></li><li>CocoaPods使用原理</li><li>后期使用出现的问题<ul><li>问题一：”setting up cocoapods master repo”卡着不动</li><li>问题二：<code>pod search</code>异常</li></ul></li></ul><a id="more"></a><h2 id="一、Ruby环境的安装"><a href="#一、Ruby环境的安装" class="headerlink" title="一、Ruby环境的安装"></a>一、Ruby环境的安装</h2><h3 id="1-1、安装系统需要的包"><a href="#1-1、安装系统需要的包" class="headerlink" title="1.1、安装系统需要的包"></a>1.1、安装系统需要的包</h3><blockquote><p>先安装 <a href="http://developer.apple.com/xcode/" target="_blank" rel="noopener">Xcode</a> 开发工具，它将帮你安装好 Unix 环境需要的开发包</p></blockquote><h3 id="1-2、Homebrew安装"><a href="#1-2、Homebrew安装" class="headerlink" title="1.2、Homebrew安装"></a>1.2、Homebrew安装</h3><h4 id="1-2-1、Homebrew是神马"><a href="#1-2-1、Homebrew是神马" class="headerlink" title="1.2.1、Homebrew是神马"></a>1.2.1、Homebrew是神马</h4><blockquote><p>linux系统有个让人蛋疼的通病，软件包依赖，好在当前主流的两大发行版本都自带了解决方案，Red hat有yum，Ubuntu有apt-get神马，你用mac os，不好意Mac os木有类似的东东，泪奔中几经折腾总算找到了第三方支持：Homebrew，Homebrew简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，可以说Homebrew就是mac下的apt-get、yum神器</p></blockquote><h4 id="1-2-2、是否已安装Homebrew"><a href="#1-2-2、是否已安装Homebrew" class="headerlink" title="1.2.2、是否已安装Homebrew"></a>1.2.2、是否已安装Homebrew</h4><ul><li><strong>brew search rabbitmq</strong>，能搜索到则证明已安装。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LionsomMBP:~ lionsom$ brew search rabbitmq</span><br><span class="line">==&gt; Searching local taps...</span><br><span class="line">rabbitmq                                 rabbitmq-c</span><br><span class="line">==&gt; Searching taps on GitHub...</span><br><span class="line">caskroom/cask/rabbitmq-app</span><br><span class="line">==&gt; Searching blacklisted, migrated and deleted formulae...</span><br></pre></td></tr></table></figure><h4 id="1-2-3、安装Homebrew"><a href="#1-2-3、安装Homebrew" class="headerlink" title="1.2.3、安装Homebrew"></a>1.2.3、安装Homebrew</h4><p>安装 Homebrew<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p><p>将以上命令粘贴至终端。</p><h4 id="1-2-4、更多详情，请前往Homebrew官网查看"><a href="#1-2-4、更多详情，请前往Homebrew官网查看" class="headerlink" title="1.2.4、更多详情，请前往Homebrew官网查看"></a>1.2.4、更多详情，请前往<a href="https://brew.sh" target="_blank" rel="noopener">Homebrew官网</a>查看</h4><h3 id="1-3、安装RVM"><a href="#1-3、安装RVM" class="headerlink" title="1.3、安装RVM"></a>1.3、安装RVM</h3><h4 id="1-3-1、RVM是什么？"><a href="#1-3-1、RVM是什么？" class="headerlink" title="1.3.1、RVM是什么？"></a>1.3.1、RVM是什么？</h4><blockquote><p>Ruby Version Manager简称RVM,是一款非常好用的ruby版本管理以及安装工具。</p></blockquote><h4 id="1-3-2、具体安装步骤"><a href="#1-3-2、具体安装步骤" class="headerlink" title="1.3.2、具体安装步骤"></a>1.3.2、具体安装步骤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure><p>期间可能会问你sudo管理员密码，以及自动通过homebrew安装依赖包，等待一段时间后就可以成功安装好 RVM。</p><p>然后，载入 RVM 环境（新开 Termal 就不用这么做了，会自动重新载入的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.rvm/scripts/rvm</span><br></pre></td></tr></table></figure><p>检查一下是否安装正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rvm -v</span><br><span class="line"></span><br><span class="line">rvm 1.29.3 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]</span><br></pre></td></tr></table></figure><h3 id="1-4、使用RVM安装Ruby环境"><a href="#1-4、使用RVM安装Ruby环境" class="headerlink" title="1.4、使用RVM安装Ruby环境"></a>1.4、使用RVM安装Ruby环境</h3><p>列出已知的ruby版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm list known</span><br></pre></td></tr></table></figure><p>可以选择现有的rvm版本来进行安装（下面以rvm 2.4版本的安装为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm install 2.4</span><br></pre></td></tr></table></figure><p>同样继续等待漫长的下载，编译过程，完成以后，Ruby, Ruby Gems 就安装好了。</p><p><strong>如果Honebrew没有安装，则在此过程中会进行自动安装。</strong></p><ul><li><p>查看是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br></pre></td></tr></table></figure></li><li><p>查询已经安装的ruby</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm list</span><br></pre></td></tr></table></figure></li><li><p>卸载一个已安装版本 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm remove 1.9.2</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5、设置-Ruby-版本"><a href="#1-5、设置-Ruby-版本" class="headerlink" title="1.5、设置 Ruby 版本"></a>1.5、设置 Ruby 版本</h3><p>RVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm 2.4.1 --default</span><br></pre></td></tr></table></figure><p>同样，也可以用其他版本号，前提是你有用 rvm install 安装过那个版本</p><p>这个时候你可以测试是否正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br><span class="line"></span><br><span class="line">ruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-darwin17]</span><br></pre></td></tr></table></figure><h3 id="1-6、替换Ruby源为taobao-org"><a href="#1-6、替换Ruby源为taobao-org" class="headerlink" title="1.6、替换Ruby源为taobao.org"></a>1.6、替换Ruby源为taobao.org</h3><blockquote><p>因为Ruby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，一种解决方案是将远替换成淘宝的，替换方式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem source -r https://rubygems.org/</span><br><span class="line">$ gem source -a https://ruby.taobao.org</span><br></pre></td></tr></table></figure><p>要想验证是否替换成功了，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure><p>正常的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://ruby.taobao.org</span><br></pre></td></tr></table></figure><p>到这里就已经把Ruby环境成功的安装到了Mac OS X上，接下来就可以进行相应的开发使用了。</p><h2 id="2、安装CocoaPods"><a href="#2、安装CocoaPods" class="headerlink" title="2、安装CocoaPods"></a>2、安装CocoaPods</h2><h3 id="2-1、CocoaPods是什么？"><a href="#2-1、CocoaPods是什么？" class="headerlink" title="2.1、CocoaPods是什么？"></a>2.1、CocoaPods是什么？</h3><blockquote><p>当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。总之小编的意思就是，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。如果能有什么工具能解决这些恼人的问题，那将“善莫大焉”。所以，你需要 CocoaPods。</p><p>CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。所以，作为iOS程序员的我们，掌握CocoaPods的使用是必不可少的基本技能了。</p></blockquote><h3 id="2-2、直接安装CocoaPods"><a href="#2-2、直接安装CocoaPods" class="headerlink" title="2.2、直接安装CocoaPods"></a>2.2、直接安装CocoaPods</h3><p>直接在终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>等待一小段时间，安装完成！！</p><p>验证是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod --version</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod search AFNetworking</span><br></pre></td></tr></table></figure><h3 id="2-3、在使用Pod进行操作之前最好手动更新repos文件"><a href="#2-3、在使用Pod进行操作之前最好手动更新repos文件" class="headerlink" title="2.3、在使用Pod进行操作之前最好手动更新repos文件"></a>2.3、在使用Pod进行操作之前最好手动更新repos文件</h3><blockquote><p>为什么最好手动导入呢？</p><p>如果不手动导入也没有问题，再使用<code>pod search AFNetworking</code>的时候pod会自动进行<code>setting up cocoapods master repo</code>的更新，由于文件过大，需要下载好一会儿。所以此时使用手动添加<code>repos</code>的文件比较方便。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_SetupPods_001.jpg" alt="setting up cocoapods master repo"></p><h4 id="2-3-1、如何前往-cocoapods文件"><a href="#2-3-1、如何前往-cocoapods文件" class="headerlink" title="2.3.1、如何前往.cocoapods文件"></a>2.3.1、如何前往<code>.cocoapods</code>文件</h4><ul><li>显示隐藏文件<code>Command + shift + .</code></li><li>也可在<code>Finder-&gt;前往-&gt;前往文件夹-&gt;./.cocoapods</code></li></ul><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_SetupPods_002.jpg" alt="前往./.cocoapods"></p><ul><li>具体路径如下</li></ul><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_SetupPods_003.jpg" alt="路径图"></p><h2 id="3、CocoaPods使用原理"><a href="#3、CocoaPods使用原理" class="headerlink" title="3、CocoaPods使用原理"></a>3、CocoaPods使用原理</h2><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_SetupPods_004.jpg" alt="流程图"></p><ul><li>pod setup<ul><li>将<strong>远程索引库</strong>下载到本地</li><li><strong>本地索引库</strong>路径（查看2.3.1）</li><li>同时生成<strong>检索文件（Key-Value格式，便于检索）</strong></li></ul></li><li>pod search AFN<ul><li>前往<strong>检索文件</strong>检索 </li><li>然后根据检索到的Value找到<strong>本地索引库</strong>中<code>.spec</code>查看框架的具体信息</li></ul></li><li>pod install<ul><li>得到AFN框架远程地址下载到我们项目中</li></ul></li></ul><h2 id="4、后期使用出现的问题"><a href="#4、后期使用出现的问题" class="headerlink" title="4、后期使用出现的问题"></a>4、后期使用出现的问题</h2><h3 id="4-1、问题一：”setting-up-cocoapods-master-repo”卡着不动"><a href="#4-1、问题一：”setting-up-cocoapods-master-repo”卡着不动" class="headerlink" title="4.1、问题一：”setting up cocoapods master repo”卡着不动"></a>4.1、问题一：”setting up cocoapods master repo”卡着不动</h3><blockquote><p>分析：<br>那个淘宝镜像（<a href="https://ruby.taobao.org）不可用了，所以需要使用最新的ruby镜像（https://gems.ruby-china.org/）" target="_blank" rel="noopener">https://ruby.taobao.org）不可用了，所以需要使用最新的ruby镜像（https://gems.ruby-china.org/）</a></p></blockquote><p><strong>具体操作 可查看1.6章节</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem source -r https://ruby.taobao.org</span><br><span class="line">$ gem source -a https://gems.ruby-china.org/</span><br></pre></td></tr></table></figure><h3 id="4-2、问题二：pod-search异常"><a href="#4-2、问题二：pod-search异常" class="headerlink" title="4.2、问题二：pod search异常"></a>4.2、问题二：<code>pod search</code>异常</h3><p><strong>4.2.1、执行pod setup</strong></p><ul><li>终端输入：<code>pod search AFNetworking</code></li><li>输出：<code>Unable to find a pod with name, author, summary, or descriptionmatching &#39;AFNetworking&#39;</code> 这时就需要继续下面的步骤了。</li></ul><p><strong>4.2.2、删除~/Library/Caches/CocoaPods目录下的search_index.json文件</strong></p><ul><li><code>pod setup</code>成功后，依然不能<code>pod search</code>，是因为之前你执行<code>pod search</code>生成了<code>search_index.json</code>，此时需要删掉。</li><li>终端输入：<code>rm ~/Library/Caches/CocoaPods/search_index.json</code></li><li>删除成功后，再执行<code>pod search</code>。</li></ul><p><strong>4.2.3、执行pod search</strong></p><ul><li>终端输入：<code>pod search afnetworking(不区分大小写)</code></li><li>输出：<code>Creating search index for spec repo &#39;master&#39;.. Done!</code>，稍等片刻······就会出现所有带有afnetworking字段的类库。</li></ul><hr><blockquote><h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong><br><strong>原文地址：<a href="http://lionsom.com/2018/03/21/Mac安装CocoaPods详解/" target="_blank" rel="noopener">Mac安装CocoaPods详解</a></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Ruby环境的安装&lt;ul&gt;
&lt;li&gt;安装系统需要的包&lt;/li&gt;
&lt;li&gt;Homebrew安装&lt;/li&gt;
&lt;li&gt;安装RVM&lt;/li&gt;
&lt;li&gt;使用RVM安装Ruby环境&lt;/li&gt;
&lt;li&gt;设置 Ruby 版本&lt;/li&gt;
&lt;li&gt;替换Ruby源为taobao.org    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安装CocoaPods&lt;ul&gt;
&lt;li&gt;CocoaPods是什么？&lt;/li&gt;
&lt;li&gt;直接安装CocoaPods&lt;/li&gt;
&lt;li&gt;更新repos文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CocoaPods使用原理&lt;/li&gt;
&lt;li&gt;后期使用出现的问题&lt;ul&gt;
&lt;li&gt;问题一：”setting up cocoapods master repo”卡着不动&lt;/li&gt;
&lt;li&gt;问题二：&lt;code&gt;pod search&lt;/code&gt;异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CocoaPods相关" scheme="http://yoursite.com/categories/CocoaPods%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="pods" scheme="http://yoursite.com/tags/pods/"/>
    
  </entry>
  
  <entry>
    <title>避免程序崩溃iOS探索</title>
    <link href="http://yoursite.com/2018/03/20/%E9%81%BF%E5%85%8D%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83iOS%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/03/20/避免程序崩溃iOS探索/</id>
    <published>2018-03-20T04:45:13.000Z</published>
    <updated>2018-04-01T09:05:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>Part ONE - 崩溃发生前之数据<code>&lt;null&gt;</code>处理</li><li>Part Two - 崩溃发生时Runtime避免崩溃</li><li>Part Three - 崩溃发生后Bug收集处理</li></ul><a id="more"></a><hr><h1 id="Part-ONE-崩溃发生前之数据-lt-null-gt-处理"><a href="#Part-ONE-崩溃发生前之数据-lt-null-gt-处理" class="headerlink" title="Part ONE - 崩溃发生前之数据&lt;null&gt;处理"></a>Part ONE - 崩溃发生前之数据<code>&lt;null&gt;</code>处理</h1><hr><h3 id="文件参考："><a href="#文件参考：" class="headerlink" title="文件参考："></a>文件参考：</h3><ul><li><a href="https://my.oschina.net/iq19900204/blog/408034" target="_blank" rel="noopener">ios中json解析出现的null问题</a></li><li><a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">GitHub-NullSafe</a></li></ul><h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p>客户端与服务器之间的数据请求一般以Json形式传递，正常有null值。<br>这个数据类型不是nil 也不是 String。 解析成对象之后，如果直接向这个对象发送消息（eg：length，count 等等）就会直接崩溃。提示错误为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[NSNull length]: unrecognized selector sent to instance 0x388a4a70</span><br></pre></td></tr></table></figure><h2 id="二、实战场景"><a href="#二、实战场景" class="headerlink" title="二、实战场景"></a>二、实战场景</h2><p><img src="http://upload-images.jianshu.io/upload_images/1859399-edc665b555034e8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据为null"></p><p><img src="http://upload-images.jianshu.io/upload_images/1859399-607940347ffad313.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用.length操作"></p><p><img src="http://upload-images.jianshu.io/upload_images/1859399-b2bbcc0a311d32dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="崩溃。。。"></p><h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><h4 id="方案一：解析后进行判断"><a href="#方案一：解析后进行判断" class="headerlink" title="方案一：解析后进行判断"></a>方案一：解析后进行判断</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//方法一</span><br><span class="line">if( [m isEqual:[NSNull null]] )</span><br><span class="line">&#123; </span><br><span class="line">    NSLog(@&quot;&lt;null&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//方法二</span><br><span class="line">if ( ![isKindOfClass:[NSNull class]] )</span><br><span class="line">&#123;</span><br><span class="line">    // 操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案二：AFN"><a href="#方案二：AFN" class="headerlink" title="方案二：AFN"></a>方案二：AFN</h4><p>如果你使用AFNetwork 这个库做网络请求的话，可以用以下代码，自动帮你去掉这个讨厌的空值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removesKeysWithNullValues = YES</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_dataSessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:baseUrl]];</span><br><span class="line">[_dataSessionManager setRequestSerializer:[AFJSONRequestSerializer serializer]];  //告诉AFN使用JSON格式，AFN内部会自动转JSON</span><br><span class="line"></span><br><span class="line">AFJSONResponseSerializer * response = [AFJSONResponseSerializer serializer];</span><br><span class="line">response.removesKeysWithNullValues = YES;</span><br><span class="line">    </span><br><span class="line">[_dataSessionManager setResponseSerializer:response];  //以JSON格式返回</span><br><span class="line">_dataSessionManager.requestSerializer.timeoutInterval = 10;</span><br></pre></td></tr></table></figure><h4 id="方案三：利用Category将nil转为-””"><a href="#方案三：利用Category将nil转为-””" class="headerlink" title="方案三：利用Category将nil转为@””"></a>方案三：利用Category将nil转为@””</h4><p><img src="http://upload-images.jianshu.io/upload_images/1859399-9aef960978c3970c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用案例"></p><p><strong>代码如下 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSDictionary (DeleteNull)</span><br><span class="line"></span><br><span class="line">+(id)changeType:(id)myObj;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  NSDictionary+DeleteNull.m</span><br><span class="line">//  PAL-iOS</span><br><span class="line">//</span><br><span class="line">//  Created by linxiang on 2017/11/1.</span><br><span class="line">//  Copyright © 2017年 minxing. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;NSDictionary+DeleteNull.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation NSDictionary (DeleteNull)</span><br><span class="line"></span><br><span class="line">#pragma mark - 私有方法</span><br><span class="line">//将NSDictionary中的Null类型的项目转化成@&quot;&quot;</span><br><span class="line">+(NSDictionary *)nullDic:(NSDictionary *)myDic</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *keyArr = [myDic allKeys];</span><br><span class="line">    NSMutableDictionary *resDic = [[NSMutableDictionary alloc]init];</span><br><span class="line">    for (int i = 0; i &lt; keyArr.count; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        id obj = [myDic objectForKey:keyArr[i]];</span><br><span class="line">        </span><br><span class="line">        obj = [self changeType:obj];</span><br><span class="line">        </span><br><span class="line">        [resDic setObject:obj forKey:keyArr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return resDic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将NSArray中的Null类型的项目转化成@&quot;&quot;</span><br><span class="line">+(NSArray *)nullArr:(NSArray *)myArr</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *resArr = [[NSMutableArray alloc] init];</span><br><span class="line">    for (int i = 0; i &lt; myArr.count; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        id obj = myArr[i];</span><br><span class="line">        </span><br><span class="line">        obj = [self changeType:obj];</span><br><span class="line">        </span><br><span class="line">        [resArr addObject:obj];</span><br><span class="line">    &#125;</span><br><span class="line">    return resArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将NSString类型的原路返回</span><br><span class="line">+(NSString *)stringToString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将Null类型的项目转化成@&quot;&quot;</span><br><span class="line">+(NSString *)nullToString</span><br><span class="line">&#123;</span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 公有方法</span><br><span class="line">//类型识别:将所有的NSNull类型转化成@&quot;&quot;</span><br><span class="line">+(id)changeType:(id)myObj</span><br><span class="line">&#123;</span><br><span class="line">    if ([myObj isKindOfClass:[NSDictionary class]])</span><br><span class="line">    &#123;</span><br><span class="line">        return [self nullDic:myObj];</span><br><span class="line">    &#125;</span><br><span class="line">    else if([myObj isKindOfClass:[NSArray class]])</span><br><span class="line">    &#123;</span><br><span class="line">        return [self nullArr:myObj];</span><br><span class="line">    &#125;</span><br><span class="line">    else if([myObj isKindOfClass:[NSString class]])</span><br><span class="line">    &#123;</span><br><span class="line">        return [self stringToString:myObj];</span><br><span class="line">    &#125;</span><br><span class="line">    else if([myObj isKindOfClass:[NSNull class]])</span><br><span class="line">    &#123;</span><br><span class="line">        return [self nullToString];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return myObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="方案四：NullSafe"><a href="#方案四：NullSafe" class="headerlink" title="方案四：NullSafe"></a>方案四：NullSafe</h4><h5 id="4-1、NullSafe简介"><a href="#4-1、NullSafe简介" class="headerlink" title="4.1、NullSafe简介"></a>4.1、NullSafe简介</h5><p>NullSafe是一个Category，在运行时操作，把这个讨厌的空值置为nil，而nil是安全的，可以向nil对象发送任何message而不会奔溃。这个category使用起来非常方便，只要加入到了工程中就可以了，你其他的什么都不用做，对，就是这么简单。详细的请去Github上查看：<br><a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">NullSafe</a></p><h5 id="4-2、NullSafe使用"><a href="#4-2、NullSafe使用" class="headerlink" title="4.2、NullSafe使用"></a>4.2、NullSafe使用</h5><p>使用时只需要把 <code>NullSafe.m</code> 文件拖进工程就可以了，它在程序运行时自动加载，你不需要再导入其他头文件了。</p><p>　　如果想要禁止 <code>NullSafe</code> 的话，需要设置：<code>NULLSAFE_ENABLED=0</code>，或者在 <code>.pch 文件</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">#define NULLSAFE_ENABLED 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h5 id="4-3、NullSafe原理"><a href="#4-3、NullSafe原理" class="headerlink" title="4.3、NullSafe原理"></a>4.3、NullSafe原理</h5><p><a href="https://www.2cto.com/kf/201710/690327.html" target="_blank" rel="noopener">iOS开发技巧之NullSafe原理分析</a></p><p>简单点说,当我们给一个<code>NSNull</code>对象发送消息的话，可能会崩溃<code>（null是有内存的）</code>，而发送给<code>nil</code>的话，是不会崩溃的。<br>作者就是使用了这么一个原理，把发送给<code>NSNull</code>的而<code>NSNull</code>又无法处理的消息经过如下几步处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个方法缓存，这个缓存会缓存项目中类的所有类名。</span><br><span class="line">2.遍历缓存，寻找是否已经有可以执行此方法的类。</span><br><span class="line">3.如果有的话，返回这个 NSMethodSignature 。</span><br><span class="line">4.如果没有的话，返回 nil ,接下来会走 forwardInvocation: 方法。</span><br><span class="line">5.[invocation invokeWithTarget:nil]; 将消息转发给 nil。</span><br></pre></td></tr></table></figure><p>那么，如何判断 <code>NSNull</code> 无法处理这个消息呢，在OC中，系统如果对某个实例发送消息之后，它（及其父类）无法处理（比如，没有这个方法等），系统就会发送 <code>methodSignatureForSelector</code> 消息，如果这个方法返回非空，那么就去执行返回的方法，如果为nil,则发送 <code>forwardInvocation</code> 消息。</p><p>这样就完成整个转发链了。</p><hr><h1 id="Part-TWO-崩溃发生时Runtime避免崩溃"><a href="#Part-TWO-崩溃发生时Runtime避免崩溃" class="headerlink" title="Part TWO - 崩溃发生时Runtime避免崩溃"></a>Part TWO - 崩溃发生时Runtime避免崩溃</h1><hr><h2 id="一、AvoidCrash"><a href="#一、AvoidCrash" class="headerlink" title="一、AvoidCrash"></a>一、AvoidCrash</h2><h3 id="1-1、AvoidCrash参考文档"><a href="#1-1、AvoidCrash参考文档" class="headerlink" title="1.1、AvoidCrash参考文档"></a>1.1、AvoidCrash参考文档</h3><p><a href="https://www.jianshu.com/p/5d625f86bd02" target="_blank" rel="noopener">iOS runtime实用篇–和常见崩溃say good-bye！</a><br>—<a href="https://github.com/chenfanfang/AvoidCrash" target="_blank" rel="noopener">AvoidCrash</a></p><h3 id="1-2、AvoidCrash与Bugly、友盟等三方冲突吗？"><a href="#1-2、AvoidCrash与Bugly、友盟等三方冲突吗？" class="headerlink" title="1.2、AvoidCrash与Bugly、友盟等三方冲突吗？"></a>1.2、AvoidCrash与Bugly、友盟等三方冲突吗？</h3><p><a href="https://www.jianshu.com/p/2b90aa96c0a0" target="_blank" rel="noopener">AvoidCrash的集成注意事项、疑惑的解答</a></p><blockquote><p>1、若集成了腾讯Bugly或者友盟等等异常搜集的SDK,AvoidCrash会影响到它们的异常搜集吗？</p></blockquote><p>首先要清楚的一点是，对于一些第三方crash信息搜集工具，比如Bugly或者友盟，它们只有当程序出现异常(崩溃)的时候才会搜集异常信息。而AvoidCrash的作用是，防止部分常见异常的发生，异常被AvoidCrash捕获了，程序就不会崩溃，第三方crash信息搜集工具就不会搜集到崩溃信息咯。</p><blockquote><p>2、如何处理才能既防止崩溃，又搜集到崩溃信息</p></blockquote><p>AvoidCrash若捕获到异常，将会发出一个通知:AvoidCrashNotification,监听该通知即可获取到原本将导致崩溃的具体信息。此时你可以利用Bugly的自定义异常接口将这些异常信息上传到Bugly。</p><h3 id="1-3、AvoidCrash分析"><a href="#1-3、AvoidCrash分析" class="headerlink" title="1.3、AvoidCrash分析"></a>1.3、AvoidCrash分析</h3><h5 id="1-3-1、不添加AvoidCrash情况下"><a href="#1-3-1、不添加AvoidCrash情况下" class="headerlink" title="1.3.1、不添加AvoidCrash情况下"></a>1.3.1、不添加AvoidCrash情况下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *nilStr = nil;</span><br><span class="line">NSArray *array = @[@&quot;lionsom&quot;, nilStr, @&quot;哈哈哈哈&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,array);</span><br></pre></td></tr></table></figure><p><strong>出现崩溃</strong><br><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_avoidCrash_001.jpg" alt="崩溃"></p><h5 id="1-3-2、添加AvoidCrash后"><a href="#1-3-2、添加AvoidCrash后" class="headerlink" title="1.3.2、添加AvoidCrash后"></a>1.3.2、添加AvoidCrash后</h5><ul><li>先交换初始化NSArray方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//instance array method exchange</span><br><span class="line">[AvoidCrash exchangeClassMethod:[self class]    </span><br><span class="line">                     method1Sel:@selector(arrayWithObjects:count:) </span><br><span class="line">                     method2Sel:@selector(AvoidCrashArrayWithObjects:count:)];</span><br></pre></td></tr></table></figure><ul><li>在我们自定义的<code>AvoidCrashArrayWithObjects:count:</code>方法中进行异常捕捉（此处涉及<code>@Try Catch</code> 和 <code>NSException</code>）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)AvoidCrashArrayWithObjects:(const id  _Nonnull __unsafe_unretained *)objects count:(NSUInteger)cnt &#123;</span><br><span class="line">    </span><br><span class="line">    id instance = nil;</span><br><span class="line">    </span><br><span class="line">    @try &#123;</span><br><span class="line">        instance = [self AvoidCrashArrayWithObjects:objects count:cnt];</span><br><span class="line">    &#125;</span><br><span class="line">    @catch (NSException *exception) &#123;</span><br><span class="line">        </span><br><span class="line">        NSString *defaultToDo = @&quot;AvoidCrash default is to remove nil object and instance a array.&quot;;</span><br><span class="line">        [AvoidCrash noteErrorWithException:exception defaultToDo:defaultToDo];</span><br><span class="line">        </span><br><span class="line">        //以下是对错误数据的处理，把为nil的数据去掉,然后初始化数组</span><br><span class="line">        NSInteger newObjsIndex = 0;</span><br><span class="line">        id  _Nonnull __unsafe_unretained newObjects[cnt];</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">            if (objects[i] != nil) &#123;</span><br><span class="line">                newObjects[newObjsIndex] = objects[i];</span><br><span class="line">                newObjsIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        instance = [self AvoidCrashArrayWithObjects:newObjects count:newObjsIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    @finally &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在自己写的函数中，如果出现异常，先将<strong>异常的具体信息</strong>抛出去，然后将<strong>NSArray中的nil移除得到新的数组</strong>。</p></li><li><p>外部接收到抛出的异常信息，整理。例如：获取具体的崩溃在哪个类的哪个方法中（如下）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//堆栈数据</span><br><span class="line">NSArray *callStackSymbolsArr = [NSThread callStackSymbols];</span><br><span class="line">    </span><br><span class="line">//获取在哪个类的哪个方法中实例化的数组  字符串格式 -[类名 方法名]  或者 +[类名 方法名]</span><br><span class="line">NSString *mainCallStackSymbolMsg = [AvoidCrash getMainCallStackSymbolMessageWithCallStackSymbols:callStackSymbolsArr];</span><br></pre></td></tr></table></figure><ul><li>最后将整理好的崩溃信息使用通知的形式传递出去，给具体的函数进行Bug上传服务器等操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将错误信息放在字典里，用通知的形式发送出去</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:AvoidCrashNotification object:nil userInfo:errorInfoDic];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="二、AvoidCrash常见问题"><a href="#二、AvoidCrash常见问题" class="headerlink" title="二、AvoidCrash常见问题"></a>二、AvoidCrash常见问题</h2><blockquote><p>1、若集成了腾讯Bugly或者友盟等等异常搜集的SDK,AvoidCrash会影响到它们的异常搜集吗？</p></blockquote><blockquote><p>2、为什么集成了AvoidCrash还是会报unrecognized selector sent to instance的异常？</p></blockquote><p><a href="https://www.jianshu.com/p/2b90aa96c0a0" target="_blank" rel="noopener">解惑</a></p><hr><h1 id="Part-Three-崩溃发生后Bug收集处理"><a href="#Part-Three-崩溃发生后Bug收集处理" class="headerlink" title="Part Three - 崩溃发生后Bug收集处理"></a>Part Three - 崩溃发生后Bug收集处理</h1><hr><h2 id="一、后期收集Bugly"><a href="#一、后期收集Bugly" class="headerlink" title="一、后期收集Bugly"></a>一、后期收集Bugly</h2><p><a href="https://bugly.qq.com/v2/" target="_blank" rel="noopener">Bugly官网</a></p><h2 id="二、热修复JSPatch"><a href="#二、热修复JSPatch" class="headerlink" title="二、热修复JSPatch"></a>二、热修复JSPatch</h2><p>搞不懂Apple审核。视情况使用！！</p><hr><blockquote><h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong><br><strong>原文地址：<a href="http://lionsom.com/2018/03/20/避免程序崩溃iOS探索/" target="_blank" rel="noopener">避免程序崩溃iOS探索</a></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Part ONE - 崩溃发生前之数据&lt;code&gt;&amp;lt;null&amp;gt;&lt;/code&gt;处理&lt;/li&gt;
&lt;li&gt;Part Two - 崩溃发生时Runtime避免崩溃&lt;/li&gt;
&lt;li&gt;Part Three - 崩溃发生后Bug收集处理&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS程序崩溃" scheme="http://yoursite.com/categories/iOS%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="崩溃" scheme="http://yoursite.com/tags/%E5%B4%A9%E6%BA%83/"/>
    
  </entry>
  
  <entry>
    <title>Mac+Hexo+github搭建myblog完整版</title>
    <link href="http://yoursite.com/2018/03/16/Hexo-github%E6%90%AD%E5%BB%BAmyblog%E5%AE%8C%E6%95%B4%E7%89%88/"/>
    <id>http://yoursite.com/2018/03/16/Hexo-github搭建myblog完整版/</id>
    <published>2018-03-16T07:34:48.000Z</published>
    <updated>2018-03-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>Part One - Hexo本地搭建运行</li><li>Part Two - github仓库创建和配置</li><li>Part Three - 本地Hexo关联github</li><li>Part Four - 绑定域名并设置域名解析</li><li>Part Five - Hexo日常操作</li><li>Part Six - Hexo主题更换</li><li>Part Seven - 实战中的一些问题</li></ul><a id="more"></a><hr><h1 id="Part-One-Hexo本地搭建运行"><a href="#Part-One-Hexo本地搭建运行" class="headerlink" title="Part One - Hexo本地搭建运行"></a>Part One - Hexo本地搭建运行</h1><hr><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官网</a><br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs官网</a></p><h3 id="1-1、Hexo安装的前提"><a href="#1-1、Hexo安装的前提" class="headerlink" title="1.1、Hexo安装的前提"></a>1.1、Hexo安装的前提</h3><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> 需要先安装 按照流程安装即可！</li><li>npm      与Nodejs一起安装完成，不需要单独安装！</li><li><a href="https://git-scm.com" target="_blank" rel="noopener">Git</a>     Mac系统自带无需安装</li></ul><h3 id="1-2、安装-Hexo"><a href="#1-2、安装-Hexo" class="headerlink" title="1.2、安装 Hexo"></a>1.2、安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><strong>注意：此处可能需要root权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---切换root---</span><br><span class="line">LionsomMBP:~ lionsom$ sudo -i </span><br><span class="line"></span><br><span class="line">---切换lionsom普通用户---</span><br><span class="line">LionsomMBP:~ root# su - lionsom</span><br></pre></td></tr></table></figure><p><img src="/assets/img/Hexo-github搭建myblog完整版/001.jpg" alt="npm install -g hexo-cli"></p><h3 id="1-3、安装Hexo完成，则开始初始化hexo"><a href="#1-3、安装Hexo完成，则开始初始化hexo" class="headerlink" title="1.3、安装Hexo完成，则开始初始化hexo"></a>1.3、安装Hexo完成，则开始初始化hexo</h3><ul><li>创建一个文件夹myblog</li><li>进入myblog</li><li><p>hexo init<br><img src="/assets/img/Hexo-github搭建myblog完整版/002.jpg" alt="hexo init"></p></li><li><p>文件目录结构<br><img src="/assets/img/Hexo-github搭建myblog完整版/myblog目录.jpg" alt="myblog生成点文件目录"></p></li></ul><h3 id="1-4、依赖包与插件的安装"><a href="#1-4、依赖包与插件的安装" class="headerlink" title="1.4、依赖包与插件的安装"></a>1.4、依赖包与插件的安装</h3><ul><li>执行以下命令，进行依赖包的安装，<ul><li>node_modules: 关联保存了将会使用到的hexo依赖包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>![依赖包安装](/assets/img/Hexo-github搭建myblog完整版/依赖包安装.jpg)</code></pre><ul><li><p>安装相关插件</p><ul><li><p><strong>重要：安装便于自动部署到Github上的插件</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>安装atom生成插件，便于感兴趣的小伙伴们订阅</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure></li><li><p>安装博客首页生成插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-index --save</span><br></pre></td></tr></table></figure></li><li><p>安装归档生成插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-archive --save</span><br></pre></td></tr></table></figure></li><li><p>安装tag生成插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-tag --save</span><br></pre></td></tr></table></figure></li><li><p>安装category生成插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-category --save</span><br></pre></td></tr></table></figure></li><li><p>安装Sitemap文件生成插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure></li><li><p>安装百度Sitemap文件生成插件，因为普通的Sitemap格式不符合百度的要求</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-5、本地启动Hexo"><a href="#1-5、本地启动Hexo" class="headerlink" title="1.5、本地启动Hexo"></a>1.5、本地启动Hexo</h3><h4 id="操作指令一览表"><a href="#操作指令一览表" class="headerlink" title="操作指令一览表"></a>操作指令一览表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean      #清理缓存</span><br><span class="line">$ hexo generate   #生成静态文件</span><br><span class="line">$ hexo server  #启动本地服务器</span><br><span class="line">或者</span><br><span class="line">$ hexo clean      #清理缓存</span><br><span class="line">$ hexo g          #生成静态文件</span><br><span class="line">$ hexo s          #启动本地服务器</span><br></pre></td></tr></table></figure><ul><li>前往myblog目录 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;test&quot;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/assets/img/Hexo-github搭建myblog完整版/创建新blog.jpg" alt="创建新blog"></p><ul><li><p>在生成路径下查看<br><img src="/assets/img/Hexo-github搭建myblog完整版/新blog路径.jpg" alt="路径"></p></li><li><p>Hexo本地生成</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>  <img src="/assets/img/Hexo-github搭建myblog完整版/Hexo本地generate.jpg" alt="Hexo本地生成"></p></li><li><p>Hexo本地运行</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p><img src="/assets/img/Hexo-github搭建myblog完整版/Hexo本地运行.jpg" alt="hexo本地运行"></p><p> <img src="/assets/img/Hexo-github搭建myblog完整版/Hexo本地运行效果图.jpg" alt="Hexo本地运行效果图"></p><hr><h1 id="Part-Two-github仓库创建和配置"><a href="#Part-Two-github仓库创建和配置" class="headerlink" title="Part Two - github仓库创建和配置"></a>Part Two - github仓库创建和配置</h1><hr><h3 id="2-1、github仓库创建"><a href="#2-1、github仓库创建" class="headerlink" title="2.1、github仓库创建"></a>2.1、github仓库创建</h3><ul><li>仓库名字必须是<strong>『username.github.io』</strong>格式；</li><li>创建GitHub Pages<br><img src="/assets/img/Hexo-github搭建myblog完整版/GitHub_Pages创建.jpg" alt="GitHub Pages创建"></li></ul><h3 id="2-2、配置git"><a href="#2-2、配置git" class="headerlink" title="2.2、配置git"></a>2.2、配置git</h3><ul><li><p>设置用户名和邮箱</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email &quot;lionsom_lin@qq.com&quot;</span><br><span class="line">$ git config --global user.name &quot;lionsom&quot;</span><br></pre></td></tr></table></figure></li><li><p>根据邮箱生成密钥 - 如下图，如无特殊需求</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;lionsom_lin@qq.com&quot;</span><br></pre></td></tr></table></figure><p>  <img src="/assets/img/Hexo-github搭建myblog完整版/密钥生成1.jpg" alt="生成密钥具体操作"></p></li><li><p>查看生成的密钥-在隐藏文件 <strong>.ssh</strong> 中，其中<code>id_rsa</code>是私钥，<code>id_rsa.pub</code>是公钥<br><img src="/assets/img/Hexo-github搭建myblog完整版/生成的密钥.jpg" alt="密钥生成路径"></p></li><li><p><code>ssh-agent</code>代管理git<strong>私钥</strong></p><ul><li><code>ssh-agent</code>是一个密钥管理器，运行<code>ssh-agent</code>以后，使用<code>ssh-add</code>将私钥交给<code>ssh-agent</code>保管，其他程序需要身份验证的时候可以将验证申请交给<code>ssh-agent</code>来完成整个认证过程。 </li></ul></li><li><p>添加<code>SSH Key</code>到<code>ssh-agent</code></p><ul><li><p>执行命令 获取 <code>agent pid 59566</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval $(ssh-agent -s)</span><br></pre></td></tr></table></figure></li><li><p>添加<code>id_rsa</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add /Users/lionsom/.ssh/id_rsa</span><br></pre></td></tr></table></figure></li></ul></li><li><p>将生成的公钥 配置到 github</p><ul><li>记事本打开<code>id_rsa.pub</code>密钥，复制内容，前往github账户中心<code>Settings</code>,进行如下图操作。<br><img src="/assets/img/Hexo-github搭建myblog完整版/公钥添加到github.jpg" alt="公钥添加"></li></ul></li><li><p>验证<strong>SSH</strong>是否配置完成</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>  成功则出现</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You&apos;ve successfully authenticated, but github does not provide shell access.</span><br></pre></td></tr></table></figure><p>  如图：<br><img src="/assets/img/Hexo-github搭建myblog完整版/密钥添加.jpg" alt="添加是否完成"></p></li></ul><hr><h1 id="Part-Three-本地Hexo关联github"><a href="#Part-Three-本地Hexo关联github" class="headerlink" title="Part Three - 本地Hexo关联github"></a>Part Three - 本地Hexo关联github</h1><hr><h3 id="3-1、配置-config-yml"><a href="#3-1、配置-config-yml" class="headerlink" title="3.1、配置_config.yml"></a>3.1、配置<strong>_config.yml</strong></h3><p><img src="/assets/img/Hexo-github搭建myblog完整版/config.yml.jpg" alt="具体配置"></p><h3 id="3-2、前往Hexo本地目录生成静态网页并Deploy到github"><a href="#3-2、前往Hexo本地目录生成静态网页并Deploy到github" class="headerlink" title="3.2、前往Hexo本地目录生成静态网页并Deploy到github"></a>3.2、前往Hexo本地目录生成静态网页并Deploy到github</h3><ul><li>确认依赖包和插件安装完成，特别是<code>hexo-deployer-git</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>指令操作</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean  #清理缓存</span><br><span class="line">$ hexo g      #生成静态文件</span><br><span class="line">$ hexo d      #部署</span><br><span class="line">或 $ hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>实际操作图</p><ul><li>清理缓存+重新生成静态文件<br><img src="/assets/img/Hexo-github搭建myblog完整版/clean+generate.jpg" alt="清理缓存+重新生成静态文件"></li><li>部署到github<br><img src="/assets/img/Hexo-github搭建myblog完整版/deploy.jpg" alt="部署到github"></li></ul></li><li><p>输入<a href="https://lionsom.github.io" target="_blank" rel="noopener">https://lionsom.github.io</a>查看<br>  <img src="/assets/img/Hexo-github搭建myblog完整版/部署成功.jpg" alt="部署成功"></p></li></ul><hr><hr><h1 id="以上就能实现基本的个人blog"><a href="#以上就能实现基本的个人blog" class="headerlink" title="以上就能实现基本的个人blog"></a>以上就能实现基本的个人blog</h1><hr><hr><h4 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h4><ul><li><a href="https://www.jianshu.com/p/148f8d803e80" target="_blank" rel="noopener">我特么搭个博客容易么[Hexo+githubPages]（一）</a></li><li><a href="https://www.jianshu.com/p/f47ac6081f30" target="_blank" rel="noopener">我特么搭个博客容易么[Hexo+githubPages]（二）</a></li><li><a href="https://www.jianshu.com/p/fae0d7ecc486" target="_blank" rel="noopener">我特么搭个博客容易么[Hexo+githubPages]（三）</a></li><li><a href="https://www.jianshu.com/p/a1778c515a33" target="_blank" rel="noopener">使用Hexo在GitHub Pages上搭建部署免费的个人博客网站（上：GitHub搭建）——最详细全面解读教程（没有之一）</a></li><li><a href="https://www.jianshu.com/p/c9295bacd98b" target="_blank" rel="noopener">使用Hexo在GitHub Pages上搭建部署免费的个人博客网站（下：Hexo部署）——最详细全面解读教程（没有之一）</a></li></ul><hr><h1 id="Part-Four-绑定域名并设置域名解析"><a href="#Part-Four-绑定域名并设置域名解析" class="headerlink" title="Part Four - 绑定域名并设置域名解析"></a>Part Four - 绑定域名并设置域名解析</h1><hr><blockquote><p><strong>GitHub为我们每个注册的用户提供了一个唯一的 <code>username.github.io</code> 网址，GitHub服务器会帮我们托管这个 <code>username.github.io</code> 所用到的全部代码，自动运行，所以我们就不需要购买服务器或者云主机来自己运行了。但是，我们之所以购买域名，就是不想总是通过 <code>username.github.io</code> 来访问我们的个人网站，而是希望通过自己的独立域名来访问。把 <code>username.github.io</code> 和自己购买的域名相关联</strong></p></blockquote><h2 id="方法一：（不推荐）"><a href="#方法一：（不推荐）" class="headerlink" title="方法一：（不推荐）"></a>方法一：（不推荐）</h2><h4 id="1、进入github项目中的Settings中，找到Github-Pages中的Custom-domain，输入自己的域名，点击Save即可。"><a href="#1、进入github项目中的Settings中，找到Github-Pages中的Custom-domain，输入自己的域名，点击Save即可。" class="headerlink" title="1、进入github项目中的Settings中，找到Github Pages中的Custom domain，输入自己的域名，点击Save即可。"></a>1、进入github项目中的<code>Settings</code>中，找到<code>Github Pages</code>中的<code>Custom domain</code>，输入自己的域名，点击Save即可。</h4><p><img src="/assets/img/Hexo-github搭建myblog完整版/github域名添加.jpg" alt="github域名添加"></p><h4 id="2、查看项目中多了-CNAME-文件"><a href="#2、查看项目中多了-CNAME-文件" class="headerlink" title="2、查看项目中多了 CNAME 文件"></a>2、查看项目中多了 <code>CNAME</code> 文件</h4><p><img src="/assets/img/Hexo-github搭建myblog完整版/github域名添加成功.jpg" alt="github域名添加成功"></p><h4 id="3、域名解析"><a href="#3、域名解析" class="headerlink" title="3、域名解析"></a>3、域名解析</h4><ul><li>记录类型：CNAME，主机记录：@，记录值一定要是 username.github.io，TTL：一般都是10分钟。<br><img src="/assets/img/Hexo-github搭建myblog完整版/域名解析设置.jpg" alt="域名解析"></li></ul><h4 id="4、检测是否绑定成功"><a href="#4、检测是否绑定成功" class="headerlink" title="4、检测是否绑定成功"></a>4、检测是否绑定成功</h4><p><img src="/assets/img/Hexo-github搭建myblog完整版/域名解析成功.jpg" alt="域名解析成功"></p><h4 id="5、此方法弊端"><a href="#5、此方法弊端" class="headerlink" title="5、此方法弊端"></a>5、此方法弊端</h4><p>如果重新generate并deploy，域名与<code>username.github.io</code>关联失效，需要重新设置一遍。</p><h2 id="方式二：（推荐）"><a href="#方式二：（推荐）" class="headerlink" title="方式二：（推荐）"></a>方式二：（推荐）</h2><h4 id="1、在本地hexo根目录-》source中创建文件『CNAME』，写入域名lionsom-com"><a href="#1、在本地hexo根目录-》source中创建文件『CNAME』，写入域名lionsom-com" class="headerlink" title="1、在本地hexo根目录-》source中创建文件『CNAME』，写入域名lionsom.com"></a>1、在本地hexo根目录-》source中创建文件『CNAME』，写入域名<code>lionsom.com</code></h4><p><img src="/assets/img/Hexo-github搭建myblog完整版/本地创建CNAME文件.jpg" alt="操作如图"></p><h4 id="2、重新部署一次，查看结果"><a href="#2、重新部署一次，查看结果" class="headerlink" title="2、重新部署一次，查看结果"></a>2、重新部署一次，查看结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean  #清理缓存</span><br><span class="line">$ hexo g      #生成静态文件</span><br><span class="line">$ hexo d      #部署</span><br></pre></td></tr></table></figure><p><img src="/assets/img/Hexo-github搭建myblog完整版/github多出CNAME文件.jpg" alt="多出CNAME文件"></p><p><img src="/assets/img/Hexo-github搭建myblog完整版/域名解析成功2.jpg" alt="解析成功"></p><h4 id="域名绑定完成！！"><a href="#域名绑定完成！！" class="headerlink" title="域名绑定完成！！"></a>域名绑定完成！！</h4><hr><h1 id="Part-Five-Hexo日常操作"><a href="#Part-Five-Hexo日常操作" class="headerlink" title="Part Five - Hexo日常操作"></a>Part Five - Hexo日常操作</h1><hr><h3 id="官网-1"><a href="#官网-1" class="headerlink" title="官网"></a>官网</h3><p><a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="noopener">hexo官网使用-基本操作</a></p><h3 id="5-1、进行常用的配置"><a href="#5-1、进行常用的配置" class="headerlink" title="5.1、进行常用的配置"></a>5.1、进行常用的配置</h3><h4 id="5-1-1、layout设置"><a href="#5-1-1、layout设置" class="headerlink" title="5.1.1、layout设置"></a>5.1.1、layout设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，<br>默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><h4 id="5-1-2、文件名称设置"><a href="#5-1-2、文件名称设置" class="headerlink" title="5.1.2、文件名称设置"></a>5.1.2、文件名称设置</h4><p>Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Writing</span><br><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure><h4 id="5-1-3、模版（Scaffold）设置"><a href="#5-1-3、模版（Scaffold）设置" class="headerlink" title="5.1.3、模版（Scaffold）设置"></a>5.1.3、模版（Scaffold）设置</h4><p><a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">hexo官网使用-Front-matter</a></p><p><img src="/assets/img/Hexo-github搭建myblog完整版/front-matter.jpg" alt="front-matter"></p><p><img src="/assets/img/Hexo-github搭建myblog完整版/Scaffold设置.jpg" alt="Scaffold设置"></p><h4 id="5-1-4、资源设置-图片等"><a href="#5-1-4、资源设置-图片等" class="headerlink" title="5.1.4、资源设置-图片等"></a>5.1.4、资源设置-图片等</h4><p><a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="noopener">hexo官网使用-资源文件夹</a></p><blockquote><p>文章资源文件夹</p><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p><strong>使用相对路径进行资源引用：<code>./XXXX.jpg</code></strong></p><h3 id="5-2、创建新blog"><a href="#5-2、创建新blog" class="headerlink" title="5.2、创建新blog"></a>5.2、创建新blog</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new blog_name</span><br></pre></td></tr></table></figure><p>生成两个文件：blog_name.md 和 blog_name资源文件夹</p><hr><h1 id="Part-Six-Hexo主题更换"><a href="#Part-Six-Hexo主题更换" class="headerlink" title="Part Six - Hexo主题更换"></a>Part Six - Hexo主题更换</h1><hr><h3 id="6-1、主题设置"><a href="#6-1、主题设置" class="headerlink" title="6.1、主题设置"></a>6.1、主题设置</h3><p><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">github主题列表地址</a></p><p><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a></p><h4 id="6-1-1、将主题clone到themes文件夹中"><a href="#6-1-1、将主题clone到themes文件夹中" class="headerlink" title="6.1.1、将主题clone到themes文件夹中"></a>6.1.1、将主题clone到themes文件夹中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LionsomMBP:myblog lionsom$ cd themes/</span><br><span class="line">LionsomMBP:themes lionsom$ git clone https://github.com/litten/hexo-theme-yilia.git</span><br></pre></td></tr></table></figure><h4 id="6-1-2、修改Hexo的-config-yml文件配置"><a href="#6-1-2、修改Hexo的-config-yml文件配置" class="headerlink" title="6.1.2、修改Hexo的_config.yml文件配置"></a>6.1.2、修改Hexo的_config.yml文件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: hexo-theme-yilia</span><br></pre></td></tr></table></figure><h4 id="6-1-3、重新加载"><a href="#6-1-3、重新加载" class="headerlink" title="6.1.3、重新加载"></a>6.1.3、重新加载</h4><p><img src="/assets/img/Hexo-github搭建myblog完整版/主题更换成功.jpg" alt="显示主题效果"></p><h3 id="6-2、yilia主题内部设置"><a href="#6-2、yilia主题内部设置" class="headerlink" title="6.2、yilia主题内部设置"></a>6.2、yilia主题内部设置</h3><ul><li><p>直接参考yilia原版配置，参考配置即可！！</p><ul><li><p><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia 官网</a></p></li><li><p><a href="https://github.com/litten/BlogBackup" target="_blank" rel="noopener">yilia-BlogBackup 样例</a></p></li></ul></li><li><p>具体配置中遇到个小麻烦-目录显示不出来<br>  <img src="/assets/img/Hexo-github搭建myblog完整版/yilia配置.jpg" alt="目录显示不出来"></p><ul><li>严格按照上述配置即可！</li></ul></li><li><p>yilia内部资源路径的问题</p><ul><li>这里的路径是Hexo根目录下source下点资源，</li><li><p>完整的路径是指Hexo/source/assets/img/wechatpay.jpg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#你的头像url</span><br><span class="line">avatar: /assets/img/wechatpay.jpg</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h1 id="Part-Seven-实战中的一些问题"><a href="#Part-Seven-实战中的一些问题" class="headerlink" title="Part Seven - 实战中的一些问题"></a>Part Seven - 实战中的一些问题</h1><hr><h3 id="7-1、图片资源加载不出来的问题"><a href="#7-1、图片资源加载不出来的问题" class="headerlink" title="7.1、图片资源加载不出来的问题"></a>7.1、图片资源加载不出来的问题</h3><p><img src="/assets/img/Hexo-github搭建myblog完整版/图片加载异常1.jpg" alt=""></p><p><img src="/assets/img/Hexo-github搭建myblog完整版/图片加载异常2.jpg" alt=""></p><p>根据上图点结论，所以，资源路径不推荐5.1.4所推荐的设置，依旧推荐在</p><p><img src="/assets/img/Hexo-github搭建myblog完整版/图片推荐路径.jpg" alt="推荐路径"></p><p><strong>使用路径 /assets/img/myhead.jpg</strong></p><h3 id="7-2、主页面预览，不显示全部内容"><a href="#7-2、主页面预览，不显示全部内容" class="headerlink" title="7.2、主页面预览，不显示全部内容"></a>7.2、主页面预览，不显示全部内容</h3><p><img src="/assets/img/Hexo-github搭建myblog完整版/显示more.jpg" alt="推荐路径"></p><p>我们可以这样解决，打开一篇文章，添加<code>&lt;!--more--&gt;</code>即可！！！</p><h3 id="7-3、设置网页浏览次数"><a href="#7-3、设置网页浏览次数" class="headerlink" title="7.3、设置网页浏览次数"></a>7.3、设置网页浏览次数</h3><p><a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a></p><blockquote><p>如果你是用的hexo，打开<code>themes/你的主题/layout/_partial/footer.ejs</code>添加即可。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 脚本</span><br><span class="line">&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"># 标签</span><br><span class="line">&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">    本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p><img src="/assets/img/Hexo-github搭建myblog完整版/不蒜子设置.jpg" alt="设置"></p><hr><blockquote><h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong><br><strong>原文地址：<a href="http://lionsom.com/2018/03/16/Hexo-github搭建myblog完整版/" target="_blank" rel="noopener">Mac+Hexo+github搭建myblog完整版</a></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Part One - Hexo本地搭建运行&lt;/li&gt;
&lt;li&gt;Part Two - github仓库创建和配置&lt;/li&gt;
&lt;li&gt;Part Three - 本地Hexo关联github&lt;/li&gt;
&lt;li&gt;Part Four - 绑定域名并设置域名解析&lt;/li&gt;
&lt;li&gt;Part Five - Hexo日常操作&lt;/li&gt;
&lt;li&gt;Part Six - Hexo主题更换&lt;/li&gt;
&lt;li&gt;Part Seven - 实战中的一些问题&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="myblog搭建" scheme="http://yoursite.com/categories/myblog%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
</feed>
