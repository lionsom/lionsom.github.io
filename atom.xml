<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到lionsom的blog</title>
  
  <subtitle>人生苦短，天马行空！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-19T15:37:00.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lionsom</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SDWebImage4.0源码探究（一）UML类图和时序图</title>
    <link href="http://yoursite.com/2018/04/10/SDWebImage4-0%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89UML%E7%B1%BB%E5%9B%BE%E5%92%8C%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/04/10/SDWebImage4-0源码探究（一）UML类图和时序图/</id>
    <published>2018-04-10T02:42:56.000Z</published>
    <updated>2018-04-19T15:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>SDWebImage类图和时序图</li><li>UML类图阅读规则</li><li>UML时序图阅读规则</li></ul><a id="more"></a><h2 id="一、SDWebImage类图和时序图"><a href="#一、SDWebImage类图和时序图" class="headerlink" title="一、SDWebImage类图和时序图"></a>一、SDWebImage类图和时序图</h2><p><img src="https://github.com/rs/SDWebImage/raw/master/Docs/SDWebImageClassDiagram.png" alt="SDWebImage类图"></p><p><img src="https://github.com/rs/SDWebImage/blob/master/Docs/SDWebImageSequenceDiagram.png?raw=true" alt="SDWebImage时序图"></p><h2 id="二、UML类图阅读规则"><a href="#二、UML类图阅读规则" class="headerlink" title="二、UML类图阅读规则"></a>二、UML类图阅读规则</h2><p><a href="https://www.jianshu.com/p/10cc65dea07a" target="_blank" rel="noopener">UML基本使用–类图</a></p><h4 id="UML-Class"><a href="#UML-Class" class="headerlink" title="UML Class"></a>UML Class</h4><p>类图的3个基本组件：类名，属性，方法。<br>在描述方法时可以通过在方法下面添加一个横线来区分类方法和实例方法,以及在后面添加 readOnly 来表明只读属性</p><p><img src="https://upload-images.jianshu.io/upload_images/183487-47aa82683b4dfd5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/241" alt="UML_Class"></p><h4 id="UML-Protocol"><a href="#UML-Protocol" class="headerlink" title="UML Protocol"></a>UML Protocol</h4><p><img src="https://upload-images.jianshu.io/upload_images/183487-b6a9f167dfc46e9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/585" alt="UML_Protocol"></p><h4 id="常见的关系"><a href="#常见的关系" class="headerlink" title="常见的关系"></a>常见的关系</h4><ul><li><h4 id="继承（Generalization）"><a href="#继承（Generalization）" class="headerlink" title="继承（Generalization）"></a>继承（Generalization）</h4></li></ul><p>【定义】：表示的是子类和父类的关系，例如猫和动物的关系一样<br>【描述方式】：带三角箭头的实现，箭头指向父类<br><img src="https://upload-images.jianshu.io/upload_images/183487-68f9c3a012985380..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/208" alt=""></p><ul><li><h4 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h4></li></ul><p>【定义】：描述的是一种类与接口(协议)的关系<br>【描述方式】：用带三角箭头的虚线表示，箭头指向接口。<br><img src="https://upload-images.jianshu.io/upload_images/183487-e0ac831baad632ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/435" alt=""></p><ul><li><h4 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h4></li></ul><p>【定义】：是一种拥有关系，它使得一个类知道另一个类的属性或方法；分为双向关联和单向关联。例如老师和学生是双向关联，老师可以有多名学生，学生也可以有多名老师；但学生和课程之间就是单向关联的，一个学生可以有多门课程上，但是课程不拥有学生。<br>【描述方式】：双向关联的关系用一条直线连接两个类，并在两头标注数量对应关系（1:n或者n：n）；单向关联关系用一个普通的箭头连接两个类，箭头指向被拥有者。<br>【备注】：这种普通的关联关系感觉在 iOS 中用的比较少，基本都是用下面三种更为特殊的关联关系，聚合，组合，依赖</p><p><img src="https://upload-images.jianshu.io/upload_images/183487-4e269fd858fe2a89.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/560" alt=""></p><ul><li><h4 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h4></li></ul><p>【定义】：是一种整体与部分的关系，并且部分可以离开整体而单独存在，好比汽车和轮胎是整体和部分的关系，但轮胎离开车任然可以存在。聚合关系是关联关系的一种，是一种强关联关系<br>【描述方式】：带空心菱形的实心线表示，菱形指向整体</p><p><img src="https://upload-images.jianshu.io/upload_images/183487-2aca6310d96d7ebc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/418" alt=""></p><p>【备注】：聚合的方式还可以用来表示 iOS 中某个声明在 VC 或者 view 中的协议(反正不是单独创建一个protocol文件那种)以 MPINewUserCell类来介绍，该类中定义了一个 MPINewUserCellDelegate给外界使用表示方式可以：</p><p><img src="https://upload-images.jianshu.io/upload_images/183487-593a41bc51d996dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/213" alt=""></p><ul><li><h4 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h4></li></ul><p>【定义】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系也是关联关系的一种，是比聚合关系还要强的关联关系。<br>【描述方式】：带实心菱形的实线，菱形指向整体<br><img src="https://upload-images.jianshu.io/upload_images/183487-7113c45c5b39707b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/403" alt=""></p><ul><li><h4 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h4></li></ul><p>【定义】：依赖关系是一种使用关系，即一个类做某件事情需要另一个类的协助，但不是把另一个类作为自己的属性；例如下载素材的 manager 类和下载的素材material之间的关系就是依赖关系，manager仅仅是使用material，并没有把它定义为自己的一个属性<br>【描述方式】：带箭头的虚线指向被使用者</p><p><img src="https://upload-images.jianshu.io/upload_images/183487-5e4d615ae22da4d1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/519" alt=""></p><h2 id="三、UML时序图阅读规则"><a href="#三、UML时序图阅读规则" class="headerlink" title="三、UML时序图阅读规则"></a>三、UML时序图阅读规则</h2><p><a href="https://www.jianshu.com/p/51318fefdcaa" target="_blank" rel="noopener">UML基本使用–时序图</a></p><hr><blockquote><h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong><br><strong>原文地址：<a href="http://lionsom.com/2018/04/10/SDWebImage4-0源码探究（一）UML类图和时序图/" target="_blank" rel="noopener">Mac+Hexo+github搭建myblog完整版</a></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SDWebImage类图和时序图&lt;/li&gt;
&lt;li&gt;UML类图阅读规则&lt;/li&gt;
&lt;li&gt;UML时序图阅读规则&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="框架分析" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    
    
      <category term="SDWebImage" scheme="http://yoursite.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage4.0源码探究（二）框架分析</title>
    <link href="http://yoursite.com/2018/03/22/SDWebImage4-0%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/03/22/SDWebImage4-0源码探究（二）框架分析/</id>
    <published>2018-03-22T06:32:23.000Z</published>
    <updated>2018-04-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>一、SDWebImage UML分析</li><li>二、SDWebImage 中 <strong>@autoreleasepool</strong> 的应用</li><li>三、SDWebImage 支持 <strong>GIF动图</strong> 吗？</li><li>四、SDWebImage 如何 <strong>区分图片格式</strong>？</li><li>五、SDWebImage 缓存图片的名称如何 <strong>避免重名</strong>？</li><li>六、SDWebImage 中 <strong>常量的定义</strong></li><li>七、SDWebImage 如何保证UI操作放在主线程中执行？</li><li>八、SDWebImage 的 <strong>最大并发数</strong> 和 <strong>超时时长</strong></li><li>九、SDWebImage 的Memory缓存和Disk缓存是用什么实现的？</li><li>十、SDWebImage 读取Memory和Disk的时候如何保证 <strong>线程安全</strong>？</li><li>十一、SDWebImage 的 <strong>Memory警告</strong> 是如何处理的！</li><li>十二、SDWebImage Disk缓存时长？ Disk清理操作时间点？ Disk清理原则？</li><li>十三、SDWebImage <strong>Disk目录</strong> 位于哪里？</li><li>十四、SDWebImage 的回调设计？</li><li>十五、SDWebImage 中 <strong>NS_OPTIONS</strong> 与 <strong>NS_ENUM</strong> 的使用</li></ul><a id="more"></a><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul><li><p><a href="https://github.com/rs/SDWebImage/blob/master/Docs/SDWebImage-4.0-Migration-guide.md" target="_blank" rel="noopener">SDWebImage 4.0迁移指南</a></p></li><li><p><a href="https://github.com/rs/SDWebImage/wiki/Common-Problems" target="_blank" rel="noopener">Common Problems</a></p></li><li><p><a href="https://github.com/rs/SDWebImage/wiki" target="_blank" rel="noopener">SDWebImage/wiki</a></p></li><li><p><a href="https://github.com/rs/SDWebImage/blob/master/Docs/HowToUse.md" target="_blank" rel="noopener">HowToUse</a></p></li></ul><h2 id="一、UML图和时序图"><a href="#一、UML图和时序图" class="headerlink" title="一、UML图和时序图"></a>一、UML图和时序图</h2><p><img src="https://github.com/rs/SDWebImage/raw/master/Docs/SDWebImageClassDiagram.png" alt="aa"></p><p><img src="https://github.com/rs/SDWebImage/blob/master/Docs/SDWebImageSequenceDiagram.png?raw=true" alt="BB"></p><hr><h1 id="二、SDWebImage-中-autoreleasepool的应用"><a href="#二、SDWebImage-中-autoreleasepool的应用" class="headerlink" title="二、SDWebImage 中@autoreleasepool的应用"></a>二、SDWebImage 中@autoreleasepool的应用</h1><ul><li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#retain-count-semantics" target="_blank" rel="noopener">Retain count semantics in ARC</a></li><li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#autoreleasepool" target="_blank" rel="noopener">What’s @autoreleasepool</a></li><li><a href="https://www.jianshu.com/p/1b66c4d47cd7" target="_blank" rel="noopener">AutoreleasePool的原理和实现</a></li></ul><p>现考虑如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">    [self doSthWith:object];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和笔试题关键部分大同小异。如果”doSthWith:”方法要创建一个临时对象，那么这个对象很可能会放在自动释放池里。笔试题中最后stringByAppendingString方法很有可能属于上述的方法。因此如果涉及到了自动释放池，那么问题也应该就出在上面。</p><p>注意：即便临时对象在调用完方法后就不再使用了，它们也依然处于存活状态，因为目前它们都在自动释放池里，等待系统稍后进行回收。但自动释放池却要等到该线程执行下一次事件循环时才会清空，这就意味着在执行for循环时，会有持续不断的新的临时对象被创建出来，并加入自动释放池。要等到结束for循环才会释放。在for循环中内存用量会持续上涨，而等到结束循环后，内存用量又会突然下降。</p><p>而如果把循环内的代码包裹在“自动释放池”中，那么在循环中自动释放的对象就会放在这个池，而不是在线程的主池里面。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            NSString *str = @&quot;abc&quot;;</span><br><span class="line">            str = [str lowercaseString];</span><br><span class="line">            str = [str stringByAppendingString:@&quot;xyz&quot;];</span><br><span class="line">        &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增的自动释放池可以减少内存用量，因为系统会在块的末尾把这些对象回收掉。而上述这些临时对象，正在回收之列。</p><p>自动释放池的机制就像“栈”。系统创建好池之后，将其压入栈中，而清空自动释放池相当于将池从栈中弹出。在对象上执行自动释放操作，就等于将其放入位于栈顶的那个池。</p><blockquote><h3 id="结论：-autoreleasepool利于局部变量立刻释放"><a href="#结论：-autoreleasepool利于局部变量立刻释放" class="headerlink" title="结论：@autoreleasepool利于局部变量立刻释放"></a>结论：@autoreleasepool利于局部变量立刻释放</h3></blockquote><hr><h1 id="三、SDWebImage-支持GIF动图吗？"><a href="#三、SDWebImage-支持GIF动图吗？" class="headerlink" title="三、SDWebImage 支持GIF动图吗？"></a>三、SDWebImage 支持GIF动图吗？</h1><h3 id="3-1、SDWebImage-4-0版本之前的UIImage-GIF类别"><a href="#3-1、SDWebImage-4-0版本之前的UIImage-GIF类别" class="headerlink" title="3.1、SDWebImage 4.0版本之前的UIImage+GIF类别"></a>3.1、SDWebImage 4.0版本之前的<code>UIImage+GIF</code>类别</h3><p>在<code>SDWebImage</code>这个库里有一个<code>UIImage+GIF</code>的类别，里面为<code>UIImage</code>扩展了三个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface UIImage (GIF)</span><br><span class="line">+ (IImage *)sd_animatedGIFNamed:(NSString *)name;</span><br><span class="line">+ (UIImage *)sd_animatedGIFWithData:(NSData *)data;</span><br><span class="line">- (UIImage *)sd_animatedImageByScalingAndCroppingToSize:(CGSize)size;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>具体使用 <a href="https://www.jianshu.com/p/f0530a75c7af#comment-12834850" target="_blank" rel="noopener">参考文章</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;gifTest&quot; ofType:@&quot;gif&quot;];</span><br><span class="line">NSData *data = [NSData dataWithContentsOfFile:path];</span><br><span class="line">UIImage *image = [UIImage sd_animatedGIFWithData:data];</span><br><span class="line">gifImageView.image = image;</span><br></pre></td></tr></table></figure></p><h3 id="3-2、SDWebImage-4-0版本之后的UIImage-GIF类别"><a href="#3-2、SDWebImage-4-0版本之后的UIImage-GIF类别" class="headerlink" title="3.2、SDWebImage 4.0版本之后的UIImage+GIF类别"></a>3.2、<strong>SDWebImage 4.0</strong>版本之后的<code>UIImage+GIF</code>类别</h3><p>在<code>SDWebImage</code>这个库里有一个<code>UIImage+GIF</code>的类别，其中的扩展方法只有一个<code>sd_animatedGIFWithData :</code>，<strong>它只返回数据包含的第一帧的图像</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface UIImage (GIF)</span><br><span class="line">/**</span><br><span class="line"> *  Compatibility method - creates an animated UIImage from an NSData, it will only contain the 1st frame image</span><br><span class="line"> */</span><br><span class="line">+ (UIImage *)sd_animatedGIFWithData:(NSData *)data;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Checks if an UIImage instance is a GIF. Will use the `images` array</span><br><span class="line"> */</span><br><span class="line">- (BOOL)isGIF;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>具体使用</p><p><img src="https://upload-images.jianshu.io/upload_images/1859399-b106e48344d3ebef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="只返回一帧的图像"></p><p>结论：SDWebImage 4.0版本之后，<code>sd_animatedGIFWithData :</code>没办法实现gif加载；</p><h3 id="3-3、SDWebImage-4-0版本之后-加载gif新方法"><a href="#3-3、SDWebImage-4-0版本之后-加载gif新方法" class="headerlink" title="3.3、SDWebImage 4.0版本之后 加载gif新方法"></a>3.3、SDWebImage 4.0版本之后 加载gif新方法</h3><p><strong>官方文档：</strong></p><hr><h2 id="Animated-Images-GIF-support"><a href="#Animated-Images-GIF-support" class="headerlink" title="Animated Images (GIF) support"></a>Animated Images (GIF) support</h2><ul><li>Starting with the 4.0 version, we rely on <a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage</a> to take care of our animated images.</li><li>If you use cocoapods, add <code>pod &#39;SDWebImage/GIF&#39;</code> to your podfile.</li><li>To use it, simply make sure you use <code>FLAnimatedImageView</code> instead of <code>UIImageView</code>.</li><li><strong>Note</strong>: there is a backwards compatible feature, so if you are still trying to load a GIF into a <code>UIImageView</code>, it will only show the 1st frame as a static image by default. However, you can enable the full GIF support by using the built-in GIF coder. See <a href="https://github.com/rs/SDWebImage/wiki/Advanced-Usage#gif-coder" target="_blank" rel="noopener">GIF coder</a></li><li><strong>Important</strong>: FLAnimatedImage only works on the iOS platform. For macOS, use <code>NSImageView</code> with <code>animates</code> set to <code>YES</code> to show the entire animated images and <code>NO</code> to only show the 1st frame. For all the other platforms (tvOS, watchOS) we will fallback to the backwards compatibility feature described above</li></ul><hr><p><strong>结论：</strong></p><ul><li>4.0版本之后，SD依赖 <a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage</a>进行了gif的加载，</li><li>需要我们单独导入<code>pod &#39;SDWebImage/GIF&#39;</code>，</li><li>并且需要使用<code>FLAnimatedImageView</code> 代替 <code>UIImageView</code></li><li>注意事项：这里所说的就是版本兼容的问题，也就是我们之前讨论的<code>sd_animatedGIFWithData :</code>方法没办法实现gif加载了。但是，您可以使用内置的GIF编码器来启用完整的GIF支持。具体查看 <a href="https://github.com/rs/SDWebImage/wiki/Advanced-Usage#gif-coder" target="_blank" rel="noopener">GIF coder</a></li><li>重要事项：<ul><li><code>FLAnimatedImage</code>暂时仅支持iOS平台；</li><li>macOS平台使用<code>NSImageView</code>与<code>animates</code>设置为YES以显示整个动画图像，而不只是显示第1帧。</li><li>其他平台(tvOS, watchOS)，我们将退回到上面描述的向后兼容性特性。可以使用老版本的方法。</li></ul></li></ul><hr><h1 id="四、SDWebImage-如何区分图片格式？"><a href="#四、SDWebImage-如何区分图片格式？" class="headerlink" title="四、SDWebImage 如何区分图片格式？"></a>四、SDWebImage 如何区分图片格式？</h1><ul><li>PNG：压缩比没有JPG高，但是无损压缩，解压缩性能高，苹果推荐的图像格式！</li><li>JPG：压缩比最高的一种图片格式，有损压缩！最多使用的场景，照相机！解压缩的性能不好！</li><li>GIF：序列桢动图，特点：只支持256种颜色！最流行的时候在1998～1999，有专利的！</li></ul><p>在分类”NSData+ImageContentType.h”中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDImageFormat) &#123;</span><br><span class="line">    SDImageFormatUndefined = -1,</span><br><span class="line">    SDImageFormatJPEG = 0,</span><br><span class="line">    SDImageFormatPNG,</span><br><span class="line">    SDImageFormatGIF,</span><br><span class="line">    SDImageFormatTIFF,</span><br><span class="line">    SDImageFormatWebP</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Return image format</span><br><span class="line"> *</span><br><span class="line"> *  @param data the input image data</span><br><span class="line"> *</span><br><span class="line"> *  @return the image format as `SDImageFormat` (enum)</span><br><span class="line"> */</span><br><span class="line">+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data &#123;</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return SDImageFormatUndefined;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    uint8_t c;</span><br><span class="line">    [data getBytes:&amp;c length:1];</span><br><span class="line">    switch (c) &#123;</span><br><span class="line">        case 0xFF:</span><br><span class="line">            return SDImageFormatJPEG;</span><br><span class="line">        case 0x89:</span><br><span class="line">            return SDImageFormatPNG;</span><br><span class="line">        case 0x47:</span><br><span class="line">            return SDImageFormatGIF;</span><br><span class="line">        case 0x49:</span><br><span class="line">        case 0x4D:</span><br><span class="line">            return SDImageFormatTIFF;</span><br><span class="line">        case 0x52:</span><br><span class="line">            // R as RIFF for WEBP</span><br><span class="line">            if (data.length &lt; 12) &#123;</span><br><span class="line">                return SDImageFormatUndefined;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</span><br><span class="line">            if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123;</span><br><span class="line">                return SDImageFormatWebP;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return SDImageFormatUndefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="实现思想：将数据data转为十六进制数据，取第一个字节数据进行判断。"><a href="#实现思想：将数据data转为十六进制数据，取第一个字节数据进行判断。" class="headerlink" title="实现思想：将数据data转为十六进制数据，取第一个字节数据进行判断。"></a>实现思想：将数据data转为十六进制数据，取第一个字节数据进行判断。</h3></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1859399-66c9b525aa5c5175.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看图片"></p><hr><h1 id="五、SDWebImage-缓存图片的名称如何避免重名"><a href="#五、SDWebImage-缓存图片的名称如何避免重名" class="headerlink" title="五、SDWebImage 缓存图片的名称如何避免重名"></a>五、SDWebImage 缓存图片的名称如何避免重名</h1><blockquote><h3 id="对『绝对路径』进行MD5"><a href="#对『绝对路径』进行MD5" class="headerlink" title="对『绝对路径』进行MD5"></a>对『绝对路径』进行MD5</h3></blockquote><ul><li>如果单纯使用 文件名保存，重名的几率很高！</li><li>使用 MD5 的散列函数！对完整的 URL 进行 md5，结果是一个 32 个字符长度的字符串！</li></ul><hr><h1 id="六、SDWebImage-中常量的定义"><a href="#六、SDWebImage-中常量的定义" class="headerlink" title="六、SDWebImage 中常量的定义"></a>六、SDWebImage 中常量的定义</h1><blockquote><p>可参考之前的文章<a href="https://www.jianshu.com/p/e65d4c40e116" target="_blank" rel="noopener">宏(define)与常量(const)</a></p></blockquote><ul><li>SD中的<code>FOUNDATION_EXPORT</code>定义与调用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImage-umbrella.h</span><br><span class="line"></span><br><span class="line">#ifdef __OBJC__</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#else</span><br><span class="line">#ifndef FOUNDATION_EXPORT</span><br><span class="line">#if defined(__cplusplus)</span><br><span class="line">#define FOUNDATION_EXPORT extern &quot;C&quot;</span><br><span class="line">#else</span><br><span class="line">#define FOUNDATION_EXPORT extern</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在SDWebImageCompat.h</span><br><span class="line">FOUNDATION_EXPORT NSString *const SDWebImageErrorDomain;</span><br><span class="line"></span><br><span class="line">// 在SDWebImageCompat.m</span><br><span class="line">NSString *const SDWebImageErrorDomain = @&quot;SDWebImageErrorDomain&quot;;</span><br></pre></td></tr></table></figure><ul><li>我常用的<code>UIKIT_EXTERN</code>调用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN NSString * const CHECK_SUM_MQ;</span><br><span class="line"></span><br><span class="line">NSString * const CHECK_SUM_MQ = @&quot;123&quot;;</span><br></pre></td></tr></table></figure><ul><li>系统内部对<code>FOUNDATION_EXPORT</code>和<code>UIKIT_EXTERN</code>的定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在系统内部文件 UIKitDefines.h 中</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">#define UIKIT_EXTERNextern &quot;C&quot; __attribute__((visibility (&quot;default&quot;)))</span><br><span class="line">#else</span><br><span class="line">#define UIKIT_EXTERN        extern __attribute__((visibility (&quot;default&quot;)))</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 系统内部文件 NSObjCRuntime.h 中</span><br><span class="line"></span><br><span class="line">#if defined(__cplusplus)</span><br><span class="line">#define FOUNDATION_EXTERN extern &quot;C&quot;</span><br><span class="line">#else</span><br><span class="line">#define FOUNDATION_EXTERN extern</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_WIN32</span><br><span class="line"></span><br><span class="line">    #if defined(NSBUILDINGFOUNDATION)</span><br><span class="line">        #define FOUNDATION_EXPORT FOUNDATION_EXTERN __declspec(dllexport)</span><br><span class="line">    #else</span><br><span class="line">        #define FOUNDATION_EXPORT FOUNDATION_EXTERN __declspec(dllimport)</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    #define FOUNDATION_IMPORT FOUNDATION_EXTERN __declspec(dllimport)</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">    #define FOUNDATION_EXPORT  FOUNDATION_EXTERN</span><br><span class="line">    #define FOUNDATION_IMPORT FOUNDATION_EXTERN</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ul><li>结论：<ul><li><code>FOUNDATION_EXTERN</code> 在 C 中 是 extern；在C++中是 extern ‘C’ ；其他情况则在win32情况下；</li><li><code>UIKIT_EXTERN</code>简单来说，就是将函数修饰为兼容以往C编译方式的、具有extern属性(文件外可见性)、public修饰的方法或变量库外仍可见的属性；</li></ul></li></ul><hr><h1 id="七、SDWebImage-如何保证UI操作放在主线程中执行？"><a href="#七、SDWebImage-如何保证UI操作放在主线程中执行？" class="headerlink" title="七、SDWebImage 如何保证UI操作放在主线程中执行？"></a>七、SDWebImage 如何保证UI操作放在主线程中执行？</h1><p><a href="https://www.jianshu.com/p/cb3dbeaa8b18" target="_blank" rel="noopener">iOS UI 操作在主线程不一定安全？</a></p><p>在SDWebImage的SDWebImageCompat.h中有这样一个宏定义，用来保证主线程操作，为什么要这样写？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCompat.h 中</span><br><span class="line"></span><br><span class="line">#ifndef dispatch_main_async_safe</span><br><span class="line">#define dispatch_main_async_safe(block)\</span><br><span class="line">    if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>在此之前见到最多的是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define dispatch_main_async_safe(block)\</span><br><span class="line">    if ([NSThread isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对比两段代码可以发现前者有两个地方改变了，一是多了 <code>#ifndef</code>，二是判断条件改变了。</p><p>显然，增加 <code>#ifndef</code> 是为了提高代码的严谨，防止重复定义 <code>dispatch_main_async_safe</code>。</p><p>关于判断条件的改变的原因则是复杂得多了,可参考文档</p><p><a href="http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/" target="_blank" rel="noopener">GCD’s Main Queue vs. Main Thread</a></p><p><a href="http://blog.krzyzanowskim.com/2016/06/03/queues-are-not-bound-to-any-specific-thread/" target="_blank" rel="noopener">Queues are not bound to any specific thread</a></p><h4 id="分析：如何判断当前是否在main-thread？"><a href="#分析：如何判断当前是否在main-thread？" class="headerlink" title="分析：如何判断当前是否在main thread？"></a>分析：如何判断当前是否在main thread？</h4><h5 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h5><p>检查我们当前在主线程上执行的最简单的方法是使用[NSThread isMainThread] - GCD缺少一个类似的方便的API来检查我们是否在主队列上运行，因此许多开发人员使用了NSThread API。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ([NSThread isMainThread]) &#123;</span><br><span class="line">block();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在大多数情况下是有效的，直到它出现了异常。下面是关于ReactiveCocoa repo问题的摘录:<br><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2635#issuecomment-170215083" target="_blank" rel="noopener">ReactiveCocoa issue</a></p><p><img src="http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/rac_issue_queue_thread.png" alt=""></p><p>潜在的问题是VektorKit API正在检查是否在主队列上调用它，而不是检查它在主线程上运行。</p><p>虽然每个应用程序都只有一个主线程，但是在这个主线程上执行许多不同的队列是可能的。</p><p>如果库(如VektorKit)依赖于在主队列上检查执行，那么从主线程上执行的非主队列调用API将导致问题。也就是说，<strong>如果在主线程执行非主队列调度的API，而这个API需要检查是否由主队列上调度，那么将会出现问题。</strong></p><h5 id="更安全的方法一"><a href="#更安全的方法一" class="headerlink" title="更安全的方法一"></a>更安全的方法一</h5><p>从技术上讲，我认为这是一个 <code>MapKit / VektorKit</code> 漏洞，苹果的UI框架通常保证在从主线程调用时正确工作，没有任何文档提到需要在主队列上执行代码。</p><p>但是，现在我们知道某些api不仅依赖于主线程上的运行，而且还依赖于主队列，因此检查当前队列而不是检查当前线程更安全。</p><p>检查当前队列还可以更好地利用GCD为线程提供的抽象。从技术上讲，我们不应该知道/关心主队列是一种总是绑定到主线程的特殊队列。</p><p>不幸的是，GCD没有一个非常方便的API来检查我们当前正在运行的队列(这很可能是许多开发人员首先使用NSThread.isMainThread()的原因)。</p><p>我们需要使用 <code>dispatch_queue_set_specific</code> 函数来将键值对与主队列相关联;稍后，我们可以使用 <code>dispatch_queue_get_specific</code> 来检查键和值的存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)function &#123;</span><br><span class="line">    static void *mainQueueKey = &quot;mainQueueKey&quot;;</span><br><span class="line">    dispatch_queue_set_specific(dispatch_get_main_queue(), mainQueueKey, &amp;mainQueueKey, NULL);</span><br><span class="line">    if (dispatch_get_specific(mainQueueKey)) &#123;</span><br><span class="line">        // do something in main queue</span><br><span class="line">        //通过这样判断，就可以真正保证(我们在不主动搞事的情况下)，任务一定是放在主队列中的</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // do something in other queue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="更安全的方法二-SDWebImage使用的方法"><a href="#更安全的方法二-SDWebImage使用的方法" class="headerlink" title="更安全的方法二 (SDWebImage使用的方法)"></a>更安全的方法二 (SDWebImage使用的方法)</h5><p>我们知道在使用 GCD 创建一个 queue 的时候会指定 queue_label，可以理解为队列名，就像下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.apple.threadQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure><p>而第一个参数就是 queue_label，根据官方文档解释，这个queueLabel 是唯一的，所以SDWebImage就采用了这个方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//取得当前队列的队列名</span><br><span class="line">dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)</span><br><span class="line">   </span><br><span class="line">//取得主队列的队列名</span><br><span class="line">dispatch_queue_get_label(dispatch_get_main_queue())</span><br><span class="line"></span><br><span class="line">然后通过 strcmp 函数进行比较，如果为0 则证明当前队列就是主队列。</span><br></pre></td></tr></table></figure><p><strong>SDWebImage中的实例 ：判断当前是否是IOQueue</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)checkIfQueueIsIOQueue &#123;</span><br><span class="line">    const char *currentQueueLabel = dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL);</span><br><span class="line">    const char *ioQueueLabel = dispatch_queue_get_label(self.ioQueue);</span><br><span class="line">    if (strcmp(currentQueueLabel, ioQueueLabel) != 0) &#123;</span><br><span class="line">        NSLog(@&quot;This method should be called from the ioQueue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p>SDWebImage 就是从判断是否在<strong>主线程执行改为判断是否由主队列上调度</strong>。而由于主队列是一个串行队列，无论任务是异步同步都不会开辟新线程，所以当前队列是主队列等价于当前在主线程上执行。可以这样说，<strong>在主队列调度的任务肯定在主线程执行，而在主线程执行的任务不一定是由主队列调度的。</strong></p></blockquote><hr><h1 id="八、SDWebImage-的最大并发数-和-超时时长"><a href="#八、SDWebImage-的最大并发数-和-超时时长" class="headerlink" title="八、SDWebImage 的最大并发数 和 超时时长"></a>八、SDWebImage 的最大并发数 和 超时时长</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageDownloader.m   -initWithSessionConfiguration:</span><br><span class="line"></span><br><span class="line">_downloadQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">_downloadTimeout = 15.0;</span><br></pre></td></tr></table></figure><hr><h1 id="九、SDWebImage-的Memory缓存和Disk缓存是用什么实现的？"><a href="#九、SDWebImage-的Memory缓存和Disk缓存是用什么实现的？" class="headerlink" title="九、SDWebImage 的Memory缓存和Disk缓存是用什么实现的？"></a>九、SDWebImage 的Memory缓存和Disk缓存是用什么实现的？</h1><h3 id="9-1、Memory缓存实现-–-AutoPurgeCache"><a href="#9-1、Memory缓存实现-–-AutoPurgeCache" class="headerlink" title="9.1、Memory缓存实现 – AutoPurgeCache"></a>9.1、Memory缓存实现 – <code>AutoPurgeCache</code></h3><blockquote><h3 id="『AutoPurgeCache』类继承自-『NSCache』"><a href="#『AutoPurgeCache』类继承自-『NSCache』" class="headerlink" title="『AutoPurgeCache』类继承自 『NSCache』"></a>『AutoPurgeCache』类继承自 『NSCache』</h3></blockquote><p><code>SDWebImage</code> 还专门实现了一个叫做 <code>AutoPurgeCache</code> 的类 继承自 <code>NSCache</code> ，相比于普通的 <code>NSCache</code>， <strong>它提供了一个在内存紧张时候释放缓存的能力。</strong></p><ul><li>自动删除机制：当系统内存紧张时，<code>NSCache</code> 会自动删除一些缓存对象</li><li>线程安全：从不同线程中对同一个 <code>NSCache</code> 对象进行增删改查时，不需要加锁</li><li>不同于 <code>NSMutableDictionary</code>、<code>NSCache</code>存储对象时不会对 <code>key</code> 进行 <code>copy</code> 操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@interface AutoPurgeCache : NSCache</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AutoPurgeCache</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(removeAllObjects) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="9-2、Disk缓存实现-–-NSFileManager"><a href="#9-2、Disk缓存实现-–-NSFileManager" class="headerlink" title="9.2、Disk缓存实现 – NSFileManager"></a>9.2、Disk缓存实现 – <code>NSFileManager</code></h3><blockquote><p><code>SDImageCache</code> 的磁盘缓存是通过异步操作 <code>NSFileManager</code> 存储缓存文件到沙盒来实现的。</p></blockquote><hr><h1 id="十、读取Memory和Disk的时候如何保证线程安全？"><a href="#十、读取Memory和Disk的时候如何保证线程安全？" class="headerlink" title="十、读取Memory和Disk的时候如何保证线程安全？"></a>十、读取Memory和Disk的时候如何保证线程安全？</h1><h3 id="10-1、读取Memory"><a href="#10-1、读取Memory" class="headerlink" title="10.1、读取Memory"></a>10.1、读取Memory</h3><p><strong><code>NScache</code>是线程安全的，在多线程操作中，不需要对Cache加锁。</strong><br>读取缓存的时候是在主线程进行。由于使用NSCache进行存储、所以不需要担心单个value对象的线程安全。</p><h3 id="10-2、读取Disk"><a href="#10-2、读取Disk" class="headerlink" title="10.2、读取Disk"></a>10.2、读取Disk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property (SDDispatchQueueSetterSementics, nonatomic, nullable) dispatch_queue_t ioQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Create IO serial queue</span><br><span class="line">_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure><ul><li><strong>判断当前是否是IOQueue</strong> <strong><em>(原理：七、SDWebImage 如何保证UI操作放在主线程中执行？)</em></strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)checkIfQueueIsIOQueue &#123;</span><br><span class="line">    const char *currentQueueLabel = dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL);</span><br><span class="line">    const char *ioQueueLabel = dispatch_queue_get_label(self.ioQueue);</span><br><span class="line">    if (strcmp(currentQueueLabel, ioQueueLabel) != 0) &#123;</span><br><span class="line">        NSLog(@&quot;This method should be called from the ioQueue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在主要存储函数中，<strong>dispatch_async(self.ioQueue, ^{})</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SDImageCache.m</span><br><span class="line"></span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    // .........    </span><br><span class="line">    </span><br><span class="line">    if (toDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                NSData *data = imageData;</span><br><span class="line">                if (!data &amp;&amp; image) &#123;</span><br><span class="line">                    SDImageFormat imageFormatFromData = [NSData sd_imageFormatForImageData:data];</span><br><span class="line">                    data = [image sd_imageDataAsFormat:imageFormatFromData];</span><br><span class="line">                &#125;                </span><br><span class="line">                [self storeImageDataToDisk:data forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (completionBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completionBlock();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><ul><li>真正的磁盘缓存是在另一个IO专属线程中的一个串行队列下进行的。</li><li>如果你搜索self.ioQueue还能发现、不只是读取磁盘内容。</li><li>包括删除、写入等所有磁盘内容都是在这个IO线程进行、以保证线程安全。</li><li>但计算大小、获取文件总数等操作。则是在主线程进行。（<strong>看下面代码</strong>）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SDImageCache.m</span><br><span class="line"></span><br><span class="line">- (NSUInteger)getSize &#123;</span><br><span class="line">    __block NSUInteger size = 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        for (NSString *fileName in fileEnumerator) &#123;</span><br><span class="line">            NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">            size += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：我们可以看见，不会创建新线程且切操作会顺序执行。你可能会疑惑：为什么同样都是在主线程执行，这样没有死锁。其实这个和线程没有关系，和队列有关系，只要不放在主队列就不会阻塞主队列上的操作(各种系统的UI方法)，这个操作只是选择了合适的时机在主线程上跑了一下而已~</p><hr><h1 id="十一、SDWebImage-的Memory警告是如何处理的！"><a href="#十一、SDWebImage-的Memory警告是如何处理的！" class="headerlink" title="十一、SDWebImage 的Memory警告是如何处理的！"></a>十一、SDWebImage 的Memory警告是如何处理的！</h1><blockquote><h3 id="利用通知中心观察"><a href="#利用通知中心观察" class="headerlink" title="利用通知中心观察"></a>利用通知中心观察</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(clearMemory)</span><br><span class="line">                                             name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                           object:nil];</span><br></pre></td></tr></table></figure><ul><li>UIApplicationDidReceiveMemoryWarningNotification 接收到内存警告的通知<ul><li>执行 clearMemory 方法，清理内存缓存！</li></ul></li></ul><hr><h1 id="十二、SDWebImage-Disk缓存时长？-Disk清理操作时间点？-Disk清理原则？"><a href="#十二、SDWebImage-Disk缓存时长？-Disk清理操作时间点？-Disk清理原则？" class="headerlink" title="十二、SDWebImage Disk缓存时长？ Disk清理操作时间点？ Disk清理原则？"></a>十二、SDWebImage Disk缓存时长？ Disk清理操作时间点？ Disk清理原则？</h1><h4 id="12-1、默认为一周"><a href="#12-1、默认为一周" class="headerlink" title="12.1、默认为一周"></a>12.1、默认为一周</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// SDImageCacheConfig.m</span><br><span class="line"></span><br><span class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</span><br></pre></td></tr></table></figure><h4 id="12-2、磁盘清理时间点"><a href="#12-2、磁盘清理时间点" class="headerlink" title="12.2、磁盘清理时间点"></a>12.2、磁盘清理时间点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(deleteOldFiles)</span><br><span class="line">                                             name:UIApplicationWillTerminateNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line"></span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(backgroundDeleteOldFiles)</span><br><span class="line">                                             name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                           object:nil];</span><br></pre></td></tr></table></figure><blockquote><p><strong>分别在『应用被杀死时』和 『应用进入后台时』进行清理操作</strong></p></blockquote><p>清理磁盘的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br></pre></td></tr></table></figure><p>当应用进入后台时，会涉及到『<strong>Long-Running Task</strong>』<br>正常程序在进入后台后、虽然可以继续执行任务。但是在时间很短内就会被挂起待机。<br>Long-Running可以让系统为app再多分配一些时间来处理一些耗时任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)backgroundDeleteOldFiles &#123;</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">// 后台任务标识--注册一个后台任务</span><br><span class="line">    __block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        // Clean up any unfinished task business by marking where you</span><br><span class="line">        // stopped or ending the task outright.</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // Start the long-running task and return immediately.</span><br><span class="line">    [self deleteOldFilesWithCompletionBlock:^&#123;</span><br><span class="line">//结束后台任务</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-3、磁盘清理原则"><a href="#12-3、磁盘清理原则" class="headerlink" title="12.3、磁盘清理原则"></a>12.3、磁盘清理原则</h4><p>清理缓存的规则分两步进行。 第一步先清除掉过期的缓存文件。 如果清除掉过期的缓存之后，空间还不够。 那么就继续按文件时间从早到晚排序，先清除最早的缓存文件，直到剩余空间达到要求。</p><p>具体点，SDWebImage 是怎么控制哪些缓存过期，以及剩余空间多少才够呢？ 通过两个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface SDImageCacheConfig : NSObject</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The maximum length of time to keep an image in the cache, in seconds</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSInteger maxCacheAge;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The maximum size of the cache, in bytes.</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxCacheSize;</span><br></pre></td></tr></table></figure><p><strong>maxCacheAge 和 maxCacheSize 有默认值吗？</strong></p><ul><li><code>maxCacheAge</code> 在上述已经说过了，是有默认值的 <strong>1week</strong>，单位秒。</li><li><code>maxCacheSize</code> 翻了一遍 SDWebImage 的代码，并没有对 maxCacheSize 设置默认值。 这就意味着 SDWebImage 在默认情况下不会对缓存空间设限制。可以这样设置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SDImageCache sharedImageCache].maxCacheSize = 1024 * 1024 * 50;// 50M</span><br></pre></td></tr></table></figure></li></ul><p>maxCacheSize 是以字节来表示的，我们上面的计算代表 50M 的最大缓存空间。 把这行代码写在你的 APP 启动的时候，这样 SDWebImage 在清理缓存的时候，就会清理多余的缓存文件了。</p><h1 id="十三、SDWebImage-Disk目录位于哪里？"><a href="#十三、SDWebImage-Disk目录位于哪里？" class="headerlink" title="十三、SDWebImage Disk目录位于哪里？"></a>十三、SDWebImage Disk目录位于哪里？</h1><ul><li>缓存在沙盒目录下 <code>Library/Caches</code></li><li>默认情况下，二级目录为 <code>~/Library/Caches/default/com.hackemist.SDWebImageCache.default</code></li><li>也可自定义文件名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithNamespace:@&quot;default&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns &#123;</span><br><span class="line">    NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">    return [self initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line">   </span><br><span class="line">   // .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何打开-真机和模拟器-沙盒文件"><a href="#如何打开-真机和模拟器-沙盒文件" class="headerlink" title="如何打开 真机和模拟器 沙盒文件"></a>如何打开 真机和模拟器 沙盒文件</h4><ul><li><strong>模拟器</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) objectAtIndex:0];</span><br></pre></td></tr></table></figure><blockquote><p>通过 Finder -&gt; 前往 -&gt; 前往文件夹 -&gt; 将路径输入即可！</p></blockquote><ul><li><strong>真机</strong> </li></ul><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_SDWebImage_001.jpg" alt=""></p><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_SDWebImage_002.jpg" alt=""></p><blockquote><p>通过 查看包内容 查看即可！</p></blockquote><h1 id="十四、SDWebImage-的回调设计？"><a href="#十四、SDWebImage-的回调设计？" class="headerlink" title="十四、SDWebImage 的回调设计？"></a>十四、SDWebImage 的回调设计？</h1><ul><li>Block<br>单个图片的分类、单个图片的下载。<br>每个操作任务中必现的progress以及completed。<br>所以、有很强的个体绑定需要或者使用次数不多时、倾向使用block</li><li>Delegate<br>SDWebImageManager下载完成之后的自定义图片处理、是否下载某个url。<br>这两个方法如果需要的话都是将会调用多次的。所以、用Delegate更好、可以将方法常驻。</li><li>同理<br>UITableView的使用Delegate、是用为在滚动途中、代理方法需要被不断的执行。<br>UIButton也是将会被多次点击。<br>UIView的动画/GCD则可以使用Block、因为只执行一次、用完释放。<br>所以、在日常使用中、我们也可以参考上述原则进行设计。</li></ul><h1 id="十五、SDWebImage-中-NS-OPTIONS-与-NS-ENUM-的使用"><a href="#十五、SDWebImage-中-NS-OPTIONS-与-NS-ENUM-的使用" class="headerlink" title="十五、SDWebImage 中 NS_OPTIONS 与 NS_ENUM 的使用"></a>十五、SDWebImage 中 <strong>NS_OPTIONS</strong> 与 <strong>NS_ENUM</strong> 的使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/// SDWebImageManager.h      Line 14</span><br><span class="line"></span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line">    SDWebImageRetryFailed = 1 &lt;&lt; 0,                    // 值为2的0次方</span><br><span class="line">    SDWebImageLowPriority = 1 &lt;&lt; 1,                    // 值为2的1次方</span><br><span class="line">    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,                // 值为2的2次方</span><br><span class="line">    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,            // 值为2的3次方</span><br><span class="line">    SDWebImageRefreshCached = 1 &lt;&lt; 4,                  // 值为2的4次方</span><br><span class="line">    SDWebImageContinueInBackground = 1 &lt;&lt; 5,           // 值为2的5次方</span><br><span class="line">    SDWebImageHandleCookies = 1 &lt;&lt; 6,                  // 值为2的6次方</span><br><span class="line">    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,    // 值为2的7次方</span><br><span class="line">    SDWebImageHighPriority = 1 &lt;&lt; 8,</span><br><span class="line">    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</span><br><span class="line">    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</span><br><span class="line">    SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</span><br><span class="line">    SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/// SDImageCache.h     Line 13</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    SDImageCacheTypeNone,             // 默认从0开始</span><br><span class="line">    SDImageCacheTypeDisk,             // 值为1</span><br><span class="line">    SDImageCacheTypeMemory            // 值为2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>NS_ENUM 定义 <strong>通用枚举</strong><br>NS_OPTIONS 定义 <strong>位移枚举</strong></p></blockquote><p>位移枚举即是在你需要的地方可以同时存在多个枚举值如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[gifImageView sd_setImageWithURL:url placeholderImage:image options:SDWebImageRefreshCached | SDWebImageRetryFailed progress:^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123;</span><br><span class="line"> </span><br><span class="line">            &#125;];</span><br></pre></td></tr></table></figure><p>而NS_ENUM定义的枚举不能几个枚举项同时存在，只能选择其中一项，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// SDImageCache.m      Line 407</span><br><span class="line"></span><br><span class="line">doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</span><br></pre></td></tr></table></figure><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// SDWebImageManager.m    Line 157</span><br><span class="line"></span><br><span class="line">SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">若 options = SDWebImageLowPriority | SDWebImageCacheMemoryOnly | SDWebImageProgressiveDownload </span><br><span class="line"></span><br><span class="line">| 运算规则：只要两个对应的二进制位有一个为1，结果位就为1，否则为0；</span><br><span class="line">&amp; 运算规则：只有两个对应的二进制位都为1时，结果位才为1，否则为0；</span><br><span class="line"></span><br><span class="line">转换为二进制</span><br><span class="line">options = 0001 | 0010 | 0100</span><br><span class="line">SDWebImageLowPriority = 0001</span><br><span class="line"></span><br><span class="line">options = 0111</span><br><span class="line">SDWebImageLowPriority = 0001</span><br><span class="line"></span><br><span class="line">if (options &amp; SDWebImageLowPriority)</span><br><span class="line">=== if(0111 &amp; 0001)</span><br><span class="line">=== if(0001)</span><br><span class="line">=== if(2)</span><br><span class="line"></span><br><span class="line">如果SDWebImageLowPriority = 1000</span><br><span class="line">if (options &amp; SDWebImageLowPriority)</span><br><span class="line">=== if(0111 &amp; 1000)</span><br><span class="line">=== if(0000)</span><br><span class="line">=== if(0)</span><br></pre></td></tr></table></figure><hr><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="http://swiftcafe.io/2017/02/19/sdimage-cache/" target="_blank" rel="noopener">天天都在用的 SDWebImage， 你了解它的缓存策略吗？</a></li><li><a href="https://www.jianshu.com/p/06f0265c22eb#" target="_blank" rel="noopener">[iOS 开发] SDWebImage 源码阅读笔记</a></li><li><a href="https://www.jianshu.com/p/3b8a7ae966d3" target="_blank" rel="noopener">iOS源码补完计划–SDWebImage4.0+源码参阅(附面试题/流程图)</a></li></ul><hr><blockquote><h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong><br><strong>原文地址：<a href="http://lionsom.com/2018/03/22/SDWebImage4-0源码探究（二）框架分析/" target="_blank" rel="noopener">SDWebImage4-0源码探究（二）框架分析</a></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一、SDWebImage UML分析&lt;/li&gt;
&lt;li&gt;二、SDWebImage 中 &lt;strong&gt;@autoreleasepool&lt;/strong&gt; 的应用&lt;/li&gt;
&lt;li&gt;三、SDWebImage 支持 &lt;strong&gt;GIF动图&lt;/strong&gt; 吗？&lt;/li&gt;
&lt;li&gt;四、SDWebImage 如何 &lt;strong&gt;区分图片格式&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;五、SDWebImage 缓存图片的名称如何 &lt;strong&gt;避免重名&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;六、SDWebImage 中 &lt;strong&gt;常量的定义&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;七、SDWebImage 如何保证UI操作放在主线程中执行？&lt;/li&gt;
&lt;li&gt;八、SDWebImage 的 &lt;strong&gt;最大并发数&lt;/strong&gt; 和 &lt;strong&gt;超时时长&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;九、SDWebImage 的Memory缓存和Disk缓存是用什么实现的？&lt;/li&gt;
&lt;li&gt;十、SDWebImage 读取Memory和Disk的时候如何保证 &lt;strong&gt;线程安全&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;十一、SDWebImage 的 &lt;strong&gt;Memory警告&lt;/strong&gt; 是如何处理的！&lt;/li&gt;
&lt;li&gt;十二、SDWebImage Disk缓存时长？ Disk清理操作时间点？ Disk清理原则？&lt;/li&gt;
&lt;li&gt;十三、SDWebImage &lt;strong&gt;Disk目录&lt;/strong&gt; 位于哪里？&lt;/li&gt;
&lt;li&gt;十四、SDWebImage 的回调设计？&lt;/li&gt;
&lt;li&gt;十五、SDWebImage 中 &lt;strong&gt;NS_OPTIONS&lt;/strong&gt; 与 &lt;strong&gt;NS_ENUM&lt;/strong&gt; 的使用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="框架分析" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    
    
      <category term="SDWebImage" scheme="http://yoursite.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>Mac安装CocoaPods详解</title>
    <link href="http://yoursite.com/2018/03/21/Mac%E5%AE%89%E8%A3%85CocoaPods%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/21/Mac安装CocoaPods详解/</id>
    <published>2018-03-21T03:57:04.000Z</published>
    <updated>2018-03-22T07:23:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>Ruby环境的安装<ul><li>安装系统需要的包</li><li>Homebrew安装</li><li>安装RVM</li><li>使用RVM安装Ruby环境</li><li>设置 Ruby 版本</li><li>替换Ruby源为taobao.org    </li></ul></li><li>安装CocoaPods<ul><li>CocoaPods是什么？</li><li>直接安装CocoaPods</li><li>更新repos文件</li></ul></li><li>CocoaPods使用原理</li><li>后期使用出现的问题<ul><li>问题一：”setting up cocoapods master repo”卡着不动</li><li>问题二：<code>pod search</code>异常</li></ul></li></ul><a id="more"></a><h2 id="一、Ruby环境的安装"><a href="#一、Ruby环境的安装" class="headerlink" title="一、Ruby环境的安装"></a>一、Ruby环境的安装</h2><h3 id="1-1、安装系统需要的包"><a href="#1-1、安装系统需要的包" class="headerlink" title="1.1、安装系统需要的包"></a>1.1、安装系统需要的包</h3><blockquote><p>先安装 <a href="http://developer.apple.com/xcode/" target="_blank" rel="noopener">Xcode</a> 开发工具，它将帮你安装好 Unix 环境需要的开发包</p></blockquote><h3 id="1-2、Homebrew安装"><a href="#1-2、Homebrew安装" class="headerlink" title="1.2、Homebrew安装"></a>1.2、Homebrew安装</h3><h4 id="1-2-1、Homebrew是神马"><a href="#1-2-1、Homebrew是神马" class="headerlink" title="1.2.1、Homebrew是神马"></a>1.2.1、Homebrew是神马</h4><blockquote><p>linux系统有个让人蛋疼的通病，软件包依赖，好在当前主流的两大发行版本都自带了解决方案，Red hat有yum，Ubuntu有apt-get神马，你用mac os，不好意Mac os木有类似的东东，泪奔中几经折腾总算找到了第三方支持：Homebrew，Homebrew简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，可以说Homebrew就是mac下的apt-get、yum神器</p></blockquote><h4 id="1-2-2、是否已安装Homebrew"><a href="#1-2-2、是否已安装Homebrew" class="headerlink" title="1.2.2、是否已安装Homebrew"></a>1.2.2、是否已安装Homebrew</h4><ul><li><strong>brew search rabbitmq</strong>，能搜索到则证明已安装。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LionsomMBP:~ lionsom$ brew search rabbitmq</span><br><span class="line">==&gt; Searching local taps...</span><br><span class="line">rabbitmq                                 rabbitmq-c</span><br><span class="line">==&gt; Searching taps on GitHub...</span><br><span class="line">caskroom/cask/rabbitmq-app</span><br><span class="line">==&gt; Searching blacklisted, migrated and deleted formulae...</span><br></pre></td></tr></table></figure><h4 id="1-2-3、安装Homebrew"><a href="#1-2-3、安装Homebrew" class="headerlink" title="1.2.3、安装Homebrew"></a>1.2.3、安装Homebrew</h4><p>安装 Homebrew<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p><p>将以上命令粘贴至终端。</p><h4 id="1-2-4、更多详情，请前往Homebrew官网查看"><a href="#1-2-4、更多详情，请前往Homebrew官网查看" class="headerlink" title="1.2.4、更多详情，请前往Homebrew官网查看"></a>1.2.4、更多详情，请前往<a href="https://brew.sh" target="_blank" rel="noopener">Homebrew官网</a>查看</h4><h3 id="1-3、安装RVM"><a href="#1-3、安装RVM" class="headerlink" title="1.3、安装RVM"></a>1.3、安装RVM</h3><h4 id="1-3-1、RVM是什么？"><a href="#1-3-1、RVM是什么？" class="headerlink" title="1.3.1、RVM是什么？"></a>1.3.1、RVM是什么？</h4><blockquote><p>Ruby Version Manager简称RVM,是一款非常好用的ruby版本管理以及安装工具。</p></blockquote><h4 id="1-3-2、具体安装步骤"><a href="#1-3-2、具体安装步骤" class="headerlink" title="1.3.2、具体安装步骤"></a>1.3.2、具体安装步骤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure><p>期间可能会问你sudo管理员密码，以及自动通过homebrew安装依赖包，等待一段时间后就可以成功安装好 RVM。</p><p>然后，载入 RVM 环境（新开 Termal 就不用这么做了，会自动重新载入的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.rvm/scripts/rvm</span><br></pre></td></tr></table></figure><p>检查一下是否安装正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rvm -v</span><br><span class="line"></span><br><span class="line">rvm 1.29.3 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]</span><br></pre></td></tr></table></figure><h3 id="1-4、使用RVM安装Ruby环境"><a href="#1-4、使用RVM安装Ruby环境" class="headerlink" title="1.4、使用RVM安装Ruby环境"></a>1.4、使用RVM安装Ruby环境</h3><p>列出已知的ruby版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm list known</span><br></pre></td></tr></table></figure><p>可以选择现有的rvm版本来进行安装（下面以rvm 2.4版本的安装为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm install 2.4</span><br></pre></td></tr></table></figure><p>同样继续等待漫长的下载，编译过程，完成以后，Ruby, Ruby Gems 就安装好了。</p><p><strong>如果Honebrew没有安装，则在此过程中会进行自动安装。</strong></p><ul><li><p>查看是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br></pre></td></tr></table></figure></li><li><p>查询已经安装的ruby</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm list</span><br></pre></td></tr></table></figure></li><li><p>卸载一个已安装版本 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm remove 1.9.2</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5、设置-Ruby-版本"><a href="#1-5、设置-Ruby-版本" class="headerlink" title="1.5、设置 Ruby 版本"></a>1.5、设置 Ruby 版本</h3><p>RVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm 2.4.1 --default</span><br></pre></td></tr></table></figure><p>同样，也可以用其他版本号，前提是你有用 rvm install 安装过那个版本</p><p>这个时候你可以测试是否正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br><span class="line"></span><br><span class="line">ruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-darwin17]</span><br></pre></td></tr></table></figure><h3 id="1-6、替换Ruby源为taobao-org"><a href="#1-6、替换Ruby源为taobao-org" class="headerlink" title="1.6、替换Ruby源为taobao.org"></a>1.6、替换Ruby源为taobao.org</h3><blockquote><p>因为Ruby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，一种解决方案是将远替换成淘宝的，替换方式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem source -r https://rubygems.org/</span><br><span class="line">$ gem source -a https://ruby.taobao.org</span><br></pre></td></tr></table></figure><p>要想验证是否替换成功了，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure><p>正常的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://ruby.taobao.org</span><br></pre></td></tr></table></figure><p>到这里就已经把Ruby环境成功的安装到了Mac OS X上，接下来就可以进行相应的开发使用了。</p><h2 id="2、安装CocoaPods"><a href="#2、安装CocoaPods" class="headerlink" title="2、安装CocoaPods"></a>2、安装CocoaPods</h2><h3 id="2-1、CocoaPods是什么？"><a href="#2-1、CocoaPods是什么？" class="headerlink" title="2.1、CocoaPods是什么？"></a>2.1、CocoaPods是什么？</h3><blockquote><p>当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。总之小编的意思就是，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。如果能有什么工具能解决这些恼人的问题，那将“善莫大焉”。所以，你需要 CocoaPods。</p><p>CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。所以，作为iOS程序员的我们，掌握CocoaPods的使用是必不可少的基本技能了。</p></blockquote><h3 id="2-2、直接安装CocoaPods"><a href="#2-2、直接安装CocoaPods" class="headerlink" title="2.2、直接安装CocoaPods"></a>2.2、直接安装CocoaPods</h3><p>直接在终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>等待一小段时间，安装完成！！</p><p>验证是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod --version</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod search AFNetworking</span><br></pre></td></tr></table></figure><h3 id="2-3、在使用Pod进行操作之前最好手动更新repos文件"><a href="#2-3、在使用Pod进行操作之前最好手动更新repos文件" class="headerlink" title="2.3、在使用Pod进行操作之前最好手动更新repos文件"></a>2.3、在使用Pod进行操作之前最好手动更新repos文件</h3><blockquote><p>为什么最好手动导入呢？</p><p>如果不手动导入也没有问题，再使用<code>pod search AFNetworking</code>的时候pod会自动进行<code>setting up cocoapods master repo</code>的更新，由于文件过大，需要下载好一会儿。所以此时使用手动添加<code>repos</code>的文件比较方便。</p></blockquote><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_SetupPods_001.jpg" alt="setting up cocoapods master repo"></p><h4 id="2-3-1、如何前往-cocoapods文件"><a href="#2-3-1、如何前往-cocoapods文件" class="headerlink" title="2.3.1、如何前往.cocoapods文件"></a>2.3.1、如何前往<code>.cocoapods</code>文件</h4><ul><li>显示隐藏文件<code>Command + shift + .</code></li><li>也可在<code>Finder-&gt;前往-&gt;前往文件夹-&gt;./.cocoapods</code></li></ul><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_SetupPods_002.jpg" alt="前往./.cocoapods"></p><ul><li>具体路径如下</li></ul><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_SetupPods_003.jpg" alt="路径图"></p><h2 id="3、CocoaPods使用原理"><a href="#3、CocoaPods使用原理" class="headerlink" title="3、CocoaPods使用原理"></a>3、CocoaPods使用原理</h2><p><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_SetupPods_004.jpg" alt="流程图"></p><ul><li>pod setup<ul><li>将<strong>远程索引库</strong>下载到本地</li><li><strong>本地索引库</strong>路径（查看2.3.1）</li><li>同时生成<strong>检索文件（Key-Value格式，便于检索）</strong></li></ul></li><li>pod search AFN<ul><li>前往<strong>检索文件</strong>检索 </li><li>然后根据检索到的Value找到<strong>本地索引库</strong>中<code>.spec</code>查看框架的具体信息</li></ul></li><li>pod install<ul><li>得到AFN框架远程地址下载到我们项目中</li></ul></li></ul><h2 id="4、后期使用出现的问题"><a href="#4、后期使用出现的问题" class="headerlink" title="4、后期使用出现的问题"></a>4、后期使用出现的问题</h2><h3 id="4-1、问题一：”setting-up-cocoapods-master-repo”卡着不动"><a href="#4-1、问题一：”setting-up-cocoapods-master-repo”卡着不动" class="headerlink" title="4.1、问题一：”setting up cocoapods master repo”卡着不动"></a>4.1、问题一：”setting up cocoapods master repo”卡着不动</h3><blockquote><p>分析：<br>那个淘宝镜像（<a href="https://ruby.taobao.org）不可用了，所以需要使用最新的ruby镜像（https://gems.ruby-china.org/）" target="_blank" rel="noopener">https://ruby.taobao.org）不可用了，所以需要使用最新的ruby镜像（https://gems.ruby-china.org/）</a></p></blockquote><p><strong>具体操作 可查看1.6章节</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem source -r https://ruby.taobao.org</span><br><span class="line">$ gem source -a https://gems.ruby-china.org/</span><br></pre></td></tr></table></figure><h3 id="4-2、问题二：pod-search异常"><a href="#4-2、问题二：pod-search异常" class="headerlink" title="4.2、问题二：pod search异常"></a>4.2、问题二：<code>pod search</code>异常</h3><p><strong>4.2.1、执行pod setup</strong></p><ul><li>终端输入：<code>pod search AFNetworking</code></li><li>输出：<code>Unable to find a pod with name, author, summary, or descriptionmatching &#39;AFNetworking&#39;</code> 这时就需要继续下面的步骤了。</li></ul><p><strong>4.2.2、删除~/Library/Caches/CocoaPods目录下的search_index.json文件</strong></p><ul><li><code>pod setup</code>成功后，依然不能<code>pod search</code>，是因为之前你执行<code>pod search</code>生成了<code>search_index.json</code>，此时需要删掉。</li><li>终端输入：<code>rm ~/Library/Caches/CocoaPods/search_index.json</code></li><li>删除成功后，再执行<code>pod search</code>。</li></ul><p><strong>4.2.3、执行pod search</strong></p><ul><li>终端输入：<code>pod search afnetworking(不区分大小写)</code></li><li>输出：<code>Creating search index for spec repo &#39;master&#39;.. Done!</code>，稍等片刻······就会出现所有带有afnetworking字段的类库。</li></ul><hr><blockquote><h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong><br><strong>原文地址：<a href="http://lionsom.com/2018/03/21/Mac安装CocoaPods详解/" target="_blank" rel="noopener">Mac安装CocoaPods详解</a></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Ruby环境的安装&lt;ul&gt;
&lt;li&gt;安装系统需要的包&lt;/li&gt;
&lt;li&gt;Homebrew安装&lt;/li&gt;
&lt;li&gt;安装RVM&lt;/li&gt;
&lt;li&gt;使用RVM安装Ruby环境&lt;/li&gt;
&lt;li&gt;设置 Ruby 版本&lt;/li&gt;
&lt;li&gt;替换Ruby源为taobao.org    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安装CocoaPods&lt;ul&gt;
&lt;li&gt;CocoaPods是什么？&lt;/li&gt;
&lt;li&gt;直接安装CocoaPods&lt;/li&gt;
&lt;li&gt;更新repos文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CocoaPods使用原理&lt;/li&gt;
&lt;li&gt;后期使用出现的问题&lt;ul&gt;
&lt;li&gt;问题一：”setting up cocoapods master repo”卡着不动&lt;/li&gt;
&lt;li&gt;问题二：&lt;code&gt;pod search&lt;/code&gt;异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CocoaPods相关" scheme="http://yoursite.com/categories/CocoaPods%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="pods" scheme="http://yoursite.com/tags/pods/"/>
    
  </entry>
  
  <entry>
    <title>避免程序崩溃iOS探索</title>
    <link href="http://yoursite.com/2018/03/20/%E9%81%BF%E5%85%8D%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83iOS%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/03/20/避免程序崩溃iOS探索/</id>
    <published>2018-03-20T04:45:13.000Z</published>
    <updated>2018-04-01T09:05:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>Part ONE - 崩溃发生前之数据<code>&lt;null&gt;</code>处理</li><li>Part Two - 崩溃发生时Runtime避免崩溃</li><li>Part Three - 崩溃发生后Bug收集处理</li></ul><a id="more"></a><hr><h1 id="Part-ONE-崩溃发生前之数据-lt-null-gt-处理"><a href="#Part-ONE-崩溃发生前之数据-lt-null-gt-处理" class="headerlink" title="Part ONE - 崩溃发生前之数据&lt;null&gt;处理"></a>Part ONE - 崩溃发生前之数据<code>&lt;null&gt;</code>处理</h1><hr><h3 id="文件参考："><a href="#文件参考：" class="headerlink" title="文件参考："></a>文件参考：</h3><ul><li><a href="https://my.oschina.net/iq19900204/blog/408034" target="_blank" rel="noopener">ios中json解析出现的null问题</a></li><li><a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">GitHub-NullSafe</a></li></ul><h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p>客户端与服务器之间的数据请求一般以Json形式传递，正常有null值。<br>这个数据类型不是nil 也不是 String。 解析成对象之后，如果直接向这个对象发送消息（eg：length，count 等等）就会直接崩溃。提示错误为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[NSNull length]: unrecognized selector sent to instance 0x388a4a70</span><br></pre></td></tr></table></figure><h2 id="二、实战场景"><a href="#二、实战场景" class="headerlink" title="二、实战场景"></a>二、实战场景</h2><p><img src="http://upload-images.jianshu.io/upload_images/1859399-edc665b555034e8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据为null"></p><p><img src="http://upload-images.jianshu.io/upload_images/1859399-607940347ffad313.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用.length操作"></p><p><img src="http://upload-images.jianshu.io/upload_images/1859399-b2bbcc0a311d32dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="崩溃。。。"></p><h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><h4 id="方案一：解析后进行判断"><a href="#方案一：解析后进行判断" class="headerlink" title="方案一：解析后进行判断"></a>方案一：解析后进行判断</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//方法一</span><br><span class="line">if( [m isEqual:[NSNull null]] )</span><br><span class="line">&#123; </span><br><span class="line">    NSLog(@&quot;&lt;null&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//方法二</span><br><span class="line">if ( ![isKindOfClass:[NSNull class]] )</span><br><span class="line">&#123;</span><br><span class="line">    // 操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案二：AFN"><a href="#方案二：AFN" class="headerlink" title="方案二：AFN"></a>方案二：AFN</h4><p>如果你使用AFNetwork 这个库做网络请求的话，可以用以下代码，自动帮你去掉这个讨厌的空值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removesKeysWithNullValues = YES</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_dataSessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:baseUrl]];</span><br><span class="line">[_dataSessionManager setRequestSerializer:[AFJSONRequestSerializer serializer]];  //告诉AFN使用JSON格式，AFN内部会自动转JSON</span><br><span class="line"></span><br><span class="line">AFJSONResponseSerializer * response = [AFJSONResponseSerializer serializer];</span><br><span class="line">response.removesKeysWithNullValues = YES;</span><br><span class="line">    </span><br><span class="line">[_dataSessionManager setResponseSerializer:response];  //以JSON格式返回</span><br><span class="line">_dataSessionManager.requestSerializer.timeoutInterval = 10;</span><br></pre></td></tr></table></figure><h4 id="方案三：利用Category将nil转为-””"><a href="#方案三：利用Category将nil转为-””" class="headerlink" title="方案三：利用Category将nil转为@””"></a>方案三：利用Category将nil转为@””</h4><p><img src="http://upload-images.jianshu.io/upload_images/1859399-9aef960978c3970c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用案例"></p><p><strong>代码如下 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSDictionary (DeleteNull)</span><br><span class="line"></span><br><span class="line">+(id)changeType:(id)myObj;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  NSDictionary+DeleteNull.m</span><br><span class="line">//  PAL-iOS</span><br><span class="line">//</span><br><span class="line">//  Created by linxiang on 2017/11/1.</span><br><span class="line">//  Copyright © 2017年 minxing. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;NSDictionary+DeleteNull.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation NSDictionary (DeleteNull)</span><br><span class="line"></span><br><span class="line">#pragma mark - 私有方法</span><br><span class="line">//将NSDictionary中的Null类型的项目转化成@&quot;&quot;</span><br><span class="line">+(NSDictionary *)nullDic:(NSDictionary *)myDic</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *keyArr = [myDic allKeys];</span><br><span class="line">    NSMutableDictionary *resDic = [[NSMutableDictionary alloc]init];</span><br><span class="line">    for (int i = 0; i &lt; keyArr.count; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        id obj = [myDic objectForKey:keyArr[i]];</span><br><span class="line">        </span><br><span class="line">        obj = [self changeType:obj];</span><br><span class="line">        </span><br><span class="line">        [resDic setObject:obj forKey:keyArr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return resDic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将NSArray中的Null类型的项目转化成@&quot;&quot;</span><br><span class="line">+(NSArray *)nullArr:(NSArray *)myArr</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *resArr = [[NSMutableArray alloc] init];</span><br><span class="line">    for (int i = 0; i &lt; myArr.count; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        id obj = myArr[i];</span><br><span class="line">        </span><br><span class="line">        obj = [self changeType:obj];</span><br><span class="line">        </span><br><span class="line">        [resArr addObject:obj];</span><br><span class="line">    &#125;</span><br><span class="line">    return resArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将NSString类型的原路返回</span><br><span class="line">+(NSString *)stringToString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将Null类型的项目转化成@&quot;&quot;</span><br><span class="line">+(NSString *)nullToString</span><br><span class="line">&#123;</span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 公有方法</span><br><span class="line">//类型识别:将所有的NSNull类型转化成@&quot;&quot;</span><br><span class="line">+(id)changeType:(id)myObj</span><br><span class="line">&#123;</span><br><span class="line">    if ([myObj isKindOfClass:[NSDictionary class]])</span><br><span class="line">    &#123;</span><br><span class="line">        return [self nullDic:myObj];</span><br><span class="line">    &#125;</span><br><span class="line">    else if([myObj isKindOfClass:[NSArray class]])</span><br><span class="line">    &#123;</span><br><span class="line">        return [self nullArr:myObj];</span><br><span class="line">    &#125;</span><br><span class="line">    else if([myObj isKindOfClass:[NSString class]])</span><br><span class="line">    &#123;</span><br><span class="line">        return [self stringToString:myObj];</span><br><span class="line">    &#125;</span><br><span class="line">    else if([myObj isKindOfClass:[NSNull class]])</span><br><span class="line">    &#123;</span><br><span class="line">        return [self nullToString];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return myObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="方案四：NullSafe"><a href="#方案四：NullSafe" class="headerlink" title="方案四：NullSafe"></a>方案四：NullSafe</h4><h5 id="4-1、NullSafe简介"><a href="#4-1、NullSafe简介" class="headerlink" title="4.1、NullSafe简介"></a>4.1、NullSafe简介</h5><p>NullSafe是一个Category，在运行时操作，把这个讨厌的空值置为nil，而nil是安全的，可以向nil对象发送任何message而不会奔溃。这个category使用起来非常方便，只要加入到了工程中就可以了，你其他的什么都不用做，对，就是这么简单。详细的请去Github上查看：<br><a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">NullSafe</a></p><h5 id="4-2、NullSafe使用"><a href="#4-2、NullSafe使用" class="headerlink" title="4.2、NullSafe使用"></a>4.2、NullSafe使用</h5><p>使用时只需要把 <code>NullSafe.m</code> 文件拖进工程就可以了，它在程序运行时自动加载，你不需要再导入其他头文件了。</p><p>　　如果想要禁止 <code>NullSafe</code> 的话，需要设置：<code>NULLSAFE_ENABLED=0</code>，或者在 <code>.pch 文件</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">#define NULLSAFE_ENABLED 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h5 id="4-3、NullSafe原理"><a href="#4-3、NullSafe原理" class="headerlink" title="4.3、NullSafe原理"></a>4.3、NullSafe原理</h5><p><a href="https://www.2cto.com/kf/201710/690327.html" target="_blank" rel="noopener">iOS开发技巧之NullSafe原理分析</a></p><p>简单点说,当我们给一个<code>NSNull</code>对象发送消息的话，可能会崩溃<code>（null是有内存的）</code>，而发送给<code>nil</code>的话，是不会崩溃的。<br>作者就是使用了这么一个原理，把发送给<code>NSNull</code>的而<code>NSNull</code>又无法处理的消息经过如下几步处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个方法缓存，这个缓存会缓存项目中类的所有类名。</span><br><span class="line">2.遍历缓存，寻找是否已经有可以执行此方法的类。</span><br><span class="line">3.如果有的话，返回这个 NSMethodSignature 。</span><br><span class="line">4.如果没有的话，返回 nil ,接下来会走 forwardInvocation: 方法。</span><br><span class="line">5.[invocation invokeWithTarget:nil]; 将消息转发给 nil。</span><br></pre></td></tr></table></figure><p>那么，如何判断 <code>NSNull</code> 无法处理这个消息呢，在OC中，系统如果对某个实例发送消息之后，它（及其父类）无法处理（比如，没有这个方法等），系统就会发送 <code>methodSignatureForSelector</code> 消息，如果这个方法返回非空，那么就去执行返回的方法，如果为nil,则发送 <code>forwardInvocation</code> 消息。</p><p>这样就完成整个转发链了。</p><hr><h1 id="Part-TWO-崩溃发生时Runtime避免崩溃"><a href="#Part-TWO-崩溃发生时Runtime避免崩溃" class="headerlink" title="Part TWO - 崩溃发生时Runtime避免崩溃"></a>Part TWO - 崩溃发生时Runtime避免崩溃</h1><hr><h2 id="一、AvoidCrash"><a href="#一、AvoidCrash" class="headerlink" title="一、AvoidCrash"></a>一、AvoidCrash</h2><h3 id="1-1、AvoidCrash参考文档"><a href="#1-1、AvoidCrash参考文档" class="headerlink" title="1.1、AvoidCrash参考文档"></a>1.1、AvoidCrash参考文档</h3><p><a href="https://www.jianshu.com/p/5d625f86bd02" target="_blank" rel="noopener">iOS runtime实用篇–和常见崩溃say good-bye！</a><br>—<a href="https://github.com/chenfanfang/AvoidCrash" target="_blank" rel="noopener">AvoidCrash</a></p><h3 id="1-2、AvoidCrash与Bugly、友盟等三方冲突吗？"><a href="#1-2、AvoidCrash与Bugly、友盟等三方冲突吗？" class="headerlink" title="1.2、AvoidCrash与Bugly、友盟等三方冲突吗？"></a>1.2、AvoidCrash与Bugly、友盟等三方冲突吗？</h3><p><a href="https://www.jianshu.com/p/2b90aa96c0a0" target="_blank" rel="noopener">AvoidCrash的集成注意事项、疑惑的解答</a></p><blockquote><p>1、若集成了腾讯Bugly或者友盟等等异常搜集的SDK,AvoidCrash会影响到它们的异常搜集吗？</p></blockquote><p>首先要清楚的一点是，对于一些第三方crash信息搜集工具，比如Bugly或者友盟，它们只有当程序出现异常(崩溃)的时候才会搜集异常信息。而AvoidCrash的作用是，防止部分常见异常的发生，异常被AvoidCrash捕获了，程序就不会崩溃，第三方crash信息搜集工具就不会搜集到崩溃信息咯。</p><blockquote><p>2、如何处理才能既防止崩溃，又搜集到崩溃信息</p></blockquote><p>AvoidCrash若捕获到异常，将会发出一个通知:AvoidCrashNotification,监听该通知即可获取到原本将导致崩溃的具体信息。此时你可以利用Bugly的自定义异常接口将这些异常信息上传到Bugly。</p><h3 id="1-3、AvoidCrash分析"><a href="#1-3、AvoidCrash分析" class="headerlink" title="1.3、AvoidCrash分析"></a>1.3、AvoidCrash分析</h3><h5 id="1-3-1、不添加AvoidCrash情况下"><a href="#1-3-1、不添加AvoidCrash情况下" class="headerlink" title="1.3.1、不添加AvoidCrash情况下"></a>1.3.1、不添加AvoidCrash情况下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *nilStr = nil;</span><br><span class="line">NSArray *array = @[@&quot;lionsom&quot;, nilStr, @&quot;哈哈哈哈&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,array);</span><br></pre></td></tr></table></figure><p><strong>出现崩溃</strong><br><img src="http://p5vr8lvt8.bkt.clouddn.com/myblog_avoidCrash_001.jpg" alt="崩溃"></p><h5 id="1-3-2、添加AvoidCrash后"><a href="#1-3-2、添加AvoidCrash后" class="headerlink" title="1.3.2、添加AvoidCrash后"></a>1.3.2、添加AvoidCrash后</h5><ul><li>先交换初始化NSArray方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//instance array method exchange</span><br><span class="line">[AvoidCrash exchangeClassMethod:[self class]    </span><br><span class="line">                     method1Sel:@selector(arrayWithObjects:count:) </span><br><span class="line">                     method2Sel:@selector(AvoidCrashArrayWithObjects:count:)];</span><br></pre></td></tr></table></figure><ul><li>在我们自定义的<code>AvoidCrashArrayWithObjects:count:</code>方法中进行异常捕捉（此处涉及<code>@Try Catch</code> 和 <code>NSException</code>）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)AvoidCrashArrayWithObjects:(const id  _Nonnull __unsafe_unretained *)objects count:(NSUInteger)cnt &#123;</span><br><span class="line">    </span><br><span class="line">    id instance = nil;</span><br><span class="line">    </span><br><span class="line">    @try &#123;</span><br><span class="line">        instance = [self AvoidCrashArrayWithObjects:objects count:cnt];</span><br><span class="line">    &#125;</span><br><span class="line">    @catch (NSException *exception) &#123;</span><br><span class="line">        </span><br><span class="line">        NSString *defaultToDo = @&quot;AvoidCrash default is to remove nil object and instance a array.&quot;;</span><br><span class="line">        [AvoidCrash noteErrorWithException:exception defaultToDo:defaultToDo];</span><br><span class="line">        </span><br><span class="line">        //以下是对错误数据的处理，把为nil的数据去掉,然后初始化数组</span><br><span class="line">        NSInteger newObjsIndex = 0;</span><br><span class="line">        id  _Nonnull __unsafe_unretained newObjects[cnt];</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">            if (objects[i] != nil) &#123;</span><br><span class="line">                newObjects[newObjsIndex] = objects[i];</span><br><span class="line">                newObjsIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        instance = [self AvoidCrashArrayWithObjects:newObjects count:newObjsIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    @finally &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在自己写的函数中，如果出现异常，先将<strong>异常的具体信息</strong>抛出去，然后将<strong>NSArray中的nil移除得到新的数组</strong>。</p></li><li><p>外部接收到抛出的异常信息，整理。例如：获取具体的崩溃在哪个类的哪个方法中（如下）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//堆栈数据</span><br><span class="line">NSArray *callStackSymbolsArr = [NSThread callStackSymbols];</span><br><span class="line">    </span><br><span class="line">//获取在哪个类的哪个方法中实例化的数组  字符串格式 -[类名 方法名]  或者 +[类名 方法名]</span><br><span class="line">NSString *mainCallStackSymbolMsg = [AvoidCrash getMainCallStackSymbolMessageWithCallStackSymbols:callStackSymbolsArr];</span><br></pre></td></tr></table></figure><ul><li>最后将整理好的崩溃信息使用通知的形式传递出去，给具体的函数进行Bug上传服务器等操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将错误信息放在字典里，用通知的形式发送出去</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:AvoidCrashNotification object:nil userInfo:errorInfoDic];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="二、AvoidCrash常见问题"><a href="#二、AvoidCrash常见问题" class="headerlink" title="二、AvoidCrash常见问题"></a>二、AvoidCrash常见问题</h2><blockquote><p>1、若集成了腾讯Bugly或者友盟等等异常搜集的SDK,AvoidCrash会影响到它们的异常搜集吗？</p></blockquote><blockquote><p>2、为什么集成了AvoidCrash还是会报unrecognized selector sent to instance的异常？</p></blockquote><p><a href="https://www.jianshu.com/p/2b90aa96c0a0" target="_blank" rel="noopener">解惑</a></p><hr><h1 id="Part-Three-崩溃发生后Bug收集处理"><a href="#Part-Three-崩溃发生后Bug收集处理" class="headerlink" title="Part Three - 崩溃发生后Bug收集处理"></a>Part Three - 崩溃发生后Bug收集处理</h1><hr><h2 id="一、后期收集Bugly"><a href="#一、后期收集Bugly" class="headerlink" title="一、后期收集Bugly"></a>一、后期收集Bugly</h2><p><a href="https://bugly.qq.com/v2/" target="_blank" rel="noopener">Bugly官网</a></p><h2 id="二、热修复JSPatch"><a href="#二、热修复JSPatch" class="headerlink" title="二、热修复JSPatch"></a>二、热修复JSPatch</h2><p>搞不懂Apple审核。视情况使用！！</p><hr><blockquote><h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong><br><strong>原文地址：<a href="http://lionsom.com/2018/03/20/避免程序崩溃iOS探索/" target="_blank" rel="noopener">避免程序崩溃iOS探索</a></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Part ONE - 崩溃发生前之数据&lt;code&gt;&amp;lt;null&amp;gt;&lt;/code&gt;处理&lt;/li&gt;
&lt;li&gt;Part Two - 崩溃发生时Runtime避免崩溃&lt;/li&gt;
&lt;li&gt;Part Three - 崩溃发生后Bug收集处理&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS程序崩溃" scheme="http://yoursite.com/categories/iOS%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="崩溃" scheme="http://yoursite.com/tags/%E5%B4%A9%E6%BA%83/"/>
    
  </entry>
  
  <entry>
    <title>Mac+Hexo+github搭建myblog完整版</title>
    <link href="http://yoursite.com/2018/03/16/Hexo-github%E6%90%AD%E5%BB%BAmyblog%E5%AE%8C%E6%95%B4%E7%89%88/"/>
    <id>http://yoursite.com/2018/03/16/Hexo-github搭建myblog完整版/</id>
    <published>2018-03-16T07:34:48.000Z</published>
    <updated>2018-03-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>Part One - Hexo本地搭建运行</li><li>Part Two - github仓库创建和配置</li><li>Part Three - 本地Hexo关联github</li><li>Part Four - 绑定域名并设置域名解析</li><li>Part Five - Hexo日常操作</li><li>Part Six - Hexo主题更换</li><li>Part Seven - 实战中的一些问题</li></ul><a id="more"></a><hr><h1 id="Part-One-Hexo本地搭建运行"><a href="#Part-One-Hexo本地搭建运行" class="headerlink" title="Part One - Hexo本地搭建运行"></a>Part One - Hexo本地搭建运行</h1><hr><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官网</a><br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs官网</a></p><h3 id="1-1、Hexo安装的前提"><a href="#1-1、Hexo安装的前提" class="headerlink" title="1.1、Hexo安装的前提"></a>1.1、Hexo安装的前提</h3><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> 需要先安装 按照流程安装即可！</li><li>npm      与Nodejs一起安装完成，不需要单独安装！</li><li><a href="https://git-scm.com" target="_blank" rel="noopener">Git</a>     Mac系统自带无需安装</li></ul><h3 id="1-2、安装-Hexo"><a href="#1-2、安装-Hexo" class="headerlink" title="1.2、安装 Hexo"></a>1.2、安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><strong>注意：此处可能需要root权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---切换root---</span><br><span class="line">LionsomMBP:~ lionsom$ sudo -i </span><br><span class="line"></span><br><span class="line">---切换lionsom普通用户---</span><br><span class="line">LionsomMBP:~ root# su - lionsom</span><br></pre></td></tr></table></figure><p><img src="/assets/img/Hexo-github搭建myblog完整版/001.jpg" alt="npm install -g hexo-cli"></p><h3 id="1-3、安装Hexo完成，则开始初始化hexo"><a href="#1-3、安装Hexo完成，则开始初始化hexo" class="headerlink" title="1.3、安装Hexo完成，则开始初始化hexo"></a>1.3、安装Hexo完成，则开始初始化hexo</h3><ul><li>创建一个文件夹myblog</li><li>进入myblog</li><li><p>hexo init<br><img src="/assets/img/Hexo-github搭建myblog完整版/002.jpg" alt="hexo init"></p></li><li><p>文件目录结构<br><img src="/assets/img/Hexo-github搭建myblog完整版/myblog目录.jpg" alt="myblog生成点文件目录"></p></li></ul><h3 id="1-4、依赖包与插件的安装"><a href="#1-4、依赖包与插件的安装" class="headerlink" title="1.4、依赖包与插件的安装"></a>1.4、依赖包与插件的安装</h3><ul><li>执行以下命令，进行依赖包的安装，<ul><li>node_modules: 关联保存了将会使用到的hexo依赖包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>![依赖包安装](/assets/img/Hexo-github搭建myblog完整版/依赖包安装.jpg)</code></pre><ul><li><p>安装相关插件</p><ul><li><p><strong>重要：安装便于自动部署到Github上的插件</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>安装atom生成插件，便于感兴趣的小伙伴们订阅</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure></li><li><p>安装博客首页生成插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-index --save</span><br></pre></td></tr></table></figure></li><li><p>安装归档生成插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-archive --save</span><br></pre></td></tr></table></figure></li><li><p>安装tag生成插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-tag --save</span><br></pre></td></tr></table></figure></li><li><p>安装category生成插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-category --save</span><br></pre></td></tr></table></figure></li><li><p>安装Sitemap文件生成插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure></li><li><p>安装百度Sitemap文件生成插件，因为普通的Sitemap格式不符合百度的要求</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-5、本地启动Hexo"><a href="#1-5、本地启动Hexo" class="headerlink" title="1.5、本地启动Hexo"></a>1.5、本地启动Hexo</h3><h4 id="操作指令一览表"><a href="#操作指令一览表" class="headerlink" title="操作指令一览表"></a>操作指令一览表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean      #清理缓存</span><br><span class="line">$ hexo generate   #生成静态文件</span><br><span class="line">$ hexo server  #启动本地服务器</span><br><span class="line">或者</span><br><span class="line">$ hexo clean      #清理缓存</span><br><span class="line">$ hexo g          #生成静态文件</span><br><span class="line">$ hexo s          #启动本地服务器</span><br></pre></td></tr></table></figure><ul><li>前往myblog目录 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;test&quot;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/assets/img/Hexo-github搭建myblog完整版/创建新blog.jpg" alt="创建新blog"></p><ul><li><p>在生成路径下查看<br><img src="/assets/img/Hexo-github搭建myblog完整版/新blog路径.jpg" alt="路径"></p></li><li><p>Hexo本地生成</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>  <img src="/assets/img/Hexo-github搭建myblog完整版/Hexo本地generate.jpg" alt="Hexo本地生成"></p></li><li><p>Hexo本地运行</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p><img src="/assets/img/Hexo-github搭建myblog完整版/Hexo本地运行.jpg" alt="hexo本地运行"></p><p> <img src="/assets/img/Hexo-github搭建myblog完整版/Hexo本地运行效果图.jpg" alt="Hexo本地运行效果图"></p><hr><h1 id="Part-Two-github仓库创建和配置"><a href="#Part-Two-github仓库创建和配置" class="headerlink" title="Part Two - github仓库创建和配置"></a>Part Two - github仓库创建和配置</h1><hr><h3 id="2-1、github仓库创建"><a href="#2-1、github仓库创建" class="headerlink" title="2.1、github仓库创建"></a>2.1、github仓库创建</h3><ul><li>仓库名字必须是<strong>『username.github.io』</strong>格式；</li><li>创建GitHub Pages<br><img src="/assets/img/Hexo-github搭建myblog完整版/GitHub_Pages创建.jpg" alt="GitHub Pages创建"></li></ul><h3 id="2-2、配置git"><a href="#2-2、配置git" class="headerlink" title="2.2、配置git"></a>2.2、配置git</h3><ul><li><p>设置用户名和邮箱</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email &quot;lionsom_lin@qq.com&quot;</span><br><span class="line">$ git config --global user.name &quot;lionsom&quot;</span><br></pre></td></tr></table></figure></li><li><p>根据邮箱生成密钥 - 如下图，如无特殊需求</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;lionsom_lin@qq.com&quot;</span><br></pre></td></tr></table></figure><p>  <img src="/assets/img/Hexo-github搭建myblog完整版/密钥生成1.jpg" alt="生成密钥具体操作"></p></li><li><p>查看生成的密钥-在隐藏文件 <strong>.ssh</strong> 中，其中<code>id_rsa</code>是私钥，<code>id_rsa.pub</code>是公钥<br><img src="/assets/img/Hexo-github搭建myblog完整版/生成的密钥.jpg" alt="密钥生成路径"></p></li><li><p><code>ssh-agent</code>代管理git<strong>私钥</strong></p><ul><li><code>ssh-agent</code>是一个密钥管理器，运行<code>ssh-agent</code>以后，使用<code>ssh-add</code>将私钥交给<code>ssh-agent</code>保管，其他程序需要身份验证的时候可以将验证申请交给<code>ssh-agent</code>来完成整个认证过程。 </li></ul></li><li><p>添加<code>SSH Key</code>到<code>ssh-agent</code></p><ul><li><p>执行命令 获取 <code>agent pid 59566</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval $(ssh-agent -s)</span><br></pre></td></tr></table></figure></li><li><p>添加<code>id_rsa</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add /Users/lionsom/.ssh/id_rsa</span><br></pre></td></tr></table></figure></li></ul></li><li><p>将生成的公钥 配置到 github</p><ul><li>记事本打开<code>id_rsa.pub</code>密钥，复制内容，前往github账户中心<code>Settings</code>,进行如下图操作。<br><img src="/assets/img/Hexo-github搭建myblog完整版/公钥添加到github.jpg" alt="公钥添加"></li></ul></li><li><p>验证<strong>SSH</strong>是否配置完成</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>  成功则出现</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You&apos;ve successfully authenticated, but github does not provide shell access.</span><br></pre></td></tr></table></figure><p>  如图：<br><img src="/assets/img/Hexo-github搭建myblog完整版/密钥添加.jpg" alt="添加是否完成"></p></li></ul><hr><h1 id="Part-Three-本地Hexo关联github"><a href="#Part-Three-本地Hexo关联github" class="headerlink" title="Part Three - 本地Hexo关联github"></a>Part Three - 本地Hexo关联github</h1><hr><h3 id="3-1、配置-config-yml"><a href="#3-1、配置-config-yml" class="headerlink" title="3.1、配置_config.yml"></a>3.1、配置<strong>_config.yml</strong></h3><p><img src="/assets/img/Hexo-github搭建myblog完整版/config.yml.jpg" alt="具体配置"></p><h3 id="3-2、前往Hexo本地目录生成静态网页并Deploy到github"><a href="#3-2、前往Hexo本地目录生成静态网页并Deploy到github" class="headerlink" title="3.2、前往Hexo本地目录生成静态网页并Deploy到github"></a>3.2、前往Hexo本地目录生成静态网页并Deploy到github</h3><ul><li>确认依赖包和插件安装完成，特别是<code>hexo-deployer-git</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>指令操作</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean  #清理缓存</span><br><span class="line">$ hexo g      #生成静态文件</span><br><span class="line">$ hexo d      #部署</span><br><span class="line">或 $ hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>实际操作图</p><ul><li>清理缓存+重新生成静态文件<br><img src="/assets/img/Hexo-github搭建myblog完整版/clean+generate.jpg" alt="清理缓存+重新生成静态文件"></li><li>部署到github<br><img src="/assets/img/Hexo-github搭建myblog完整版/deploy.jpg" alt="部署到github"></li></ul></li><li><p>输入<a href="https://lionsom.github.io" target="_blank" rel="noopener">https://lionsom.github.io</a>查看<br>  <img src="/assets/img/Hexo-github搭建myblog完整版/部署成功.jpg" alt="部署成功"></p></li></ul><hr><hr><h1 id="以上就能实现基本的个人blog"><a href="#以上就能实现基本的个人blog" class="headerlink" title="以上就能实现基本的个人blog"></a>以上就能实现基本的个人blog</h1><hr><hr><h4 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h4><ul><li><a href="https://www.jianshu.com/p/148f8d803e80" target="_blank" rel="noopener">我特么搭个博客容易么[Hexo+githubPages]（一）</a></li><li><a href="https://www.jianshu.com/p/f47ac6081f30" target="_blank" rel="noopener">我特么搭个博客容易么[Hexo+githubPages]（二）</a></li><li><a href="https://www.jianshu.com/p/fae0d7ecc486" target="_blank" rel="noopener">我特么搭个博客容易么[Hexo+githubPages]（三）</a></li><li><a href="https://www.jianshu.com/p/a1778c515a33" target="_blank" rel="noopener">使用Hexo在GitHub Pages上搭建部署免费的个人博客网站（上：GitHub搭建）——最详细全面解读教程（没有之一）</a></li><li><a href="https://www.jianshu.com/p/c9295bacd98b" target="_blank" rel="noopener">使用Hexo在GitHub Pages上搭建部署免费的个人博客网站（下：Hexo部署）——最详细全面解读教程（没有之一）</a></li></ul><hr><h1 id="Part-Four-绑定域名并设置域名解析"><a href="#Part-Four-绑定域名并设置域名解析" class="headerlink" title="Part Four - 绑定域名并设置域名解析"></a>Part Four - 绑定域名并设置域名解析</h1><hr><blockquote><p><strong>GitHub为我们每个注册的用户提供了一个唯一的 <code>username.github.io</code> 网址，GitHub服务器会帮我们托管这个 <code>username.github.io</code> 所用到的全部代码，自动运行，所以我们就不需要购买服务器或者云主机来自己运行了。但是，我们之所以购买域名，就是不想总是通过 <code>username.github.io</code> 来访问我们的个人网站，而是希望通过自己的独立域名来访问。把 <code>username.github.io</code> 和自己购买的域名相关联</strong></p></blockquote><h2 id="方法一：（不推荐）"><a href="#方法一：（不推荐）" class="headerlink" title="方法一：（不推荐）"></a>方法一：（不推荐）</h2><h4 id="1、进入github项目中的Settings中，找到Github-Pages中的Custom-domain，输入自己的域名，点击Save即可。"><a href="#1、进入github项目中的Settings中，找到Github-Pages中的Custom-domain，输入自己的域名，点击Save即可。" class="headerlink" title="1、进入github项目中的Settings中，找到Github Pages中的Custom domain，输入自己的域名，点击Save即可。"></a>1、进入github项目中的<code>Settings</code>中，找到<code>Github Pages</code>中的<code>Custom domain</code>，输入自己的域名，点击Save即可。</h4><p><img src="/assets/img/Hexo-github搭建myblog完整版/github域名添加.jpg" alt="github域名添加"></p><h4 id="2、查看项目中多了-CNAME-文件"><a href="#2、查看项目中多了-CNAME-文件" class="headerlink" title="2、查看项目中多了 CNAME 文件"></a>2、查看项目中多了 <code>CNAME</code> 文件</h4><p><img src="/assets/img/Hexo-github搭建myblog完整版/github域名添加成功.jpg" alt="github域名添加成功"></p><h4 id="3、域名解析"><a href="#3、域名解析" class="headerlink" title="3、域名解析"></a>3、域名解析</h4><ul><li>记录类型：CNAME，主机记录：@，记录值一定要是 username.github.io，TTL：一般都是10分钟。<br><img src="/assets/img/Hexo-github搭建myblog完整版/域名解析设置.jpg" alt="域名解析"></li></ul><h4 id="4、检测是否绑定成功"><a href="#4、检测是否绑定成功" class="headerlink" title="4、检测是否绑定成功"></a>4、检测是否绑定成功</h4><p><img src="/assets/img/Hexo-github搭建myblog完整版/域名解析成功.jpg" alt="域名解析成功"></p><h4 id="5、此方法弊端"><a href="#5、此方法弊端" class="headerlink" title="5、此方法弊端"></a>5、此方法弊端</h4><p>如果重新generate并deploy，域名与<code>username.github.io</code>关联失效，需要重新设置一遍。</p><h2 id="方式二：（推荐）"><a href="#方式二：（推荐）" class="headerlink" title="方式二：（推荐）"></a>方式二：（推荐）</h2><h4 id="1、在本地hexo根目录-》source中创建文件『CNAME』，写入域名lionsom-com"><a href="#1、在本地hexo根目录-》source中创建文件『CNAME』，写入域名lionsom-com" class="headerlink" title="1、在本地hexo根目录-》source中创建文件『CNAME』，写入域名lionsom.com"></a>1、在本地hexo根目录-》source中创建文件『CNAME』，写入域名<code>lionsom.com</code></h4><p><img src="/assets/img/Hexo-github搭建myblog完整版/本地创建CNAME文件.jpg" alt="操作如图"></p><h4 id="2、重新部署一次，查看结果"><a href="#2、重新部署一次，查看结果" class="headerlink" title="2、重新部署一次，查看结果"></a>2、重新部署一次，查看结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean  #清理缓存</span><br><span class="line">$ hexo g      #生成静态文件</span><br><span class="line">$ hexo d      #部署</span><br></pre></td></tr></table></figure><p><img src="/assets/img/Hexo-github搭建myblog完整版/github多出CNAME文件.jpg" alt="多出CNAME文件"></p><p><img src="/assets/img/Hexo-github搭建myblog完整版/域名解析成功2.jpg" alt="解析成功"></p><h4 id="域名绑定完成！！"><a href="#域名绑定完成！！" class="headerlink" title="域名绑定完成！！"></a>域名绑定完成！！</h4><hr><h1 id="Part-Five-Hexo日常操作"><a href="#Part-Five-Hexo日常操作" class="headerlink" title="Part Five - Hexo日常操作"></a>Part Five - Hexo日常操作</h1><hr><h3 id="官网-1"><a href="#官网-1" class="headerlink" title="官网"></a>官网</h3><p><a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="noopener">hexo官网使用-基本操作</a></p><h3 id="5-1、进行常用的配置"><a href="#5-1、进行常用的配置" class="headerlink" title="5.1、进行常用的配置"></a>5.1、进行常用的配置</h3><h4 id="5-1-1、layout设置"><a href="#5-1-1、layout设置" class="headerlink" title="5.1.1、layout设置"></a>5.1.1、layout设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，<br>默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><h4 id="5-1-2、文件名称设置"><a href="#5-1-2、文件名称设置" class="headerlink" title="5.1.2、文件名称设置"></a>5.1.2、文件名称设置</h4><p>Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Writing</span><br><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure><h4 id="5-1-3、模版（Scaffold）设置"><a href="#5-1-3、模版（Scaffold）设置" class="headerlink" title="5.1.3、模版（Scaffold）设置"></a>5.1.3、模版（Scaffold）设置</h4><p><a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">hexo官网使用-Front-matter</a></p><p><img src="/assets/img/Hexo-github搭建myblog完整版/front-matter.jpg" alt="front-matter"></p><p><img src="/assets/img/Hexo-github搭建myblog完整版/Scaffold设置.jpg" alt="Scaffold设置"></p><h4 id="5-1-4、资源设置-图片等"><a href="#5-1-4、资源设置-图片等" class="headerlink" title="5.1.4、资源设置-图片等"></a>5.1.4、资源设置-图片等</h4><p><a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="noopener">hexo官网使用-资源文件夹</a></p><blockquote><p>文章资源文件夹</p><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p><strong>使用相对路径进行资源引用：<code>./XXXX.jpg</code></strong></p><h3 id="5-2、创建新blog"><a href="#5-2、创建新blog" class="headerlink" title="5.2、创建新blog"></a>5.2、创建新blog</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new blog_name</span><br></pre></td></tr></table></figure><p>生成两个文件：blog_name.md 和 blog_name资源文件夹</p><hr><h1 id="Part-Six-Hexo主题更换"><a href="#Part-Six-Hexo主题更换" class="headerlink" title="Part Six - Hexo主题更换"></a>Part Six - Hexo主题更换</h1><hr><h3 id="6-1、主题设置"><a href="#6-1、主题设置" class="headerlink" title="6.1、主题设置"></a>6.1、主题设置</h3><p><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">github主题列表地址</a></p><p><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a></p><h4 id="6-1-1、将主题clone到themes文件夹中"><a href="#6-1-1、将主题clone到themes文件夹中" class="headerlink" title="6.1.1、将主题clone到themes文件夹中"></a>6.1.1、将主题clone到themes文件夹中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LionsomMBP:myblog lionsom$ cd themes/</span><br><span class="line">LionsomMBP:themes lionsom$ git clone https://github.com/litten/hexo-theme-yilia.git</span><br></pre></td></tr></table></figure><h4 id="6-1-2、修改Hexo的-config-yml文件配置"><a href="#6-1-2、修改Hexo的-config-yml文件配置" class="headerlink" title="6.1.2、修改Hexo的_config.yml文件配置"></a>6.1.2、修改Hexo的_config.yml文件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: hexo-theme-yilia</span><br></pre></td></tr></table></figure><h4 id="6-1-3、重新加载"><a href="#6-1-3、重新加载" class="headerlink" title="6.1.3、重新加载"></a>6.1.3、重新加载</h4><p><img src="/assets/img/Hexo-github搭建myblog完整版/主题更换成功.jpg" alt="显示主题效果"></p><h3 id="6-2、yilia主题内部设置"><a href="#6-2、yilia主题内部设置" class="headerlink" title="6.2、yilia主题内部设置"></a>6.2、yilia主题内部设置</h3><ul><li><p>直接参考yilia原版配置，参考配置即可！！</p><ul><li><p><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia 官网</a></p></li><li><p><a href="https://github.com/litten/BlogBackup" target="_blank" rel="noopener">yilia-BlogBackup 样例</a></p></li></ul></li><li><p>具体配置中遇到个小麻烦-目录显示不出来<br>  <img src="/assets/img/Hexo-github搭建myblog完整版/yilia配置.jpg" alt="目录显示不出来"></p><ul><li>严格按照上述配置即可！</li></ul></li><li><p>yilia内部资源路径的问题</p><ul><li>这里的路径是Hexo根目录下source下点资源，</li><li><p>完整的路径是指Hexo/source/assets/img/wechatpay.jpg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#你的头像url</span><br><span class="line">avatar: /assets/img/wechatpay.jpg</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h1 id="Part-Seven-实战中的一些问题"><a href="#Part-Seven-实战中的一些问题" class="headerlink" title="Part Seven - 实战中的一些问题"></a>Part Seven - 实战中的一些问题</h1><hr><h3 id="7-1、图片资源加载不出来的问题"><a href="#7-1、图片资源加载不出来的问题" class="headerlink" title="7.1、图片资源加载不出来的问题"></a>7.1、图片资源加载不出来的问题</h3><p><img src="/assets/img/Hexo-github搭建myblog完整版/图片加载异常1.jpg" alt=""></p><p><img src="/assets/img/Hexo-github搭建myblog完整版/图片加载异常2.jpg" alt=""></p><p>根据上图点结论，所以，资源路径不推荐5.1.4所推荐的设置，依旧推荐在</p><p><img src="/assets/img/Hexo-github搭建myblog完整版/图片推荐路径.jpg" alt="推荐路径"></p><p><strong>使用路径 /assets/img/myhead.jpg</strong></p><h3 id="7-2、主页面预览，不显示全部内容"><a href="#7-2、主页面预览，不显示全部内容" class="headerlink" title="7.2、主页面预览，不显示全部内容"></a>7.2、主页面预览，不显示全部内容</h3><p><img src="/assets/img/Hexo-github搭建myblog完整版/显示more.jpg" alt="推荐路径"></p><p>我们可以这样解决，打开一篇文章，添加<code>&lt;!--more--&gt;</code>即可！！！</p><h3 id="7-3、设置网页浏览次数"><a href="#7-3、设置网页浏览次数" class="headerlink" title="7.3、设置网页浏览次数"></a>7.3、设置网页浏览次数</h3><p><a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a></p><blockquote><p>如果你是用的hexo，打开<code>themes/你的主题/layout/_partial/footer.ejs</code>添加即可。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 脚本</span><br><span class="line">&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"># 标签</span><br><span class="line">&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">    本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p><img src="/assets/img/Hexo-github搭建myblog完整版/不蒜子设置.jpg" alt="设置"></p><hr><blockquote><h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p><strong>欢迎指正补充，可联系<a href="lionsom_lin@qq.com">lionsom_lin@qq.com</a></strong><br><strong>原文地址：<a href="http://lionsom.com/2018/03/16/Hexo-github搭建myblog完整版/" target="_blank" rel="noopener">Mac+Hexo+github搭建myblog完整版</a></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Part One - Hexo本地搭建运行&lt;/li&gt;
&lt;li&gt;Part Two - github仓库创建和配置&lt;/li&gt;
&lt;li&gt;Part Three - 本地Hexo关联github&lt;/li&gt;
&lt;li&gt;Part Four - 绑定域名并设置域名解析&lt;/li&gt;
&lt;li&gt;Part Five - Hexo日常操作&lt;/li&gt;
&lt;li&gt;Part Six - Hexo主题更换&lt;/li&gt;
&lt;li&gt;Part Seven - 实战中的一些问题&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="myblog搭建" scheme="http://yoursite.com/categories/myblog%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
</feed>
